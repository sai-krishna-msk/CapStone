,links
0,"An operating system acts as an intermediary between the user of a computer and computer hardware. The purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.

An operating system is a software that manages the computer hardware. The hardware must provide appropriate mechanisms to ensure the correct operation of the computer system and to prevent user programs from interfering with the proper operation of the system.

Operating System – Definition:

An operating system is a program that controls the execution of application programs and acts as an interface between the user of a computer and the computer hardware.

A more common definition is that the operating system is the one program running at all times on the computer (usually called the kernel), with all else being application programs.

An operating system is concerned with the allocation of resources and services, such as memory, processors, devices, and information. The operating system correspondingly includes programs to manage these resources, such as a traffic controller, a scheduler, memory management module, I/O programs, and a file system.

Functions of Operating system – Operating system performs three functions:

Convenience: An OS makes a computer more convenient to use. Efficiency: An OS allows the computer system resources to be used in an efficient manner. Ability to Evolve: An OS should be constructed in such a way as to permit the effective development, testing and introduction of new system functions at the same time without interfering with service.

Operating system as User Interface –

User System and application programs Operating system Hardware

Every general-purpose computer consists of the hardware, operating system, system programs, and application programs. The hardware consists of memory, CPU, ALU, and I/O devices, peripheral device, and storage device. System program consists of compilers, loaders, editors, OS, etc. The application program consists of business programs, database programs.



Fig1: Conceptual view of a computer system

Every computer must have an operating system to run other programs. The operating system coordinates the use of the hardware among the various system programs and application programs for various users. It simply provides an environment within which other programs can do useful work.

The operating system is a set of special programs that run on a computer system that allows it to work properly. It performs basic tasks such as recognizing input from the keyboard, keeping track of files and directories on the disk, sending output to the display screen and controlling peripheral devices.

OS is designed to serve two basic purposes:

It controls the allocation and use of the computing System’s resources among the various user and tasks. It provides an interface between the computer hardware and the programmer that simplifies and makes feasible for coding, creation, debugging of application programs.

The Operating system must support the following tasks. The task are:

Provides the facilities to create, modification of programs and data files using an editor. Access to the compiler for translating the user program from high level language to machine language. Provide a loader program to move the compiled program code to the computer’s memory for execution. Provide routines that handle the details of I/O programming.

I/O System Management –

The module that keeps track of the status of devices is called the I/O traffic controller. Each I/O device has a device handler that resides in a separate process associated with that device.

The I/O subsystem consists of

A memory Management component that includes buffering caching and spooling.

A general device driver interface.

Drivers for specific hardware devices.

Assembler –

The input to an assembler is an assembly language program. The output is an object program plus information that enables the loader to prepare the object program for execution. At one time, the computer programmer had at his disposal a basic machine that interpreted, through hardware, certain fundamental instructions. He would program this computer by writing a series of ones and Zeros (Machine language), place them into the memory of the machine.

Compiler –

The High-level languages- examples are FORTRAN, COBOL, ALGOL and PL/I are processed by compilers and interpreters. A compiler is a program that accepts a source program in a “high-level language “and produces a corresponding object program. An interpreter is a program that appears to execute a source program as if it was machine language. The same name (FORTRAN, COBOL, etc.) is often used to designate both a compiler and its associated language.

Loader –

A Loader is a routine that loads an object program and prepares it for execution. There are various loading schemes: absolute, relocating and direct-linking. In general, the loader must load, relocate and link the object program. The loader is a program that places programs into memory and prepares them for execution. In a simple loading scheme, the assembler outputs the machine language translation of a program on a secondary device and a loader places it in the core. The loader places into memory the machine language version of the user’s program and transfers control to it. Since the loader program is much smaller than the assembler, those make more core available to the user’s program.

History of Operating system –

Operating system has been evolving through the years. Following Table shows the history of OS.

Generation Year Electronic device used Types of OS Device First 1945-55 Vaccum Tubes Plug Boards Second 1955-65 Transistors Batch Systems Third 1965-80 Integrated Circuits(IC) Multiprogramming Fourth Since 1980 Large Scale Integration PC

Types of Operating System –

Batch Operating System- Sequence of jobs in a program on a computer without manual interventions.

Time sharing operating System- allows many users to share the computer resources.(Max utilization of the resources).

Distributed operating System- Manages a group of different computers and make appear to be a single computer.

Network operating system- computers running in different operating system can participate in common network (It is used for security purpose).

Real time operating system – meant applications to fix the deadlines.

Examples of Operating System are –

Windows (GUI based, PC)

GNU/Linux (Personal, Workstations, ISP, File and print server, Three-tier client/Server)

macOS (Macintosh), used for Apple’s personal computers and work stations (MacBook, iMac).

Android (Google’s Operating System for smartphones/tablets/smartwatches)

iOS (Apple’s OS for iPhone, iPad and iPod Touch)

References –

Operating System Concepts – Book

Introduction to Operating System – NPTEL

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

This article is contributed by Aluka Madhavi. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.

"
1,"An Operating System performs all the basic tasks like managing file,process, and memory. Thus operating system acts as manager of all the resources, i.e. resource manager. Thus operating system becomes an interface between user and machine.

Types of Operating Systems: Some of the widely used operating systems are as follows-

1. Batch Operating System –

This type of operating system does not interact with the computer directly. There is an operator which takes similar jobs having same requirement and group them into batches. It is the responsibility of operator to sort the jobs with similar needs.

Advantages of Batch Operating System:

It is very difficult to guess or know the time required by any job to complete. Processors of the batch systems know how long the job would be when it is in queue

Multiple users can share the batch systems

The idle time for batch system is very less

It is easy to manage large work repeatedly in batch systems

Disadvantages of Batch Operating System:

The computer operators should be well known with batch systems

Batch systems are hard to debug

It is sometime costly

The other jobs will have to wait for an unknown time if any job fails

Examples of Batch based Operating System: Payroll System, Bank Statements etc.

2. Time-Sharing Operating Systems –

Each task is given some time to execute, so that all the tasks work smoothly. Each user gets time of CPU as they use single system. These systems are also known as Multitasking Systems. The task can be from single user or from different users also. The time that each task gets to execute is called quantum. After this time interval is over OS switches over to next task.

Advantages of Time-Sharing OS:

Each task gets an equal opportunity

Less chances of duplication of software

CPU idle time can be reduced

Disadvantages of Time-Sharing OS:

Reliability problem

One must have to take care of security and integrity of user programs and data

Data communication problem

Examples of Time-Sharing OSs are: Multics, Unix etc.

3. Distributed Operating System –

These types of operating system is a recent advancement in the world of computer technology and are being widely accepted all-over the world and, that too, with a great pace. Various autonomous interconnected computers communicate each other using a shared communication network. Independent systems possess their own memory unit and CPU. These are referred as loosely coupled systems or distributed systems. These system’s processors differ in size and function. The major benefit of working with these types of operating system is that it is always possible that one user can access the files or software which are not actually present on his system but on some other system connected within this network i.e., remote access is enabled within the devices connected in that network.

Advantages of Distributed Operating System:

Failure of one will not affect the other network communication, as all systems are independent from each other

Electronic mail increases the data exchange speed

Since resources are being shared, computation is highly fast and durable

Load on host computer reduces

These systems are easily scalable as many systems can be easily added to the network

Delay in data processing reduces

Disadvantages of Distributed Operating System:

Failure of the main network will stop the entire communication

To establish distributed systems the language which are used are not well defined yet

These types of systems are not readily available as they are very expensive. Not only that the underlying software is highly complex and not understood well yet

Examples of Distributed Operating System are- LOCUS etc.

4. Network Operating System –

These systems run on a server and provide the capability to manage data, users, groups, security, applications, and other networking functions. These type of operating systems allow shared access of files, printers, security, applications, and other networking functions over a small private network. One more important aspect of Network Operating Systems is that all the users are well aware of the underlying configuration, of all other users within the network, their individual connections etc. and that’s why these computers are popularly known as tightly coupled systems.

Advantages of Network Operating System:

Highly stable centralized servers

Security concerns are handled through servers

New technologies and hardware up-gradation are easily integrated to the system

Server access are possible remotely from different locations and types of systems

Disadvantages of Network Operating System:

Servers are costly

User has to depend on central location for most operations

Maintenance and updates are required regularly

Examples of Network Operating System are: Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD etc.

5. Real-Time Operating System –

These types of OSs serves the real-time systems. The time interval required to process and respond to inputs is very small. This time interval is called response time.

Real-time systems are used when there are time requirements are very strict like missile systems, air traffic control systems, robots etc.

Two types of Real-Time Operating System which are as follows:

Hard Real-Time Systems:

These OSs are meant for the applications where time constraints are very strict and even the shortest possible delay is not acceptable. These systems are built for saving life like automatic parachutes or air bags which are required to be readily available in case of any accident. Virtual memory is almost never found in these systems.

These OSs are meant for the applications where time constraints are very strict and even the shortest possible delay is not acceptable. These systems are built for saving life like automatic parachutes or air bags which are required to be readily available in case of any accident. Virtual memory is almost never found in these systems. Soft Real-Time Systems:

These OSs are for applications where for time-constraint is less strict.

Advantages of RTOS:

Maximum Consumption: Maximum utilization of devices and system,thus more output from all the resources

Maximum utilization of devices and system,thus more output from all the resources Task Shifting: Time assigned for shifting tasks in these systems are very less. For example in older systems it takes about 10 micro seconds in shifting one task to another and in latest systems it takes 3 micro seconds.

Time assigned for shifting tasks in these systems are very less. For example in older systems it takes about 10 micro seconds in shifting one task to another and in latest systems it takes 3 micro seconds. Focus on Application: Focus on running applications and less importance to applications which are in queue.

Focus on running applications and less importance to applications which are in queue. Real time operating system in embedded system: Since size of programs are small, RTOS can also be used in embedded systems like in transport and others.

Since size of programs are small, RTOS can also be used in embedded systems like in transport and others. Error Free: These types of systems are error free.

These types of systems are error free. Memory Allocation: Memory allocation is best managed in these type of systems.

Disadvantages of RTOS:"
2,"Prerequisite – Introduction of Operating System – Set 1

An Operating System acts as a communication bridge (interface) between the user and computer hardware. The purpose of an operating system is to provide a platform on which a user can execute programs in a convenient and efficient manner.

An operating system is a piece of software that manages the allocation of computer hardware. The coordination of the hardware must be appropriate to ensure the correct working of the computer system and to prevent user programs from interfering with the proper working of the system.

Example: Just like a boss gives order to his employee, in the similar way we request or pass our orders to the Operating System. The main goal of the Operating System is to thus make the computer environment more convenient to use and the secondary goal is to use the resources in the most efficient manner.

What is Operating System ?

An operating system is a program on which application programs are executed and acts as an communication bridge (interface) between the user and the computer hardware.

The main task an operating system carries out is the allocation of resources and services, such as allocation of: memory, devices, processors and information. The operating system also includes programs to manage these resources, such as a traffic controller, a scheduler, memory management module, I/O programs, and a file system.

Important functions of an operating System:

Security –

The operating system uses password protection to protect user data and similar other techniques. it also prevents unauthorized access to programs and user data. Control over system performance –

Monitors overall system health to help improve performance. records the response time between service requests and system response to have a complete view of the system health. This can help improve performance by providing important information needed to troubleshoot problems. Job accounting –

Operating system Keeps track of time and resources used by various tasks and users, this information can be used to track resource usage for a particular user or group of user. Error detecting aids –

Operating system constantly monitors the system to detect errors and avoid the malfunctioning of computer system.



Coordination between other software and users –

Operating systems also coordinate and assign interpreters, compilers, assemblers and other software to the various users of the computer systems. Memory Management –

The operating system manages the Primary Memory or Main Memory. Main memory is made up of a large array of bytes or words where each byte or word is assigned a certain address. Main memory is a fast storage and it can be accessed directly by the CPU. For a program to be executed, it should be first loaded in the main memory. An Operating System performs the following activities for memory management: It keeps tracks of primary memory, i.e., which bytes of memory are used by which user program. The memory addresses that have already been allocated and the memory addresses of the memory that has not yet been used. In multi programming, the OS decides the order in which process are granted access to memory, and for how long. It Allocates the memory to a process when the process requests it and deallocates the memory when the process has terminated or is performing an I/O operation. Processor Management –

In a multi programming environment, the OS decides the order in which processes have access to the processor, and how much processing time each process has. This function of OS is called process scheduling. An Operating System performs the following activities for processor management. Keeps tracks of the status of processes. The program which perform this task is known as traffic controller. Allocates the CPU that is processor to a process. De-allocates processor when a process is no more required. Device Management –

An OS manages device communication via their respective drivers. It performs the following activities for device management. Keeps tracks of all devices connected to system. designates a program responsible for every device known as the Input/Output controller. Decides which process gets access to a certain device and for how long. Allocates devices in an effective and efficient way. Deallocates devices when they are no longer required. File Management –

A file system is organized into directories for efficient or easy navigation and usage. These directories may contain other directories and other files. An Operating System carries out the following file management activities. It keeps track of where information is stored, user access settings and status of every file and more… These facilities are collectively known as the file system.

Moreover, Operating System also provides certain services to the computer system in one form or the other.

The Operating System provides certain services to the users which can be listed in the following manner:

Program Execution: The Operating System is responsible for execution of all types of programs whether it be user programs or system programs. The Operating System utilises various resources available for the efficient running of all types of functionalities. Handling Input/Output Operations: The Operating System is responsible for handling all sort of inputs, i.e, from keyboard, mouse, desktop, etc. The Operating System does all interfacing in the most appropriate manner regrading all kind of Inputs and Outputs.

For example, there is difference in nature of all types of peripheral devices such as mouse or keyboard, then Operating System is responsible for handling data between them. Manipulation of File System: The Operating System is responsible for making of decisions regarding the storage of all types of data or files, i.e, floppy disk/hard disk/pen drive, etc. The Operating System decides as how should the data should be manipulated and stored. Error Detection and Handling: The Operating System is responsible for detection of any types of error or bugs that can occur while any task. The well secured OS sometimes also acts as countermeasure for preventing any sort of breach to the Computer System from any external source and probably handling them. Resource Allocation: The Operating System ensures the proper use of all the resources available by deciding which resource to be used by whom for how much time. All the decisions are taken by the Operating System. Accounting: The Operating System tracks an account of all the functionalities taking place in the computer system at a time. All the details such as the types of errors occurred are recorded by the Operating System. Information and Resource Protection: The Operating System is responsible for using all the information and resources available on the machine in the most protected way. The Operating System must foil an attempt from any external resource to hamper any sort of data or information.

All these services are ensured by the Operating System for the convenience of the users to make the programming task easier. All different kinds of Operating System more or less provide the same services.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Amaninder.Singh A student of Btech Interested in coding and know languages like java C and many more

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : KarimKamel, skylags"
3,"Real time system means that the system is subjected to real time, i.e., response should be guaranteed within a specified timing constraint or system should meet the specified deadline. For example: flight control system, real time monitors etc.

Types of real time systems based on timing constraints:

Hard real time system –

This type of system can never miss its deadline. Missing the deadline may have disastrous consequences.The usefulness of result produced by a hard real time system decreases abruptly and may become negative if tardiness increases. Tardiness means how late a real time system completes its task with respect to its deadline. Example: Flight controller system. Soft real time system –

This type of system can miss its deadline occasionally with some acceptably low probability. Missing the deadline have no disastrous consequences. The usefulness of result produced by a soft real time system decreases gradually with increase in tardiness. Example: Telephone switches.

Reference model of real time system: Our reference model is characterized by three elements:

A workload model: It specifies the application supported by system. A resource model: It specifies the resources available to the application. Algorithms: It specifies how the application system will use resources.

Terms related to real time system:

Job – A job is a small piece of work that can be assigned to a processor and may or may not require resources.

A job is a small piece of work that can be assigned to a processor and may or may not require resources. Task – A set of related jobs that jointly provide some system functionality.

A set of related jobs that jointly provide some system functionality. Release time of a job – It is the time at which job becomes ready for execution.

It is the time at which job becomes ready for execution. Execution time of a job – It is the time taken by job to finish its execution.

It is the time taken by job to finish its execution. Deadline of a job – It is the time by which a job should finish its execution. Deadline is of two types: absolute deadline and relative deadline.

It is the time by which a job should finish its execution. Deadline is of two types: absolute deadline and relative deadline. Response time of a job – It is the length of time from release time of a job to the instant when it finishes.

It is the length of time from release time of a job to the instant when it finishes. Maximum allowable response time of a job is called its relative deadline.

Absolute deadline of a job is equal to its relative deadline plus its release time.

Processors are also known as active resources. They are essential for execution of a job. A job must have one or more processors in order to execute and proceed towards completion. Example: computer, transmission links.

Resources are also known as passive resources. A job may or may not require a resource during its execution. Example: memory, mutex

Two resources are identical if they can be used interchangeably else they are heterogeneous.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : krishnakoumar27"
4,"The system is subjected to real time, i.e. response should be guaranteed within a specified timing constraint or system should meet the specified deadline. For example flight control system, real-time monitors etc.

There are two types of tasks in real-time systems:

Periodic tasks Dynamic tasks

Periodic Tasks: In periodic task, jobs are released at regular intervals. A periodic task is one which repeats itself after a fixed time interval. A periodic task is denoted by five tuples: T i = < Φ i , P i , e i , D i >

Where, Φ i – is the phase of the task. Phase is release time of the first job in the task. If the phase is not mentioned then release time of first job is assumed to be zero. P i – is the period of the task i.e. the time interval between the release times of two consecutive jobs. e i – is the execution time of the task. D i – is the relative deadline of the task. For example: Consider the task T i with period = 5 and execution time = 3

Phase is not given so, assume the release time of the first job as zero. So the job of this task is first released at t = 0 then it executes for 3s and then next job is released at t = 5 which executes for 3s and then next job is released at t = 10. So jobs are released at t = 5k where k = 0, 1, . . ., n

Hyper period of a set of periodic tasks is the least common multiple of periods of all the tasks in that set. For example, two tasks T 1 and T 2 having period 4 and 5 respectively will have a hyper period, H = lcm(p1, p2) = lcm(4, 5) = 20. The hyper period is the time after which pattern of job release times starts to repeat.

In periodic task, jobs are released at regular intervals. A periodic task is one which repeats itself after a fixed time interval. A periodic task is denoted by five tuples: Where, Dynamic Tasks: It is a sequential program that is invoked by the occurrence of an event. An event may be generated by the processes external to the system or by processes internal to the system. Dynamically arriving tasks can be categorized on their criticality and knowledge about their occurrence times. Aperiodic Tasks: In this type of task, jobs are released at arbitrary time intervals i.e. randomly. Aperiodic tasks have soft deadlines or no deadlines. Sporadic Tasks: They are similar to aperiodic tasks i.e. they repeat at random instances. The only difference is that sporadic tasks have hard deadlines. A speriodic task is denoted by three tuples: T i =(e i , g i , D i )

Where

e i – the execution time of the task.

g i – the minimum separation between the occurrence of two consecutive instances of the task.

D i – the relative deadline of the task.

It is a sequential program that is invoked by the occurrence of an event. An event may be generated by the processes external to the system or by processes internal to the system. Dynamically arriving tasks can be categorized on their criticality and knowledge about their occurrence times.

Jitter: Sometimes actual release time of a job is not known. Only know that r i is in a range [ r i -, r i + ]. This range is known as release time jitter. Here r i – is how early a job can be released and r i + is how late a job can be released. Only range [ e i -, e i + ] of the execution time of a job is known. Here e i – is the minimum amount of time required by a job to complete its execution and e i + the maximum amount of time required by a job to complete its execution.

Precedence Constraint of Jobs: Jobs in a task are independent if they can be executed in any order. If there is a specific order in which jobs in a task have to be executed then jobs are said to have precedence constraints. For representing precedence constraints of jobs a partial order relation < is used. This is called precedence relation. A job J i is a predecessor of job J j if J i < J j i.e. J j cannot begin its execution until J i completes. J i is an immediate predecessor of J j if J i < J j and there is no other job J k such that J i < J k < J j . J i and J j are independent if neither J i < J j nor J j < J i is true.

An efficient way to represent precedence constraints is by using a directed graph G = (J, <) where J is the set of jobs. This graph is known as the precedence graph. Jobs are represented by vertices of graph and precedence constraints are represented using directed edges. If there is a directed edge from J i to J j then it means that J i is immediate predecessor of J j . For example: Consider a task T having 5 jobs J 1 , J 2 , J 3 , J 4 and J 5 such that J 2 and J 5 cannot begin their execution until J 1 completes and there are no other constraints.

The precedence constraints for this example are:

J 1 < J 2 and J 1 < J 5

Set representation of precedence graph:

< (1) = { } < (2) = {1} < (3) = { } < (4) = { } < (5) = {1}

Consider another example where precedence graph is given and you have to find precedence constraints

From the above graph, we derive the following precedence constraints:

J 1 < J 2 J 2 < J 3 J 2 < J 4 J 3 < J 4

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : dcbleo"
5,"Multiprogramming – A computer running more than one program at a time (like running Excel and Firefox simultaneously). Multiprocessing – A computer using more than one CPU at a time. Multitasking – Tasks sharing a common resource (like 1 CPU). Multithreading is an extension of multitasking.

1. Multi programming –

In a modern computing system, there are usually several concurrent application processes which want to execute. Now it is the responsibility of the Operating System to manage all the processes effectively and efficiently.

One of the most important aspects of an Operating System is to multi program.

In a computer system, there are multiple processes waiting to be executed, i.e. they are waiting when the CPU will be allocated to them and they begin their execution. These processes are also known as jobs. Now the main memory is too small to accommodate all of these processes or jobs into it. Thus, these processes are initially kept in an area called job pool. This job pool consists of all those processes awaiting allocation of main memory and CPU.

CPU selects one job out of all these waiting jobs, brings it from the job pool to main memory and starts executing it. The processor executes one job until it is interrupted by some external factor or it goes for an I/O task.

Non-multi programmed system’s working –

In a non multi programmed system, As soon as one job leaves the CPU and goes for some other task (say I/O ), the CPU becomes idle. The CPU keeps waiting and waiting until this job (which was executing earlier) comes back and resumes its execution with the CPU. So CPU remains free for all this while.

Now it has a drawback that the CPU remains idle for a very long period of time. Also, other jobs which are waiting to be executed might not get a chance to execute because the CPU is still allocated to the earlier job.

This poses a very serious problem that even though other jobs are ready to execute, CPU is not allocated to them as the CPU is allocated to a job which is not even utilizing it (as it is busy in I/O tasks).

This poses a very serious problem that even though other jobs are ready to execute, CPU is not allocated to them as the CPU is allocated to a job which is not even utilizing it (as it is busy in I/O tasks). It cannot happen that one job is using the CPU for say 1 hour while the others have been waiting in the queue for 5 hours. To avoid situations like this and come up with efficient utilization of CPU, the concept of multi programming came up.

The main idea of multi programming is to maximize the CPU time.

Multi programmed system’s working –

In a multi-programmed system, as soon as one job goes for an I/O task, the Operating System interrupts that job, chooses another job from the job pool (waiting queue), gives CPU to this new job and starts its execution. The previous job keeps doing its I/O operation while this new job does CPU bound tasks. Now say the second job also goes for an I/O task, the CPU chooses a third job and starts executing it. As soon as a job completes its I/O operation and comes back for CPU tasks, the CPU is allocated to it.

In this way, no CPU time is wasted by the system waiting for the I/O task to be completed.

Therefore, the ultimate goal of multi programming is to keep the CPU busy as long as there are processes ready to execute. This way, multiple programs can be executed on a single processor by executing a part of a program at one time, a part of another program after this, then a part of another program and so on, hence executing multiple programs. Hence, the CPU never remains idle.

In the image below, program A runs for some time and then goes to waiting state. In the mean time program B begins its execution. So the CPU does not waste its resources and gives program B an opportunity to run.

2. Multiprocessing –

In a uni-processor system, only one process executes at a time.

Multiprocessing is the use of two or more CPUs (processors) within a single Computer system. The term also refers to the ability of a system to support more than one processor within a single computer system. Now since there are multiple processors available, multiple processes can be executed at a time. These multi processors share the computer bus, sometimes the clock, memory and peripheral devices also.

Multi processing system’s working –

With the help of multiprocessing, many processes can be executed simultaneously. Say processes P1, P2, P3 and P4 are waiting for execution. Now in a single processor system, firstly one process will execute, then the other, then the other and so on.

But with multiprocessing, each process can be assigned to a different processor for its execution. If its a dual-core processor (2 processors), two processes can be executed simultaneously and thus will be two times faster, similarly a quad core processor will be four times as fast as a single processor.

Why use multi processing –

The main advantage of multiprocessor system is to get more work done in a shorter period of time. These types of systems are used when very high speed is required to process a large volume of data. Multi processing systems can save money in comparison to single processor systems because the processors can share peripherals and power supplies.

It also provides increased reliability in the sense that if one processor fails, the work does not halt, it only slows down. e.g. if we have 10 processors and 1 fails, then the work does not halt, rather the remaining 9 processors can share the work of the 10th processor. Thus the whole system runs only 10 percent slower, rather than failing altogether.

Multiprocessing refers to the hardware (i.e., the CPU units) rather than the software (i.e., running processes). If the underlying hardware provides more than one processor then that is multiprocessing. It is the ability of the system to leverage multiple processors’ computing power.

Difference between Multi programming and Multi processing –

A System can be both multi programmed by having multiple programs running at the same time and multiprocessing by having more than one physical processor. The difference between multiprocessing and multi programming is that Multiprocessing is basically executing multiple processes at the same time on multiple processors, whereas multi programming is keeping several programs in main memory and executing them concurrently using a single CPU only.

Multiprocessing occurs by means of parallel processing whereas Multi programming occurs by switching from one process to other (phenomenon called as context switching).

3. Multitasking –

As the name itself suggests, multi tasking refers to execution of multiple tasks (say processes, programs, threads etc.) at a time. In the modern operating systems, we are able to play MP3 music, edit documents in Microsoft Word, surf the Google Chrome all simultaneously, this is accomplished by means of multi tasking.

Multitasking is a logical extension of multi programming. The major way in which multitasking differs from multi programming is that multi programming works solely on the concept of context switching whereas multitasking is based on time sharing alongside the concept of context switching.

Multi tasking system’s working –

In a time sharing system, each process is assigned some specific quantum of time for which a process is meant to execute. Say there are 4 processes P1, P2, P3, P4 ready to execute. So each of them are assigned some time quantum for which they will execute e.g time quantum of 5 nanoseconds (5 ns). As one process begins execution (say P2), it executes for that quantum of time (5 ns). After 5 ns the CPU starts the execution of the other process (say P3) for the specified quantum of time.

Thus the CPU makes the processes to share time slices between them and execute accordingly. As soon as time quantum of one process expires, another process begins its execution.

Here also basically a context switch is occurring but it is occurring so fast that the user is able to interact with each program separately while it is running. This way, the user is given the illusion that multiple processes/ tasks are executing simultaneously. But actually only one process/ task is executing at a particular instant of time. In multitasking, time sharing is best manifested because each running process takes only a fair quantum of the CPU time.

In a more general sense, multitasking refers to having multiple programs, processes, tasks, threads running at the same time. This term is used in modern operating systems when multiple tasks share a common processing resource (e.g., CPU and Memory).

As depicted in the above image, At any time the CPU is executing only one task while other tasks are waiting for their turn. The illusion of parallelism is achieved when the CPU is reassigned to another task. i.e all the three tasks A, B and C are appearing to occur simultaneously because of time sharing.

So for multitasking to take place, firstly there should be multiprogramming i.e. presence of multiple programs ready for execution. And secondly the concept of time sharing.

4. Multi threading –

A thread is a basic unit of CPU utilization. Multi threading is an execution model that allows a single process to have multiple code segments (i.e., threads) running concurrently within the “context” of that process.

e.g. VLC media player, where one thread is used for opening the VLC media player, one thread for playing a particular song and another thread for adding new songs to the playlist.

Multi threading is the ability of a process to manage its use by more than one user at a time and to manage multiple requests by the same user without having to have multiple copies of the program.

Multi threading system’s working –

Example 1 –

Say there is a web server which processes client requests. Now if it executes as a single threaded process, then it will not be able to process multiple requests at a time. Firstly one client will make its request and finish its execution and only then, the server will be able to process another client request. This is really costly, time consuming and tiring task. To avoid this, multi threading can be made use of.

Now, whenever a new client request comes in, the web server simply creates a new thread for processing this request and resumes its execution to hear more client requests. So the web server has the task of listening to new client requests and creating threads for each individual request. Each newly created thread processes one client request, thus reducing the burden on web server.

Example 2 –

We can think of threads as child processes that share the parent process resources but execute independently. Now take the case of a GUI. Say we are performing a calculation on the GUI (which is taking very long time to finish). Now we can not interact with the rest of the GUI until this command finishes its execution. To be able to interact with the rest of the GUI, this command of calculation should be assigned to a separate thread. So at this point of time, 2 threads will be executing i.e. one for calculation, and one for the rest of the GUI. Hence here in a single process, we used multiple threads for multiple functionality.

The image below completely describes the VLC player example:

Advantages of Multi threading –

Benefits of Multi threading include increased responsiveness. Since there are multiple threads in a program, so if one thread is taking too long to execute or if it gets blocked, the rest of the threads keep executing without any problem. Thus the whole program remains responsive to the user by means of remaining threads.

Another advantage of multi threading is that it is less costly. Creating brand new processes and allocating resources is a time consuming task, but since threads share resources of the parent process, creating threads and switching between them is comparatively easy. Hence multi threading is the need of modern Operating Systems.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
6,"Memory is the most essential element of a computing system because without it computer can’t perform simple tasks. Computer memory is of two basic type – Primary memory(RAM and ROM) and Secondary memory(hard drive,CD,etc.). Random Access Memory (RAM) is primary-volatile memory and Read Only Memory (ROM) is primary-non-volatile memory.

1. Random Access Memory (RAM) –

2. Read Only Memory (ROM) –

Types of Read Only Memory (ROM) –

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below."
7,"In computing, there exist two type processor i.e., 32-bit and 64-bit. This type of processor tells us how much memory a processor can have access from a CPU register. For instance,

A 32-bit system can access 232 memory addresses, i.e 4 GB of RAM or physical memory ideally, it can access more than 4 GB of RAM also.

A 64-bit system can access 264 memory addresses, i.e actually 18-Quintillion bytes of RAM. In short, any amount of memory greater than 4 GB can be easily handled by it.

Most computers made in the 1990s and early 2000s were 32-bit machines. The CPU register stores memory addresses, which is how the processor accesses data from RAM. One bit in the register can reference an individual byte in memory, so a 32-bit system can address a maximum of 4 GB (4,294,967,296 bytes) of RAM. The actual limit is often less around 3.5 GB since part of the register is used to store other temporary values besides memory addresses. Most computers released over the past two decades were built on a 32-bit architecture, hence most operating systems were designed to run on a 32-bit processor.

A 64-bit register can theoretically reference 18,446,744,073,709,551,616 bytes, or 17,179,869,184 GB (16 exabytes) of memory. This is several million times more than an average workstation would need to access. What’s important is that a 64-bit computer (which means it has a 64-bit processor) can access more than 4 GB of RAM. If a computer has 8 GB of RAM, it better has a 64-bit processor. Otherwise, at least 4 GB of the memory will be inaccessible by the CPU.

A major difference between 32-bit processors and 64-bit processors is the number of calculations per second they can perform, which affects the speed at which they can complete tasks. 64-bit processors can come in dual-core, quad-core, six-core, and eight-core versions for home computing. Multiple cores allow for an increased number of calculations per second that can be performed, which can increase the processing power and help make a computer run faster. Software programs that require many calculations to function smoothly can operate faster and more efficiently on the multi-core 64-bit processors, for the most part.

Advantages of 64-bit over 32-bit

Using 64-bit one can do a lot in multi-tasking, user can easily switch between various applications without any windows hanging problems.



Gamers can easily play High graphical games like Modern Warfare, GTA V, or use high-end software like Photoshop or CAD which takes a lot of memory since it makes multi-tasking with big software, easy and efficient for users. However upgrading the video card instead of getting a 64-bit processor would be more beneficial.



Note:



A computer with a 64-bit processor can have a 64-bit or 32-bit version of an operating system installed. However, with a 32-bit operating system, the 64-bit processor would not run at its full capability.

On a computer with a 64-bit processor, we can’t run a 16-bit legacy program. Many 32-bit programs will work with a 64-bit processor and operating system, but some older 32-bit programs may not function properly, or at all, due to limited or no compatibility.



References: https://www.computerhope.com/issues/ch001498.htm



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : flick07, DeepaBharti1, harshkes, piyushbagani15"
8,"A computer without a program running is just an inert hunk of electronics. The first thing a computer has to do when it is turned on is to start up a special program called an operating system. The operating system’s job is to help other computer programs to work by handling the messy details of controlling the computer’s hardware.

An overview of the boot process





The boot process is something that happens every time you turn your computer on. You don’t really see it, because it happens so fast. You press the power button come back a few minutes later and Windows XP, or Windows Vista, or whatever Operating System you use is all loaded.

The BIOS chip tells it to look in a fixed place, usually on the lowest-numbered hard disk (the boot disk) for a special program called a boot loader (under Linux the boot loader is called Grub or LILO). The boot loader is pulled into memory and started. The boot loader’s job is to start the real operating system.

Functions of BIOS



POST (Power On Self Test) The Power On Self Test happens each time you turn your computer on. It sounds complicated and that’s because it kind of is. Your computer does so much when its turned on and this is just part of that.



It initializes the various hardware devices. It is an important process so as to ensure that all the devices operate smoothly without any conflicts. BIOSes following ACPI create tables describing the devices in the computer.



The POST first checks the bios and then tests the CMOS RAM. If there is no problem with this then POST continues to check the CPU, hardware devices such as the Video Card, the secondary storage devices such as the Hard Drive, Floppy Drives, Zip Drive or CD/DVD Drives. If some errors found then an error message is displayed on the screen or a number of beeps are heard. These beeps are known as POST beep codes.

Master Boot Record



The Master Boot Record (MBR) is a small program that starts when the computer is booting, in order to find the operating system (eg. Windows XP). This complicated process (called the Boot Process) starts with the POST (Power On Self Test) and ends when the Bios searches for the MBR on the Hard Drive, which is generally located in the first sector, first head, first cylinder (cylinder 0, head 0, sector 1).

A typical structure looks like:





The bootstrap loader is stored in computer’s EPROM, ROM, or another non-volatile memory. When the computer is turned on or restarted, it first performs the power-on-self-test, also known as POST. If the POST is successful and no issues are found, the bootstrap loader will load the operating system for the computer into memory. The computer will then be able to quickly access, load, and run the operating system.



init



init is the last step of the kernel boot sequence. It looks for the file /etc/inittab to see if there is an entry for initdefault. It is used to determine initial run-level of the system. A run-level is used to decide the initial state of the operating system.

Some of the run levels are:

Level

0 –> System Halt

1 –> Single user mode

3 –> Full multiuser mode with network

5 –> Full multiuser mode with network and X display manager

6 –> Reboot

The above design of init is called SysV- pronounced as System five. Several other implementations of init have been written now. Some of the popular implementatios are systemd and upstart. Upstart is being used by ubuntu since 2006. More details of the upstart can be found here.



The next step of init is to start up various daemons that support networking and other services. X server daemon is one of the most important daemon. It manages display, keyboard, and mouse. When X server daemon is started you see a Graphical Interface and a login screen is displayed.



References :

http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/bootup.html

https://www.computerhope.com/jargon/b/bootload.htm

http://www.dewassoc.com/kbase/hard_drives/master_boot_record.htm

This article is contributed by Saket Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : ayushgangwar, DhananjayGhumare"
9,"Basically for a computer to start running to get an instance when it is powered up or rebooted it need to have an initial program to run. And this initial program which is known as bootstrap need to be simple. It must initialize all aspects of the system, from CPU registers to device controllers and the contents of the main memory and then starts the operating system.

To do this job the bootstrap program basically finds the operating system kernel on disk and then loads the kernel into memory and after this, it jumps to the initial address to begin the operating-system execution.

Why ROM:

For most of today’s computer bootstrap is stored in Read Only Memory (ROM).



This location is good for storage because this place doesn’t require initialization and moreover location here it is fixed so that processor can start executing when powered up or reset.

ROM is basically read-only memory and hence it cannot be affected by the computer virus.



The problem is that changing the bootstrap code basically requires changes in the ROM hardware chips.Because of this reason, most system nowadays has the tiny bootstrap loader program in the boot whose only job is to bring the full bootstrap program from the disk. Through this now we are able to change the full bootstrap program easily and the new version can be easily written onto the disk.

Full bootstrap program is stored in the boot blocks at a fixed location on the disk. A disk which has a boot partition is called a boot disk. The code in the boot ROM basically instructs the read controller to read the boot blocks into the memory and then starts the execution of code. The full bootstrap program is more complex than the bootstrap loader in the boot ROM, It is basically able to load the complete OS from a non-fixed location on disk to start the operating system running. Even though the complete bootstrap program is very small.

Example:

Let us try to understand this using an example of the boot process in Windows 2000.

The Windows 2000 basically stores its boot code in the first sector on the hard disk. Moreover, Windows 2000 allows the hard disk to be divided into one or more partition. In this one partition is basically identified as the boot partition which basically contains the operating system and the device drivers.

Booting in Windows 2000 starts by running the code that is placed in the system’s ROM memory. This code directs the system to read code directly from MBR. In addition to this boot code also contain the table which lists the partition for the hard disk and also a flag which indicates which partition is to be boot from the system. Once the system identifies the boot partition it reads the first sector from the memory which is known as boot sector and continue the process with the remainder of the boot process which includes loading of various system services.

The following figure shows the Booting from disk in Windows 2000.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : helpful_thief"
10,"The Unified Extensible Firmware Interface (UEFI), like BIOS (Basic Input Output System) is a firmware that runs when the computer is booted. It initializes the hardware and loads the operating system into the memory. However, being the more modern solution and overcoming various limitations of BIOS, UEFI is all set to replace the former.

But what makes BIOS outdated?

Present in all IBM PC-compatible personal computers, BIOS has been around since the late 1970s. Since then, it has incorporated some major improvements such as addition of a user interface, and advanced power management functions, which allow BIOS to easily configure the PCs and create better power management plans. Yet, it hasn’t advanced as much as the computer hardware and software technology since the 70s.

Limitations of BIOS

BIOS can boot from drives of less than 2 TB. 3+ TB drives are now standard, and a system with a BIOS can’t boot from them.



BIOS runs in 16-bit processor mode, and has only 1 MB space to execute.



It can’t initialize multiple hardware devices at once, thus leading to slow booting process.

Difference between the Booting Process with UEFI and the Booting Process with BIOS



Booting Process With BIOS : When BIOS begins it’s execution, it first goes for the Power-On Self Test (POST), which ensures that the hardware devices are functioning correctly. After that, it checks for the Master Boot Record in the first sector of the selected boot device. From the MBR, the location of the Boot-Loader is retrieved, which, after being loaded by BIOS into the computer’s RAM, loads the operating system into the main memory.



When BIOS begins it’s execution, it first goes for the Power-On Self Test (POST), which ensures that the hardware devices are functioning correctly. After that, it checks for the Master Boot Record in the first sector of the selected boot device. From the MBR, the location of the Boot-Loader is retrieved, which, after being loaded by BIOS into the computer’s RAM, loads the operating system into the main memory. Booting Process With UEFI : Unlike BIOS, UEFI doesn’t look for the MBR in the first sector of the Boot Device. It maintains a list of valid boot volumes called EFI Service Partitions. During the POST procedure the UEFI firmware scans all of the bootable storage devices that are connected to the system for a valid GUID Partition Table (GPT), which is an improvement over MBR. Unlike the MBR, GPT doesn’t contain a Boot-Loader. The firmware itself scans the GPT to find an EFI Service Partition to boot from, and directly loads the OS from the right partition. If it fails to find one, it goes back the BIOS-type Booting process called ‘Legacy Boot’.

Advantages of UEFI over BIOS



Breaking Out Of Size Limitations : The UEFI firmware can boot from drives of 2.2 TB or larger with the theoretical upper limit being 9.4 zettabytes, which is roughly 3 times the size of the total information present on the Internet. This is due to the fact that GPT uses 64-bit entries in it’s table, thereby dramatically expanding the possible boot-device size.



The UEFI firmware can boot from drives of 2.2 TB or larger with the theoretical upper limit being 9.4 zettabytes, which is roughly 3 times the size of the total information present on the Internet. This is due to the fact that GPT uses 64-bit entries in it’s table, thereby dramatically expanding the possible boot-device size. Speed and performance : UEFI can run in 32-bit or 64-bit mode and has more addressable address space than BIOS, which means your boot process is faster.



UEFI can run in 32-bit or 64-bit mode and has more addressable address space than BIOS, which means your boot process is faster. More User-Friendly Interface : Since UEFI can run in 32-bit and 64-bit mode, it provides better UI configuration that has better graphics and also supports mouse cursor.



Since UEFI can run in 32-bit and 64-bit mode, it provides better UI configuration that has better graphics and also supports mouse cursor. Security: UEFI also provides the feature of Secure Boot. It allows only authentic drivers and services to load at boot time, to make sure that no malware can be loaded at computer startup. It also requires drivers and the Kernel to have digital signature, which makes it an effective tool in countering piracy and boot-sector malware.

UEFI doesn’t require a Boot-Loader, and can also operate alongside BIOS, supporting legacy boot, which in turn, makes it compatible with older operating systems. Intel plans to completely replace BIOS with UEFI, for all it’s chipsets, by 2020.

My Personal Notes arrow_drop_up Save

ParthDutt Intern Technical Content Writing at GeeksforGeeks"
11,"Kernel is the core part of an operating system which manages system resources. It also acts like a bridge between application and hardware of the computer. It is one of the first programs loaded on start-up (after the Bootloader).

Kernel mode and User mode of CPU operation

The CPU can execute certain instruction only when it is in the kernel mode. These instruction are called privilege instruction. They allow implementation of special operation whose execution by the user program could interface with the functioning of operating system or activity of another user program. For example, instruction for managing memory protection.

The operating system puts the CPU in kernel mode when it is executing in the kernel so, that kernel can execute some special operation.

The operating system puts the CPU in user mode when a user program is in execution so, that user program cannot interface with the operating system program.

User-level instruction does not require special privilege. Example are ADD,PUSH,etc.

The concept of modes can be extended beyond two, requiring more than a single mode bit CPUs that support virtualization use one of these extra bits to indicate when the virtual machine manager, VMM, is in control of the system. The VMM has more privileges than ordinary user programs, but not so many as the full kernel.

System calls are typically implemented in the form of software interrupts, which causes the hardware’s interrupt handler to transfer control over to an appropriate interrupt handler, which is part of the operating system, switching the mode bit to kernel mode in the process. The interrupt handler checks exactly which interrupt was generated, checks additional parameters ( generally passed through registers ) if appropriate, and then calls the appropriate kernel service routine to handle the service requested by the system call.

User programs’ attempts to execute illegal instructions ( privileged or non-existent instructions ), or to access forbidden memory areas, also generate software interrupts, which are trapped by the interrupt handler and control is transferred to the OS, which issues an appropriate error message, possibly dumps data to a log ( core ) file for later analysis, and then terminates the offending program.

What is Microkernel?

Microkernel is one of the classification of the kernel. Being a kernel it manages all system resources. But in a microkernel, the user services and kernel services are implemented in different address space. The user services are kept in user address space, and kernel services are kept under kernel address space, thus also reduces the size of kernel and size of operating system as well.

It provides minimal services of process and memory management. The communication between client program/application and services running in user address space is established through message passing, reducing the speed of execution microkernel. The Operating System remains unaffected as user services and kernel services are isolated so if any user service fails it does not affect kernel service. Thus it adds to one of the advantages in a microkernel. It is easily extendable i.e. if any new services are to be added they are added to user address space and hence requires no modification in kernel space. It is also portable, secure and reliable.

Microkernel Architecture –

Since kernel is the core part of the operating system, so it is meant for handling the most important services only. Thus in this architecture only the most important services are inside kernel and rest of the OS services are present inside system application program. Thus users are able to interact with those not-so important services within the system application. And the microkernel is solely responsible for the most important services of operating system they are named as follows:

Inter process-Communication

Memory Management

CPU-Scheduling

Advantages of Microkernel –

The architecture of this kernel is small and isolated hence it can function better.

Expansion of the system is easier, it is simply added in the system application without disturbing the kernel.

Eclipse IDE is a good example of Microkernel Architecture.

Read next – Monolithic Kernel and key differences from Microkernel

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
12,"Prerequisite – Microkernel

The kernel provides many services related to I/O. Several services such as scheduling, caching, spooling, device reservation, and error handling – are provided by the kernel, s I/O subsystem built on the hardware and device-driver infrastructure. The I/O subsystem is also responsible for protecting itself from the errant processes and malicious users.

I/O Scheduling –

To schedule a set of I/O request means to determine a good order in which to execute them. The order in which application issues the system call are the best choice. Scheduling can improve the overall performance of the system, can share device access permission fairly to all the processes, reduce the average waiting time, response time, turnaround time for I/O to complete. OS developers implement scheduling by maintaining a wait queue of the request for each device. When an application issue a blocking I/O system call, The request is placed in the queue for that device. The I/O scheduler rearrange the order to improve the efficiency of the system. Buffering –

A buffer is a memory area that stores data being transferred between two devices or between a device and an application. Buffering is done for three reasons. First is to cope with a speed mismatch between producer and consumer of a data stream. The second use of buffering is to provide adaptation for data that have different data-transfer sizes. Third use of buffering is to support copy semantics for the application I/O, “copy semantic ” means, suppose that an application wants to write data on a disk that is stored in its buffer. it calls the write() system’s call, providing a pointer to the buffer and the integer specifying the number of bytes to write. Q. After the system call returns, what happens if the application of the buffer changes the content of the buffer?

Ans. With copy semantic, the version of the data written to the disk is guaranteed to be the version at the time of the application system call. Caching –

A cache is a region of fast memory that holds a copy of data. Access to the cached copy is much easier than the original file. For instance, the instruction of the currently running process is stored on the disk, cached in physical memory, and copied again in the CPU’s secondary and primary cache.



The main difference between a buffer and a cache is that a buffer may hold only the existing copy of a data item, while cache, by definition, holds a copy on faster storage of an item that resides elsewhere. Spooling and Device Reservation –

A spool is a buffer that holds the output of a device, such as a printer that cannot accept interleaved data streams. Although a printer can serve only one job at a time, several applications may wish to print their output concurrently, without having their output mixes together. The OS solves this problem by preventing all output continuing to the printer. The output of all applications is spooled in a separate disk file. When an application finishes printing then the spooling system queues the corresponding spool file for output to the printer. Error Handling –

An Os that uses protected memory can guard against many kinds of hardware and application errors, so that a complete system failure is not the usual result of each minor mechanical glitch, Devices, and I/O transfers can fail in many ways, either for transient reasons, as when a network becomes overloaded or for permanent reasons, as when a disk controller becomes defective. I/O Protection –

Errors and the issue of protection are closely related. A user process may attempt to issue illegal I/O instructions to disrupt the normal function of a system. We can use the various mechanisms to ensure that such disruption cannot take place in the system. To prevent illegal I/O access, we define all I/O instructions to be privileged instructions. The user cannot issue I/O instruction directly.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : shreyashagrawal, singhpriansh"
13,"Apart from microkernel, Monolithic Kernel is another classification of Kernel. Like microkernel this one also manages system resources between application and hardware, but user services and kernel services are implemented under same address space. It increases the size of the kernel, thus increases size of operating system as well.

This kernel provides CPU scheduling, memory management, file management and other operating system functions through system calls. As both services are implemented under same address space, this makes operating system execution faster.

Below is the diagrammatic representation of Monolithic Kernel:

If any service fails the entire system crashes, and it is one of the drawbacks of this kernel. The entire operating system needs modification if user adds a new service.

Advantages of Monolithic Kernel –

One of the major advantage of having monolithic kernel is that it provides CPU scheduling, memory management, file management and other operating system functions through system calls.

The other one is that it is a single large process running entirely in a single address space.

It is a single static binary file. Example of some Monolithic Kernel based OSs are: Unix, Linux, Open VMS, XTS-400, z/TPF.

Disadvantages of Monolithic Kernel –

One of the major disadvantage of monolithic kernel is that, if anyone service fails it leads to entire system failure.

If user has to add any new service. User needs to modify entire operating system.

Key differences between Monolithic Kernel and Microkernel –

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
14,"Types of System Calls : There are 5 different categories of system calls –

Examples of Windows and Unix System Calls –

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below."
15,"The getrlimit() and setrlimit() system calls can be used to get and set the resource limits such as files, CPU, memory etc. associated with a process.

Each resource has an associated soft and hard limit. soft limit: The soft limit is the actual limit enforced by the kernel for the corresponding resource.

The soft limit is the actual limit enforced by the kernel for the corresponding resource. hard limit: The hard limit acts as a ceiling for the soft limit. The soft limit ranges in between 0 and hard limit.

The two limits are defined by the following structure

filter_none edit

close play_arrow link

brightness_4

code struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; };

chevron_right filter_none

The signatures of the system calls are

filter_none edit

close play_arrow link

brightness_4

code int getrlimit( int resource, struct rlimit *rlim); int setrlimit( int resource, const struct rlimit *rlim);

chevron_right filter_none

resource refers to the resource limits you want to retrieve or modify.

To set both the limits, set the values with the new values to the elements of rlimit structure.

To get both the limits, pass the address of rlim. Successful call to getrlimit(), sets the rlimit elements to the limits.

On success, both return 0. On error, -1 is returned, and errno is set appropriately.

Here, is a program demonstrating the system calls by changing the value one greater than the maximum file descriptor number to 3.

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <sys/resource.h> #include <string.h> #include <errno.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> int main() { struct rlimit old_lim, lim, new_lim; if ( getrlimit(RLIMIT_NOFILE, &old_lim) == 0) printf ( ""Old limits -> soft limit= %ld \t"" "" hard limit= %ld

"" , old_lim.rlim_cur, old_lim.rlim_max); else fprintf (stderr, ""%s

"" , strerror ( errno )); lim.rlim_cur = 3; lim.rlim_max = 1024; if (setrlimit(RLIMIT_NOFILE, &lim) == -1) fprintf (stderr, ""%s

"" , strerror ( errno )); if ( getrlimit(RLIMIT_NOFILE, &new_lim) == 0) printf ( ""New limits -> soft limit= %ld "" ""\t hard limit= %ld

"" , new_lim.rlim_cur, new_lim.rlim_max); else fprintf (stderr, ""%s

"" , strerror ( errno )); return 0; }

chevron_right filter_none

Output:

Old limits -> soft limit= 1048576 hard limit= 1048576 New limits -> soft limit= 3 hard limit= 1024

The Old limits values may vary depending upon the system.

Now, If you try to open a new file, it will show run time error, because maximum 3 files can be opened and that are already being opened by the system(STDIN, STDOUT, STDERR).

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <sys/resource.h> #include <string.h> #include <errno.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> int main() { struct rlimit old_lim, lim, new_lim; if ( getrlimit(RLIMIT_NOFILE, &old_lim) == 0) printf ( ""Old limits -> soft limit= %ld \t"" "" hard limit= %ld

"" , old_lim.rlim_cur, old_lim.rlim_max); else fprintf (stderr, ""%s

"" , strerror ( errno )); lim.rlim_cur = 3; lim.rlim_max = 1024; if (setrlimit(RLIMIT_NOFILE, &lim) == -1) fprintf (stderr, ""%s

"" , strerror ( errno )); if ( getrlimit(RLIMIT_NOFILE, &new_lim) == 0) printf ( ""New limits -> soft limit= %ld \t"" "" hard limit= %ld

"" , new_lim.rlim_cur, new_lim.rlim_max); else fprintf (stderr, ""%s

"" , strerror ( errno )); if (open( ""foo.txt"" , O_WRONLY | O_CREAT, 0) == -1) fprintf (stderr, ""%s

"" , strerror ( errno )); else printf ( ""Opened successfully

"" ); return 0; }

chevron_right filter_none

Output:



Old limits -> soft limit= 1048576 hard limit= 1048576

New limits -> soft limit= 3 hard limit= 1024

Too many open files

man 2 prlimit

There is another system callthat combines both the system calls.For more details, check manual by typing

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
16,"An error in one program can adversely affect many processes, it might modify data of another program, or also can affect the operating system. For example, if a process stuck in infinite loop then this infinite loop could affect correct operation of other processes. So to ensure the proper execution of the operating system, there are two modes of operation:

User mode –

When the computer system run user applications like creating a text document or using any application program, then the system is in the user mode. When the user application requests for a service from the operating system or an interrupt occurs or system call, then there will be a transition from user to kernel mode to fulfill the requests.

Note: To switch from kernel mode to user mode, mode bit should be 1.

Given below image describes what happen when an interrupt occurs:



Kernel Mode –

When the system boots, hardware starts in kernel mode and when operating system is loaded, it start user application in user mode. To provide protection to the hardware, we have privileged instructions which execute only in kernel mode. If user attempt to run privileged instruction in user mode then it will treat instruction as illegal and traps to OS. Some of the privileged instructions are:

Handling Interrupts To switch from user mode to kernel mode. Input-Output management.

Note: To switch from user mode to kernel mode mode bit should be 0.

Read next – User Level thread Vs Kernel Level thread

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : midhunxda"
17,"In any Operating System, it is necessary to have Dual Mode Operation to ensure protection and security of the System from unauthorized or errant users . This Dual Mode separates the User Mode from the System Mode or Kernel Mode.

What are Privileged Instructions?

The Instructions that can run only in Kernel Mode are called Privileged Instructions .

Privileged Instructions possess the following characteristics :

(i) If any attempt is made to execute a Privileged Instruction in User Mode, then it will not be executed and treated as an illegal instruction. The Hardware traps it to the Operating System.

(ii) Before transferring the control to any User Program, it is the responsibility of the Operating System to ensure that the Timer is set to interrupt. Thus, if the timer interrupts then the Operating System regains the control.

Thus, any instruction which can modify the contents of the Timer is a Privileged Instruction.

(iii) Privileged Instructions are used by the Operating System in order to achieve correct operation.

(iv) Various examples of Privileged Instructions include:

I/O instructions and Halt instructions

Turn off all Interrupts

Set the Timer

Context Switching

Clear the Memory or Remove a process from the Memory

Modify entries in Device-status table

What are Non-Privileged Instructions?

The Instructions that can run only in User Mode are called Non-Privileged Instructions .

Various examples of Non-Privileged Instructions include:

Reading the status of Processor

Reading the System Time

Generate any Trap Instruction

Sending the final prinout of Printer

Also, it is important to note that in order to change the mode from Privileged to Non-Privileged, we require a Non-privileged Instruction that does not generate any interrupt.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
18,"Program vs Process

A process is a program in execution. For example, when we write a program in C or C++ and compile it, the compiler creates binary code. The original code and binary code are both programs. When we actually run the binary code, it becomes a process.

A process is an ‘active’ entity, as opposed to a program, which is considered to be a ‘passive’ entity. A single program can create many processes when run multiple times; for example, when we open a .exe or binary file multiple times, multiple instances begin (multiple processes are created).

What does a process look like in memory?



Text Section:A Process, sometimes known as the Text Section, also includes the current activity represented by the value of the Program Counter.

Stack: The Stack contains the temporary data, such as function parameters, returns addresses, and local variables.

Data Section: Contains the global variable.

Heap Section: Dynamically allocated memory to process during its run time.

Refer this for more details on sections.

Attributes or Characteristics of a Process

A process has following attributes.



1. Process Id: A unique identifier assigned by the operating system 2. Process State: Can be ready, running, etc. 3. CPU registers: Like the Program Counter (CPU registers must be saved and restored when a process is swapped in and out of CPU) 5. Accounts information: 6. I/O status information: For example, devices allocated to the process, open files, etc 8. CPU scheduling information: For example, Priority (Different processes may have different priorities, for example a short process may be assigned a low priority in the shortest job first scheduling)

All of the above attributes of a process are also known as thecontext of the process.

Every process has its own process control block(PCB), i.e each process will have a unique PCB. All of the above attributes are part of the PCB.

States of Process:

A process is in one of the following states:



1. New: Newly Created Process (or) being-created process. 2. Ready: After creation process moves to Ready state, i.e. the process is ready for execution. 3. Run: Currently running process in CPU (only one process at a time can be under execution in a single processor). 4. Wait (or Block): When a process requests I/O access. 5. Complete (or Terminated): The process completed its execution. 6. Suspended Ready: When the ready queue becomes full, some processes are moved to suspended ready state 7. Suspended Block: When waiting queue becomes full.

Context Switching

The process of saving the context of one process and loading the context of another process is known as Context Switching. In simple terms, it is like loading and unloading the process from running state to ready state.

When does context switching happen?

1. When a high-priority process comes to ready state (i.e. with higher priority than the running process)

2. An Interrupt occurs

3. User and kernel mode switch (It is not necessary though)

4. Preemptive CPU scheduling used.

Context Switch vs Mode Switch

A mode switch occurs when CPU privilege level is changed, for example when a system call is made or a fault occurs. The kernel works in more a privileged mode than a standard user task. If a user process wants to access things which are only accessible to the kernel, a mode switch must occur. The currently executing process need not be changed during a mode switch.

A mode switch typically occurs for a process context switch to occur. Only the kernel can cause a context switch.

CPU-Bound vs I/O-Bound Processes:

A CPU-bound process requires more CPU time or spends more time in the running state.

An I/O-bound process requires more I/O time and less CPU time. An I/O-bound process spends more time in the waiting state.

Exercise:

1. Which of the following need not necessarily be saved on a context switch between processes? (GATE-CS-2000)

(A) General purpose registers

(B) Translation lookaside buffer

(C) Program counter

(D) All of the above

Answer (B)

Explanation:

In a process context switch, the state of the first process must be saved somehow, so that when the scheduler gets back to the execution of the first process, it can restore this state and continue. The state of the process includes all the registers that the process may be using, especially the program counter, plus any other operating system-specific data that may be necessary. A translation look-aside buffer (TLB) is a CPU cache that memory management hardware uses to improve virtual address translation speed. A TLB has a fixed number of slots that contain page table entries, which map virtual addresses to physical addresses. On a context switch, some TLB entries can become invalid, since the virtual-to-physical mapping is different. The simplest strategy to deal with this is to completely flush the TLB.

2. The time taken to switch between user and kernel modes of execution is t1 while the time taken to switch between two processes is t2. Which of the following is TRUE? (GATE-CS-2011)

(A) t1 > t2

(B) t1 = t2

(C) t1 < t2

(D) nothing can be said about the relation between t1 and t2.

Answer: (C)

Explanation: Process switching involves mode switch. Context switching can occur only in kernel mode.

Quiz on Process Management

References:

http://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/3_Processes.html

http://cs.nyu.edu/courses/spring11/G22.2250-001/lectures/lecture-04.html

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
19,"Prerequisite – Introduction, Process Scheduler

States of a process are as following:

New (Create) – In this step, the process is about to be created but not yet created, it is the program which is present in secondary memory that will be picked up by OS to create the process.

In this step, the process is about to be created but not yet created, it is the program which is present in secondary memory that will be picked up by OS to create the process. Ready – New -> Ready to run. After the creation of a process, the process enters the ready state i.e. the process is loaded into the main memory. The process here is ready to run and is waiting to get the CPU time for its execution. Processes that are ready for execution by the CPU are maintained in a queue for ready processes.

New -> Ready to run. After the creation of a process, the process enters the ready state i.e. the process is loaded into the main memory. The process here is ready to run and is waiting to get the CPU time for its execution. Processes that are ready for execution by the CPU are maintained in a queue for ready processes. Run – The process is chosen by CPU for execution and the instructions within the process are executed by any one of the available CPU cores.

The process is chosen by CPU for execution and the instructions within the process are executed by any one of the available CPU cores. Blocked or wait – Whenever the process requests access to I/O or needs input from the user or needs access to a critical region(the lock for which is already acquired) it enters the blocked or wait state. The process continues to wait in the main memory and does not require CPU. Once the I/O operation is completed the process goes to the ready state.

Whenever the process requests access to I/O or needs input from the user or needs access to a critical region(the lock for which is already acquired) it enters the blocked or wait state. The process continues to wait in the main memory and does not require CPU. Once the I/O operation is completed the process goes to the ready state. Terminated or completed – Process is killed as well as PCB is deleted.

Process is killed as well as PCB is deleted. Suspend ready – Process that was initially in the ready state but were swapped out of main memory(refer Virtual Memory topic) and placed onto external storage by scheduler are said to be in suspend ready state. The process will transition back to ready state whenever the process is again brought onto the main memory.

Process that was initially in the ready state but were swapped out of main memory(refer Virtual Memory topic) and placed onto external storage by scheduler are said to be in suspend ready state. The process will transition back to ready state whenever the process is again brought onto the main memory. Suspend wait or suspend blocked – Similar to suspend ready but uses the process which was performing I/O operation and lack of main memory caused them to move to secondary memory.

When work is finished it may go to suspend ready.

CPU and IO Bound Processes:

If the process is intensive in terms of CPU operations then it is called CPU bound process. Similarly, If the process is intensive in terms of I/O operations then it is called IO bound process.

Types of schedulers:

Long term – performance – Makes a decision about how many processes should be made to stay in the ready state, this decides the degree of multiprogramming. Once a decision is taken it lasts for a long time hence called long term scheduler. Short term – Context switching time – Short term scheduler will decide which process to be executed next and then it will call dispatcher. A dispatcher is a software that moves process from ready to run and vice versa. In other words, it is context switching. Medium term – Swapping time – Suspension decision is taken by medium term scheduler. Medium term scheduler is used for swapping that is moving the process from main memory to secondary and vice versa.

Multiprogramming – We have many processes ready to run. There are two types of multiprogramming:

Pre-emption – Process is forcefully removed from CPU. Pre-emption is also called as time sharing or multitasking. Non pre-emption – Processes are not removed until they complete the execution.

Degree of multiprogramming –

The number of processes that can reside in the ready state at maximum decides the degree of multiprogramming, e.g., if the degree of programming = 100, this means 100 processes can reside in the ready state at maximum.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : kbapat, nitishanon, shreyashagrawal"
20,"While creating a process the operating system performs several operations. To identify the processes, it assigns a process identification number (PID) to each process. As the operating system supports multi-programming, it needs to keep track of all the processes. For this task, the process control block (PCB) is used to track the process’s execution status. Each block of memory contains information about the process state, program counter, stack pointer, status of opened files, scheduling algorithms, etc. All these information is required and must be saved when the process is switched from one state to another. When the process makes a transition from one state to another, the operating system must update information in the process’s PCB.

A process control block (PCB) contains information about the process, i.e. registers, quantum, priority, etc. The process table is an array of PCB’s, that means logically contains a PCB for all of the current processes in the system.

Pointer – It is a stack pointer which is required to be saved when the process is switched from one state to another to retain the current position of the process.

It is a stack pointer which is required to be saved when the process is switched from one state to another to retain the current position of the process. Process state – It stores the respective state of the process.

It stores the respective state of the process. Process number – Every process is assigned with a unique id known as process ID or PID which stores the process identifier.

Every process is assigned with a unique id known as process ID or PID which stores the process identifier. Program counter – It stores the counter which contains the address of the next instruction that is to be executed for the process.

It stores the counter which contains the address of the next instruction that is to be executed for the process. Register – These are the CPU registers which includes: accumulator, base, registers and general purpose registers.

These are the CPU registers which includes: accumulator, base, registers and general purpose registers. Memory limits – This field contains the information about memory management system used by operating system. This may include the page tables, segment tables etc.

This field contains the information about memory management system used by operating system. This may include the page tables, segment tables etc. Open files list – This information includes the list of files opened for a process.

Miscellaneous accounting and status data – This field includes information about the amount of CPU used, time constraints, jobs or process number, etc.

The process control block stores the register content also known as execution content of the processor when it was blocked from running. This execution content architecture enables the operating system to restore a process’s execution context when the process returns to the running state. When the process makes a transition from one state to another, the operating system updates its information in the process’s PCB. The operating system maintains pointers to each process’s PCB in a process table so that it can access the PCB quickly.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

This article is contributed by Rajshree Srivastava. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : magbene, caogdue31"
21,"There are three types of process scheduler.



Long Term or job scheduler :

It brings the new process to the ‘Ready State’. It controls Degree of Multi-programming, i.e., number of process present in ready state at any point of time. It is important that the long-term scheduler make a careful selection of both IO and CPU bound process. IO bound tasks are which use much of their time in input and output operations while CPU bound processes are which spend their time on CPU. The job scheduler increases efficiency by maintaining a balance between the two. Short term or CPU scheduler :

It is responsible for selecting one process from ready state for scheduling it on the running state. Note: Short-term scheduler only selects the process to schedule it doesn’t load the process on running. Here is when all the scheduling algorithms are used. The CPU scheduler is responsible for ensuring there is no starvation owing to high burst time processes.

Dispatcher is responsible for loading the process selected by Short-term scheduler on the CPU (Ready to Running State) Context switching is done by dispatcher only. A dispatcher does the following: Switching context. Switching to user mode. Jumping to the proper location in the newly loaded program. Medium-term scheduler :

It is responsible for suspending and resuming the process. It mainly does swapping (moving processes from main memory to disk and vice versa). Swapping may be necessary to improve the process mix or because a change in memory requirements has overcommitted available memory, requiring memory to be freed up. It is helpful in maintaining a perfect balance between the I/O bound and the CPU bound. It reduces the degree of multiprogramming.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : magbene, VaibhavRai3, jyotibisht6114"
22,"Scheduling of processes/work is done to finish the work on time.

Below are different time with respect to a process.

Arrival Time: Time at which the process arrives in the ready queue.

Completion Time: Time at which process completes its execution.

Burst Time: Time required by a process for CPU execution.

Turn Around Time: Time Difference between completion time and arrival time.

Turn Around Time = Completion Time – Arrival Time Waiting Time(W.T): Time Difference between turn around time and burst time.

Waiting Time = Turn Around Time – Burst Time

Why do we need scheduling?

A typical process involves both I/O time and CPU time. In a uni programming system like MS-DOS, time spent waiting for I/O is wasted and CPU is free during this time. In multi programming systems, one process can use CPU while another is waiting for I/O. This is possible only with process scheduling.

Objectives of Process Scheduling Algorithm

Max CPU utilization [Keep CPU as busy as possible]

Fair allocation of CPU.

Max throughput [Number of processes that complete their execution per time unit]

Min turnaround time [Time taken by a process to finish execution]

Min waiting time [Time a process waits in ready queue]

Min response time [Time when a process produces first response]

Different Scheduling Algorithms

First Come First Serve (FCFS): Simplest scheduling algorithm that schedules according to arrival times of processes. First come first serve scheduling algorithm states that the process that requests the CPU first is allocated the CPU first. It is implemented by using the FIFO queue. When a process enters the ready queue, its PCB is linked onto the tail of the queue. When the CPU is free, it is allocated to the process at the head of the queue. The running process is then removed from the queue. FCFS is a non-preemptive scheduling algorithm.

Note:First come first serve suffers from convoy effect.

Shortest Job First (SJF): Process which have the shortest burst time are scheduled first.If two processes have the same bust time then FCFS is used to break the tie. It is a non-preemptive scheduling algorithm.

Longest Job First (LJF): It is similar to SJF scheduling algorithm. But, in this scheduling algorithm, we give priority to the process having the longest burst time. This is non-preemptive in nature i.e., when any process starts executing, can’t be interrupted before complete execution.

Shortest Remaining Time First (SRTF): It is preemptive mode of SJF algorithm in which jobs are schedule according to shortest remaining time.

Longest Remaining Time First (LRTF): It is preemptive mode of LJF algorithm in which we give priority to the process having largest burst time remaining.

Round Robin Scheduling: Each process is assigned a fixed time(Time Quantum/Time Slice) in cyclic way.It is designed especially for the time-sharing system. The ready queue is treated as a circular queue. The CPU scheduler goes around the ready queue, allocating the CPU to each process for a time interval of up to 1-time quantum. To implement Round Robin scheduling, we keep the ready queue as a FIFO queue of processes. New processes are added to the tail of the ready queue. The CPU scheduler picks the first process from the ready queue, sets a timer to interrupt after 1-time quantum, and dispatches the process. One of two things will then happen. The process may have a CPU burst of less than 1-time quantum. In this case, the process itself will release the CPU voluntarily. The scheduler will then proceed to the next process in the ready queue. Otherwise, if the CPU burst of the currently running process is longer than 1-time quantum, the timer will go off and will cause an interrupt to the operating system. A context switch will be executed, and the process will be put at the tail of the ready queue. The CPU scheduler will then select the next process in the ready queue.

Priority Based scheduling (Non-Preemptive): In this scheduling, processes are scheduled according to their priorities, i.e., highest priority process is scheduled first. If priorities of two processes match, then schedule according to arrival time. Here starvation of process is possible.

Highest Response Ratio Next (HRRN): In this scheduling, processes with highest response ratio is scheduled. This algorithm avoids starvation.

Response Ratio = (Waiting Time + Burst time) / Burst time

Multilevel Queue Scheduling: According to the priority of process, processes are placed in the different queues. Generally high priority process are placed in the top level queue. Only after completion of processes from top level queue, lower level queued processes are scheduled. It can suffer from starvation.

Multi level Feedback Queue Scheduling: It allows the process to move in between queues. The idea is to separate processes according to the characteristics of their CPU bursts. If a process uses too much CPU time, it is moved to a lower-priority queue.

Some useful facts about Scheduling Algorithms:



FCFS can cause long waiting times, especially when the first job takes too much CPU time. Both SJF and Shortest Remaining time first algorithms may cause starvation. Consider a situation when the long process is there in the ready queue and shorter processes keep coming. If time quantum for Round Robin scheduling is very large, then it behaves same as FCFS scheduling. SJF is optimal in terms of average waiting time for a given set of processes,i.e., average waiting time is minimum with this scheduling, but problems are, how to know/predict the time of next job.

Exercise:



Consider a system which requires 40-time units of burst time. The Multilevel feedback queue scheduling is used and time quantum is 2 unit for the top queue and is incremented by 5 unit at each level, then in what queue the process will terminate the execution?

Which of the following is false about SJF?

S1: It causes minimum average waiting time

S2: It can cause starvation

(A) Only S1

(B) Only S2

(C) Both S1 and S2

(D) Neither S1 nor S2

Answer (D)

S1 is true SJF will always give minimum average waiting time.

S2 is true SJF can cause starvation.

Consider the following table of arrival time and burst time for three processes P0, P1 and P2. (GATE-CS-2011) Process Arrival time Burst Time P0 0 ms 9 ms P1 1 ms 4 ms P2 2 ms 9 ms The pre-emptive shortest job first scheduling algorithm is used. Scheduling is carried out only at arrival or completion of processes. What is the average waiting time for the three processes?

(A) 5.0 ms

(B) 4.33 ms

(C) 6.33

(D) 7.33

Solution :

Answer: – (A)

Process P0 is allocated processor at 0 ms as there is no other process in the ready queue. P0 is preempted after 1 ms as P1 arrives at 1 ms and burst time for P1 is less than remaining time of P0. P1 runs for 4ms. P2 arrived at 2 ms but P1 continued as burst time of P2 is longer than P1. After P1 completes, P0 is scheduled again as the remaining time for P0 is less than the burst time of P2.

P0 waits for 4 ms, P1 waits for 0 ms and P2 waits for 11 ms. So average waiting time is (0+4+11)/3 = 5.





Consider the following set of processes, with the arrival times and the CPU-burst times given in milliseconds (GATE-CS-2004) Process Arrival Time Burst Time P1 0 5 P2 1 3 P3 2 3 P4 4 1 What is the average turnaround time for these processes with the preemptive shortest remaining processing time first (SRPT) algorithm ?

(A) 5.50

(B) 5.75

(C) 6.00

(D) 6.25

Answer (A)

Solution:

The following is Gantt Chart of execution P1 P2 P4 P3 P1 1 4 5 8 12 Turn Around Time = Completion Time – Arrival Time

Avg Turn Around Time = (12 + 3 + 6+ 1)/4 = 5.50

An operating system uses the Shortest Remaining Time first (SRTF) process scheduling algorithm. Consider the arrival times and execution times for the following processes: Process Execution time Arrival time P1 20 0 P2 25 15 P3 10 30 P4 15 45 What is the total waiting time for process P2?

(A) 5

(B) 15

(C) 40

(D) 55

Answer (B)

At time 0, P1 is the only process, P1 runs for 15 time units.

At time 15, P2 arrives, but P1 has the shortest remaining time. So P1 continues for 5 more time units.

At time 20, P2 is the only process. So it runs for 10 time units

At time 30, P3 is the shortest remaining time process. So it runs for 10 time units

At time 40, P2 runs as it is the only process. P2 runs for 5 time units.

At time 45, P3 arrives, but P2 has the shortest remaining time. So P2 continues for 10 more time units.

P2 completes its execution at time 55 Total waiting time for P2 = Completion time - (Arrival time + Execution time) = 55 - (15 + 25) = 15

Please refer Quiz on CPU Scheduling for more questions.

References:

http://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_CPU_Scheduling.html

http://codex.cs.yale.edu/avi/os-book/OS8/os8c/slide-dir/PDF-dir/ch5.pdf

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
23,"Prerequisite – CPU Scheduling

1. Preemptive Scheduling:

Preemptive scheduling is used when a process switches from running state to ready state or from waiting state to ready state. The resources (mainly CPU cycles) are allocated to the process for the limited amount of time and then is taken away, and the process is again placed back in the ready queue if that process still has CPU burst time remaining. That process stays in ready queue till it gets next chance to execute.

Algorithms based on preemptive scheduling are: Round Robin (RR),Shortest Remaining Time First (SRTF), Priority (preemptive version), etc.

2. Non-Preemptive Scheduling:

Non-preemptive Scheduling is used when a process terminates, or a process switches from running to waiting state. In this scheduling, once the resources (CPU cycles) is allocated to a process, the process holds the CPU till it gets terminated or it reaches a waiting state. In case of non-preemptive scheduling does not interrupt a process running CPU in middle of the execution. Instead, it waits till the process complete its CPU burst time and then it can allocate the CPU to another process.

Algorithms based on non-preemptive scheduling are: Shortest Job First (SJF basically non preemptive) and Priority (non preemptive version), etc.

Key Differences Between Preemptive and Non-Preemptive Scheduling:



In preemptive scheduling the CPU is allocated to the processes for the limited time whereas in Non-preemptive scheduling, the CPU is allocated to the process till it terminates or switches to waiting state.

The executing process in preemptive scheduling is interrupted in the middle of execution when higher priority one comes whereas, the executing process in non-preemptive scheduling is not interrupted in the middle of execution and wait till its execution.

In Preemptive Scheduling, there is the overhead of switching the process from ready state to running state, vise-verse, and maintaining the ready queue. Whereas in case of non-preemptive scheduling has no overhead of switching the process from running state to ready state.

In preemptive scheduling, if a high priority process frequently arrives in the ready queue then the process with low priority has to wait for a long, and it may have to starve. On the other hands, in the non-preemptive scheduling, if CPU is allocated to the process having larger burst time then the processes with small burst time may have to starve.

Preemptive scheduling attain flexible by allowing the critical processes to access CPU as they arrive into the ready queue, no matter what process is executing currently. Non-preemptive scheduling is called rigid as even if a critical process enters the ready queue the process running CPU is not disturbed.

The Preemptive Scheduling has to maintain the integrity of shared data that’s why it is cost associative as it which is not the case with Non-preemptive Scheduling.

Comparison Chart:

Paramenter PREEMPTIVE SCHEDULING NON-PREEMPTIVE SCHEDULING Basic In this resources(CPU Cycle) are allocated to a process for a limited time. Once resources(CPU Cycle) are allocated to a process, the process holds it till it completes its burst time or switches to waiting state. Interrupt Process can be interrupted in between. Process can not be interrupted until it terminates itself or its time is up. Starvation If a process having high priority frequently arrives in the ready queue, low priority process may starve. If a process with long burst time is running CPU, then later coming process with less CPU burst time may starve. Overhead It has overheads of scheduling the processes. It does not have overheads. Flexibility flexible rigid Cost cost associated no cost associated CPU Utilization In preemptive scheduling, CPU utilization is high. It is low in non preemptive scheduling. Examples Examples of preemptive scheduling are Round Robin and Shortest Remaining Time First. Examples of non-preemptive scheduling are First Come First Serve and Shortest Job First.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : niharika3, ashushrma378, kajalshekhawat06"
24,"A Context switch is the time spent between two processes (i.e., bringing a waiting process into execution and sending an executing process into waiting state). This happens in multitasking.The operating system must bring the state information if waiting process into memory and save the state information of the currently running process.

In order to solve this problem, we would like to record the timestamps of the first and last instruction of the swapping processes.The context switch time is the difference between the two processes.

Let’s take an example: Assume there are only two processes, P1 and P2.

P1 is executing and P2 is waiting for execution. At some point, the operating system must swap P1 and P2, let’s assume it happens at the nth instruction of P1. If t(x, k) indicates the timestamp in microseconds of the kth instruction of process x, then the context switch would take t(2, 1) – t(1, n).

Another issue is that swapping is governed by the scheduling algorithm of the operating system and there may be many kernel level threads which are also doing context switches. Other processes could be contending for the CPU or the kernel handling interrupts. The user does not have any control over these extraneous context switches. For instance, if at time t(1, n) the kernel decides to handle an interrupt, then the context switch time would be overstated.

In order to avoid these obstacles, we must construct an environment such that after P1 executes, the task scheduler immediately selects P2 to run. This may be accomplished by constructing a data channel, such as a pipe between P1 and P2.

That is, let’s allow P1 to be the initial sender and P2 be the receiver. Initially, P2 is blocked(sleeping) as it awaits the data token. When P1 executes, it delivers the data token over the data channel to P2 and immediately attempts to read the response token. A context switch results and the task scheduler must selects another process to run.Since P2 is now in a ready-to-run state, it is a desirable candidate to be selected by the task scheduler for execution.When P2 runs, the role of P1 and P2 are swapped. P2 is now acting as the sender and P1 as the blocked receiver.

To summaries –

P2 blocks awaiting data from P1 P1 marks the starting time. P1 sends token to P2. P1 attempts to read a response token from P2. This induces a context switch. P2 is scheduled and receives the token. P2 sends a response token to P1. P2 attempts read a response token from P1. This induces a context switch. P1 is scheduled and receives the token. P1 marks the end time.

The key is that the delivery of a data token induces a context switch. Let Td and Tr be the time it takes to deliver and receive a data token, respectively, and let Tc be the amount of time spent in a context switch. At step 2, P1 records the timestamp of the delivery of the token, and at step 9, it records the timestamp of the response. The amount of time elapsed, T, between these events may be expressed by:

T = 2 * (Td + Tc + Tr)

This formula arises because of the following events:

P1 sends the token (3)

CPU context switches (4)

P2 receives it (5)

P2 then sends the response token (6)

CPU context switches (7)

and finally, P1 receives it (8)

GATE CS Practice Questions –

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

brahmanisai Studying in National Institute Of Technology Raipur Computer Science Interested in diving into computer languages Placed in Capgemini"
25,"Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. There are three types of Scheduler:

Long term (job) scheduler – Due to the smaller size of main memory initially all program are stored in secondary memory. When they are stored or loaded in the main memory they are called process. This is the decision of long term scheduler that how many processes will stay in the ready queue. Hence, in simple words, long term scheduler decides the degree of multi-programming of system. Medium term scheduler – Most often, a running process needs I/O operation which doesn’t requires CPU. Hence during the execution of a process when a I/O operation is required then the operating system sends that process from running queue to blocked queue. When a process completes its I/O operation then it should again be shifted to ready queue. ALL these decisions are taken by the medium-term scheduler. Medium-term scheduling is a part of swapping. Short term (CPU) scheduler – When there are lots of processes in main memory initially all are present in the ready queue. Among all of the process, a single process is to be selected for execution. This decision is handled by short term scheduler. Let’s have a look at the figure given below. It may make a more clear view for you.

Dispatcher –

A dispatcher is a special program which comes into play after the scheduler. When the scheduler completes its job of selecting a process, it is the dispatcher which takes that process to the desired state/queue. The dispatcher is the module that gives a process control over the CPU after it has been selected by the short-term scheduler. This function involves the following:

Switching context

Switching to user mode

Jumping to the proper location in the user program to restart that program

The Difference between the Scheduler and Dispatcher –

Consider a situation, where various processes are residing in the ready queue waiting to be executed. The CPU cannot execute all of these processes simultaneously, so the operating system has to choose a particular process on the basis of the scheduling algorithm used. So, this procedure of selecting a process among various processes is done by the scheduler. Once the scheduler has selected a process from the queue, the dispatcher comes into the picture, and it is the dispatcher who takes that process from the ready queue and moves it into the running state. Therefore, the scheduler gives the dispatcher an ordered list of processes which the dispatcher moves to the CPU over time.

Example –

There are 4 processes in the ready queue, P1, P2, P3, P4; Their arrival times are t0, t1, t2, t3 respectively. A First in First out (FIFO) scheduling algorithm is used. Because P1 arrived first, the scheduler will decide it is the first process that should be executed, and the dispatcher will remove P1 from the ready queue and give it to the CPU. The scheduler will then determine P2 to be the next process that should be executed, so when the dispatcher returns to the queue for a new process, it will take P2 and give it to the CPU. This continues in the same way for P3, and then P4.

Properties DISPATCHER SCHEDULER Definition: Dispatcher is a module that gives control of CPU to the process selected by short term scheduler Scheduler is something which selects a process among various processes Types: There are no different types in dispatcher.It is just a code segment. There are 3 types of scheduler i.e. Long-term, Short-term, Medium-term Dependency: Working of dispatcher is dependent on scheduler.Means dispatcher have to wait until scheduler selects a process. Scheduler works independently. It works immediately when needed Algorithm: Dispatcher has no specific algorithm for its implementation Scheduler works on various algorithm such as FCFS, SJF, RR etc. Time Taken: The time taken by dispatcher is called dispatch latency. Time taken by scheduler is usually negligible.Hence we neglect it. Functions: Dispatcher is also responsible for:Context Switching, Switch to user mode, Jumping to proper location when process again restarted The only work of scheduler is selection of processes.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3, BenTrono, adrian_monk"
26,"Given n processes with their burst times, the task is to find average waiting time and average turn around time using FCFS scheduling algorithm.

First in, first out (FIFO), also known as first come, first served (FCFS), is the simplest scheduling algorithm. FIFO simply queues processes in the order that they arrive in the ready queue.

In this, the process that comes first will be executed first and next process starts only after the previous gets fully executed.

Here we are considering that arrival time for all processes is 0.

How to compute below times in Round Robin using a program?

Completion Time: Time at which process completes its execution. Turn Around Time: Time Difference between completion time and arrival time. Turn Around Time = Completion Time – Arrival Time Waiting Time(W.T): Time Difference between turn around time and burst time.

Waiting Time = Turn Around Time – Burst Time



In this post, we have assumed arrival times as 0, so turn around and completion times are same.

Implementation:

1- Input the processes along with their burst time (bt). 2- Find waiting time (wt) for all processes. 3- As first process that comes need not to wait so waiting time for process 1 will be 0 i.e. wt[0] = 0. 4- Find waiting time for all other processes i.e. for process i -> wt[i] = bt[i-1] + wt[i-1] . 5- Find turnaround time = waiting_time + burst_time for all processes. 6- Find average waiting time = total_waiting_time / no_of_processes. 7- Similarly, find average turnaround time = total_turn_around_time / no_of_processes.

C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> using namespace std; void findWaitingTime( int processes[], int n, int bt[], int wt[]) { wt[0] = 0; for ( int i = 1; i < n ; i++ ) wt[i] = bt[i-1] + wt[i-1] ; } void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } void findavgTime( int processes[], int n, int bt[]) { int wt[n], tat[n], total_wt = 0, total_tat = 0; findWaitingTime(processes, n, bt, wt); findTurnAroundTime(processes, n, bt, wt, tat); cout << ""Processes "" << "" Burst time "" << "" Waiting time "" << "" Turn around time

"" ; for ( int i=0; i<n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; cout << "" "" << i+1 << ""\t\t"" << bt[i] << ""\t "" << wt[i] << ""\t\t "" << tat[i] <<endl; } cout << ""Average waiting time = "" << ( float )total_wt / ( float )n; cout << ""

Average turn around time = "" << ( float )total_tat / ( float )n; } int main() { int processes[] = { 1, 2, 3}; int n = sizeof processes / sizeof processes[0]; int burst_time[] = {10, 5, 8}; findavgTime(processes, n, burst_time); return 0; } chevron_right filter_none C filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> void findWaitingTime( int processes[], int n, int bt[], int wt[]) { wt[0] = 0; for ( int i = 1; i < n ; i++ ) wt[i] = bt[i-1] + wt[i-1] ; } void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } void findavgTime( int processes[], int n, int bt[]) { int wt[n], tat[n], total_wt = 0, total_tat = 0; findWaitingTime(processes, n, bt, wt); findTurnAroundTime(processes, n, bt, wt, tat); printf ( ""Processes Burst time Waiting time Turn around time

"" ); for ( int i=0; i<n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; printf ( "" %d "" ,(i+1)); printf ( "" %d "" , bt[i] ); printf ( "" %d"" ,wt[i] ); printf ( "" %d

"" ,tat[i] ); } int s=( float )total_wt / ( float )n; int t=( float )total_tat / ( float )n; printf ( ""Average waiting time = %d"" ,s); printf ( ""

"" ); printf ( ""Average turn around time = %d "" ,t); } int main() { int processes[] = { 1, 2, 3}; int n = sizeof processes / sizeof processes[0]; int burst_time[] = {10, 5, 8}; findavgTime(processes, n, burst_time); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.text.ParseException; class GFG { static void findWaitingTime( int processes[], int n, int bt[], int wt[]) { wt[ 0 ] = 0 ; for ( int i = 1 ; i < n; i++) { wt[i] = bt[i - 1 ] + wt[i - 1 ]; } } static void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0 ; i < n; i++) { tat[i] = bt[i] + wt[i]; } } static void findavgTime( int processes[], int n, int bt[]) { int wt[] = new int [n], tat[] = new int [n]; int total_wt = 0 , total_tat = 0 ; findWaitingTime(processes, n, bt, wt); findTurnAroundTime(processes, n, bt, wt, tat); System.out.printf( ""Processes Burst time Waiting"" + "" time Turn around time

"" ); for ( int i = 0 ; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; System.out.printf( "" %d "" , (i + 1 )); System.out.printf( "" %d "" , bt[i]); System.out.printf( "" %d"" , wt[i]); System.out.printf( "" %d

"" , tat[i]); } float s = ( float )total_wt /( float ) n; int t = total_tat / n; System.out.printf( ""Average waiting time = %f"" , s); System.out.printf( ""

"" ); System.out.printf( ""Average turn around time = %d "" , t); } public static void main(String[] args) throws ParseException { int processes[] = { 1 , 2 , 3 }; int n = processes.length; int burst_time[] = { 10 , 5 , 8 }; findavgTime(processes, n, burst_time); } } chevron_right filter_none Python 3 filter_none edit

close play_arrow link

brightness_4

code def findWaitingTime(processes, n, bt, wt): wt[ 0 ] = 0 for i in range ( 1 , n ): wt[i] = bt[i - 1 ] + wt[i - 1 ] def findTurnAroundTime(processes, n, bt, wt, tat): for i in range (n): tat[i] = bt[i] + wt[i] def findavgTime( processes, n, bt): wt = [ 0 ] * n tat = [ 0 ] * n total_wt = 0 total_tat = 0 findWaitingTime(processes, n, bt, wt) findTurnAroundTime(processes, n, bt, wt, tat) print ( ""Processes Burst time "" + "" Waiting time "" + "" Turn around time"" ) for i in range (n): total_wt = total_wt + wt[i] total_tat = total_tat + tat[i] print ( "" "" + str (i + 1 ) + ""\t\t"" + str (bt[i]) + ""\t "" + str (wt[i]) + ""\t\t "" + str (tat[i])) print ( ""Average waiting time = "" + str (total_wt / n)) print ( ""Average turn around time = "" + str (total_tat / n)) if __name__ = = ""__main__"" : processes = [ 1 , 2 , 3 ] n = len (processes) burst_time = [ 10 , 5 , 8 ] findavgTime(processes, n, burst_time) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; class GFG { static void findWaitingTime( int []processes, int n, int []bt, int [] wt) { wt[0] = 0; for ( int i = 1; i < n; i++) { wt[i] = bt[i - 1] + wt[i - 1]; } } static void findTurnAroundTime( int []processes, int n, int []bt, int []wt, int []tat) { for ( int i = 0; i < n; i++) { tat[i] = bt[i] + wt[i]; } } static void findavgTime( int []processes, int n, int []bt) { int []wt = new int [n]; int []tat = new int [n]; int total_wt = 0, total_tat = 0; findWaitingTime(processes, n, bt, wt); findTurnAroundTime(processes, n, bt, wt, tat); Console.Write( ""Processes Burst time Waiting"" + "" time Turn around time

"" ); for ( int i = 0; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; Console.Write( "" {0} "" , (i + 1)); Console.Write( "" {0} "" , bt[i]); Console.Write( "" {0}"" , wt[i]); Console.Write( "" {0}

"" , tat[i]); } float s = ( float )total_wt /( float ) n; int t = total_tat / n; Console.Write( ""Average waiting time = {0}"" , s); Console.Write( ""

"" ); Console.Write( ""Average turn around time = {0} "" , t); } public static void Main(String[] args) { int []processes = {1, 2, 3}; int n = processes.Length; int []burst_time = {10, 5, 8}; findavgTime(processes, n, burst_time); } } chevron_right filter_none

Processes Burst time Waiting time Turn around time 1 10 0 10 2 5 10 15 3 8 15 23 Average waiting time = 8.33333 Average turn around time = 16

Important Points:"
27,"We have already discussed FCFS Scheduling of processes with same arrival time. In this post, scenario when processes have different arrival times are discussed. Given n processes with their burst times and arrival times, the task is to find average waiting time and average turn around time using FCFS scheduling algorithm.

FIFO simply queues processes in the order they arrive in the ready queue. Here, the process that comes first will be executed first and next process will start only after the previous gets fully executed.



Completion Time: Time at which process completes its execution. Turn Around Time: Time Difference between completion time and arrival time. Turn Around Time = Completion Time – Arrival Time Waiting Time(W.T): Time Difference between turn around time and burst time.

Waiting Time = Turn Around Time – Burst Time

Process Wait Time : Service Time - Arrival Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 8 - 2 = 6 P3 16 - 3 = 13 Average Wait Time: (0 + 4 + 6 + 13) / 4 = 5.75

Service Time : Service time means amount of time after which a process can start execution. It is summation of burst time of previous processes (Processes that came before)

Changes in code as compare to code of FCFS with same arrival time:

To find waiting time: Time taken by all processes before the current process to be started (i.e. burst time of all previous processes) – arrival time of current process

wait_time[i] = (bt[0] + bt[1] +…… bt[i-1] ) – arrival_time[i]

Implementation:



1- Input the processes along with their burst time(bt) and arrival time(at) 2- Find waiting time for all other processes i.e. for a given process i: wt[i] = (bt[0] + bt[1] +...... bt[i-1]) - at[i] 3- Now find turn around time = waiting_time + burst_time for all processes 4- Average waiting time = total_waiting_time / no_of_processes 5- Average turn around time = total_turn_around_time / no_of_processes

C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> using namespace std; void findWaitingTime( int processes[], int n, int bt[], int wt[], int at[]) { int service_time[n]; service_time[0] = 0; wt[0] = 0; for ( int i = 1; i < n ; i++) { service_time[i] = service_time[i-1] + bt[i-1]; wt[i] = service_time[i] - at[i]; if (wt[i] < 0) wt[i] = 0; } } void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } void findavgTime( int processes[], int n, int bt[], int at[]) { int wt[n], tat[n]; findWaitingTime(processes, n, bt, wt, at); findTurnAroundTime(processes, n, bt, wt, tat); cout << ""Processes "" << "" Burst Time "" << "" Arrival Time "" << "" Waiting Time "" << "" Turn-Around Time "" << "" Completion Time

"" ; int total_wt = 0, total_tat = 0; for ( int i = 0 ; i < n ; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; int compl_time = tat[i] + at[i]; cout << "" "" << i+1 << ""\t\t"" << bt[i] << ""\t\t"" << at[i] << ""\t\t"" << wt[i] << ""\t\t "" << tat[i] << ""\t\t "" << compl_time << endl; } cout << ""Average waiting time = "" << ( float )total_wt / ( float )n; cout << ""

Average turn around time = "" << ( float )total_tat / ( float )n; } int main() { int processes[] = {1, 2, 3}; int n = sizeof processes / sizeof processes[0]; int burst_time[] = {5, 9, 6}; int arrival_time[] = {0, 3, 6}; findavgTime(processes, n, burst_time, arrival_time); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code public class GFG{ static void findWaitingTime( int processes[], int n, int bt[], int wt[], int at[]) { int service_time[] = new int [n]; service_time[ 0 ] = 0 ; wt[ 0 ] = 0 ; for ( int i = 1 ; i < n ; i++) { int wasted= 0 ; service_time[i] = service_time[i- 1 ] + bt[i- 1 ]; wt[i] = service_time[i] - at[i]; if (wt[i] < 0 ) { wasted = Math.abs(wt[i]); wt[i] = 0 ; } service_time[i] = service_time[i] + wasted; } } static void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0 ; i < n ; i++) tat[i] = bt[i] + wt[i]; } static void findavgTime( int processes[], int n, int bt[], int at[]) { int wt[] = new int [n], tat[] = new int [n]; findWaitingTime(processes, n, bt, wt, at); findTurnAroundTime(processes, n, bt, wt, tat); System.out.print( ""Processes "" + "" Burst Time "" + "" Arrival Time "" + "" Waiting Time "" + "" Turn-Around Time "" + "" Completion Time

"" ); int total_wt = 0 , total_tat = 0 ; for ( int i = 0 ; i < n ; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; int compl_time = tat[i] + at[i]; System.out.println(i+ 1 + ""\t\t"" + bt[i] + ""\t\t"" + at[i] + ""\t\t"" + wt[i] + ""\t\t "" + tat[i] + ""\t\t "" + compl_time); } System.out.print( ""Average waiting time = "" + ( float )total_wt / ( float )n); System.out.print( ""

Average turn around time = "" + ( float )total_tat / ( float )n); } public static void main(String args[]) { int processes[] = { 1 , 2 , 3 }; int n = processes.length; int burst_time[] = { 5 , 9 , 6 }; int arrival_time[] = { 0 , 3 , 6 }; findavgTime(processes, n, burst_time, arrival_time); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def findWaitingTime(processes, n, bt, wt, at): service_time = [ 0 ] * n service_time[ 0 ] = 0 wt[ 0 ] = 0 for i in range ( 1 , n): service_time[i] = (service_time[i - 1 ] + bt[i - 1 ]) wt[i] = service_time[i] - at[i] if (wt[i] < 0 ): wt[i] = 0 def findTurnAroundTime(processes, n, bt, wt, tat): for i in range (n): tat[i] = bt[i] + wt[i] def findavgTime(processes, n, bt, at): wt = [ 0 ] * n tat = [ 0 ] * n findWaitingTime(processes, n, bt, wt, at) findTurnAroundTime(processes, n, bt, wt, tat) print ( ""Processes Burst Time Arrival Time Waiting"" , ""Time Turn-Around Time Completion Time

"" ) total_wt = 0 total_tat = 0 for i in range (n): total_wt = total_wt + wt[i] total_tat = total_tat + tat[i] compl_time = tat[i] + at[i] print ( "" "" , i + 1 , ""\t\t"" , bt[i], ""\t\t"" , at[i], ""\t\t"" , wt[i], ""\t\t "" , tat[i], ""\t\t "" , compl_time) print ( ""Average waiting time = %.5f "" % (total_wt / n)) print ( ""

Average turn around time = "" , total_tat / n) if __name__ = = ""__main__"" : processes = [ 1 , 2 , 3 ] n = 3 burst_time = [ 5 , 9 , 6 ] arrival_time = [ 0 , 3 , 6 ] findavgTime(processes, n, burst_time, arrival_time) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; public class GFG{ static void findWaitingTime( int []processes, int n, int []bt, int []wt, int []at) { int []service_time = new int [n]; service_time[0] = 0; wt[0] = 0; for ( int i = 1; i < n ; i++) { service_time[i] = service_time[i-1] + bt[i-1]; wt[i] = service_time[i] - at[i]; if (wt[i] < 0) wt[i] = 0; } } static void findTurnAroundTime( int []processes, int n, int [] bt, int []wt, int [] tat) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } static void findavgTime( int []processes, int n, int []bt, int []at) { int []wt = new int [n]; int []tat = new int [n]; findWaitingTime(processes, n, bt, wt, at); findTurnAroundTime(processes, n, bt, wt, tat); Console.Write( ""Processes "" + "" Burst Time "" + "" Arrival Time "" + "" Waiting Time "" + "" Turn-Around Time "" + "" Completion Time

"" ); int total_wt = 0, total_tat = 0; for ( int i = 0 ; i < n ; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; int compl_time = tat[i] + at[i]; Console.WriteLine(i+1 + ""\t\t"" + bt[i] + ""\t\t"" + at[i] + ""\t\t"" + wt[i] + ""\t\t "" + tat[i] + ""\t\t "" + compl_time); } Console.Write( ""Average waiting time = "" + ( float )total_wt / ( float )n); Console.Write( ""

Average turn around time = "" + ( float )total_tat / ( float )n); } public static void Main(String []args) { int []processes = {1, 2, 3}; int n = processes.Length; int []burst_time = {5, 9, 6}; int []arrival_time = {0, 3, 6}; findavgTime(processes, n, burst_time, arrival_time); } } chevron_right filter_none

Output:



Processes Burst Time Arrival Time Waiting Time Turn-Around Time Completion Time 1 5 0 0 5 5 2 9 3 2 11 14 3 6 6 8 14 20 Average waiting time = 3.33333 Average turn around time = 10.0

This article is contributed by Sahil Chhabra (akku). If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
28,"Prerequisites : Basics of FCFS Scheduling (Program for FCFS Scheduling | Set 1, Program for FCFS Scheduling | Set 2 )

Convoy Effect is phenomenon associated with the First Come First Serve (FCFS) algorithm, in which the whole Operating System slows down due to few slow processes.

FCFS algorithm is non-preemptive in nature, that is, once CPU time has been allocated to a process, other processes can get CPU time only after the current process has finished. This property of FCFS scheduling leads to the situation called Convoy Effect.

Suppose there is one CPU intensive (large burst time) process in the ready queue, and several other processes with relatively less burst times but are Input/Output (I/O) bound (Need I/O operations frequently).

Steps are as following below:

The I/O bound processes are first allocated CPU time. As they are less CPU intensive, they quickly get executed and goto I/O queues.

Now, the CPU intensive process is allocated CPU time. As its burst time is high, it takes time to complete.

While the CPU intensive process is being executed, the I/O bound processes complete their I/O operations and are moved back to ready queue.

However, the I/O bound processes are made to wait as the CPU intensive process still hasn’t finished. This leads to I/O devices being idle.

When the CPU intensive process gets over, it is sent to the I/O queue so that it can access an I/O device.

Meanwhile, the I/O bound processes get their required CPU time and move back to I/O queue.

However, they are made to wait because the CPU intensive process is still accessing an I/O device. As a result, the CPU is sitting idle now.

Hence in Convoy Effect, one slow process slows down the performance of the entire set of processes, and leads to wastage of CPU time and other devices.

To avoid Convoy Effect, preemptive scheduling algorithms like Round Robin Scheduling can be used – as the smaller processes don’t have to wait much for CPU time – making their execution faster and leading to less resources sitting idle.

References –

A. Silberschatz, P. Galvin, G. Gagne, “Operating Systems Concepts (8th Edition)”, Wiley India Pvt. Ltd.

This article is contributed by Sanchit Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : anish3007, saurabhhjjain"
29,"Prerequisite – Page Replacement Algorithms

In Operating System, process data is loaded in fixed sized chunks and each chunk is referred to as a page. The processor loads these pages in the fixed sized chunks of memory called frames. Typically the size of each page is always equal to the frame size.

A page fault occurs when a page is not found in the memory, and needs to be loaded from the disk. If a page fault occurs and all memory frames have been already allocated, then replacement of a page in memory is required on the request of a new page. This is referred to as demand-paging. The choice of which page to replace is specified by a page replacement algorithms. The commonly used page replacement algorithms are FIFO, LRU, optimal page replacement algorithms etc.

Generally, on increasing the number of frames to a process’ virtual memory, its execution becomes faster as less number of page faults occur. Sometimes the reverse happens, i.e. more number of page faults occur when more frames are allocated to a process. This most unexpected result is termed as Belady’s Anomaly.

Bélády’s anomaly is the name given to the phenomenon where increasing the number of page frames results in an increase in the number of page faults for a given memory access pattern.

This phenomenon is commonly experienced in following page replacement algorithms:

First in first out (FIFO) Second chance algorithm Random page replacement algorithm

Reason of Belady’s Anomaly –

The other two commonly used page replacement algorithms are Optimal and LRU, but Belady’s Anamoly can never occur in these algorithms for any reference string as they belong to a class of stack based page replacement algorithms.

A stack based algorithm is one for which it can be shown that the set of pages in memory for N frames is always a subset of the set of pages that would be in memory with N + 1 frames. For LRU replacement, the set of pages in memory would be the n most recently referenced pages. If the number of frames increases then these n pages will still be the most recently referenced and so, will still be in the memory. While in FIFO, if a page named b came into physical memory before a page – a then priority of replacement of b is greater than that of a, but this is not independent of the number of page frames and hence, FIFO does not follow a stack page replacement policy and therefore suffers Belady’s Anomaly.

Example: Consider the following diagram to understand the behaviour of a stack-based page replacement algorithm

The diagram illustrates that given the set of pages i.e. {0, 1, 2} in 3 frames of memory is not a subset of the pages in memory – {0, 1, 4, 5} with 4 frames and it is a violation in the property of stack based algorithms. This situation can be frequently seen in FIFO algorithm.

Belady’s Anomaly in FIFO –

Assuming a system that has no pages loaded in the memory and uses the FIFO Page replacement algorithm. Consider the following reference string:

1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

Case-1: If the system has 3 frames, the given reference string on using FIFO page replacement algorithm yields a total of 9 page faults. The diagram below illustrates the pattern of the page faults occurring in the example.

Case-2: If the system has 4 frames, the given reference string on using FIFO page replacement algorithm yields a total of 10 page faults. The diagram below illustrates the pattern of the page faults occurring in the example.

It can be seen from the above example that on increasing the number of frames while using the FIFO page replacement algorithm, the number of page faults increased from 9 to 10.

Note – It is not necessary that every string reference pattern cause Belady anomaly in FIFO but there are certain kind of string references that worsen the FIFO performance on increasing the number of frames.

Why Stack based algorithms do not suffer Anomaly –

All the stack based algorithms never suffer Belady Anomaly because these type of algorithms assigns a priority to a page (for replacement) that is independent of the number of page frames. Examples of such policies are Optimal, LRU and LFU. Additionally these algorithms also have a good property for simulation, i.e. the miss (or hit) ratio can be computed for any number of page frames with a single pass through the reference string.

In LRU algorithm every time a page is referenced it is moved at the top of the stack, so, the top n pages of the stack are the n most recently used pages.Even if the number of frames are incremented to n+1, top of the stack will have n+1 most recently used pages.

Similar example can be used to calculate the number of page faults in LRU algorithm. Assuming a system that has no pages loaded in the memory and uses the LRU Page replacement algorithm. Consider the following reference string:

1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

Case-1: If the system has 3 frames, the given reference string on using LRU page replacement algorithm yields a total of 10 page faults. The diagram below illustrates the pattern of the page faults occurring in the example.

Case-2: If the system has 4 frames, the given reference string on using LRU page replacement algorithm, then total 8 page faults occur. The diagram shows the pattern of the page faults in the example.

Conclusion –

Various factors substantially affect the number of page faults, such as reference string length and the number of free page frames available. Anomalies also occurs due to the small cache size as well as the reckless rate of change of the contents of cache. Also, the situation of fixed number of page faults even after increasing the number of frames can also be seen as an anomaly. Often algorithms like Random page replacement algorithm are also susceptible to Belady’s Anomaly, because it may behave like first in first out (FIFO) page replacement algorithm. But Stack based algorithms are generally immune to all such situations as they are guaranteed to give better page hits when the frames are incremented.

GATE CS Corner questions –

Practicing the following questions will help you test your knowledge. All questions have been asked in GATE in previous years or in GATE Mock Tests. It is highly recommended that you practice them.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
30,"Shortest job first (SJF) or shortest job next, is a scheduling policy that selects the waiting process with the smallest execution time to execute next. SJN is a non-preemptive algorithm.

Shortest Job first has the advantage of having a minimum average waiting time among all scheduling algorithms.

It is a Greedy Algorithm.

It may cause starvation if shorter processes keep coming. This problem can be solved using the concept of ageing.

It is practically infeasible as Operating System may not know burst time and therefore may not sort them. While it is not possible to predict execution time, several methods can be used to estimate the execution time for a job, such as a weighted average of previous execution times. SJF can be used in specialized environments where accurate estimates of running time are available.

Algorithm:

Sort all the process according to the arrival time. Then select that process which has minimum arrival time and minimum Burst time. After completion of process make a pool of process which after till the completion of previous process and select that process among the pool which is having minimum Burst time.

How to compute below times in SJF using a program?

Completion Time: Time at which process completes its execution. Turn Around Time: Time Difference between completion time and arrival time. Turn Around Time = Completion Time – Arrival Time Waiting Time(W.T): Time Difference between turn around time and burst time.

Waiting Time = Turn Around Time – Burst Time

In this post, we have assumed arrival times as 0, so turn around and completion times are same.

C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> using namespace std; int mat[10][6]; void swap( int *a, int *b) { int temp = *a; *a = *b; *b = temp; } void arrangeArrival( int num, int mat[][6]) { for ( int i=0; i<num; i++) { for ( int j=0; j<num-i-1; j++) { if (mat[j][1] > mat[j+1][1]) { for ( int k=0; k<5; k++) { swap(mat[j][k], mat[j+1][k]); } } } } } void completionTime( int num, int mat[][6]) { int temp, val; mat[0][3] = mat[0][1] + mat[0][2]; mat[0][5] = mat[0][3] - mat[0][1]; mat[0][4] = mat[0][5] - mat[0][2]; for ( int i=1; i<num; i++) { temp = mat[i-1][3]; int low = mat[i][2]; for ( int j=i; j<num; j++) { if (temp >= mat[j][1] && low >= mat[j][2]) { low = mat[j][2]; val = j; } } mat[val][3] = temp + mat[val][2]; mat[val][5] = mat[val][3] - mat[val][1]; mat[val][4] = mat[val][5] - mat[val][2]; for ( int k=0; k<6; k++) { swap(mat[val][k], mat[i][k]); } } } int main() { int num, temp; cout<< ""Enter number of Process: "" ; cin>>num; cout<< ""...Enter the process ID...

"" ; for ( int i=0; i<num; i++) { cout<< ""...Process "" <<i+1<< ""...

"" ; cout<< ""Enter Process Id: "" ; cin>>mat[i][0]; cout<< ""Enter Arrival Time: "" ; cin>>mat[i][1]; cout<< ""Enter Burst Time: "" ; cin>>mat[i][2]; } cout<< ""Before Arrange...

"" ; cout<< ""Process ID\tArrival Time\tBurst Time

"" ; for ( int i=0; i<num; i++) { cout<<mat[i][0]<< ""\t\t"" <<mat[i][1]<< ""\t\t"" <<mat[i][2]<< ""

"" ; } arrangeArrival(num, mat); completionTime(num, mat); cout<< ""Final Result...

"" ; cout<< ""Process ID\tArrival Time\tBurst Time\tWaiting Time\tTurnaround Time

"" ; for ( int i=0; i<num; i++) { cout<<mat[i][0]<< ""\t\t"" <<mat[i][1]<< ""\t\t"" <<mat[i][2]<< ""\t\t"" <<mat[i][4]<< ""\t\t"" <<mat[i][5]<< ""

"" ; } } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; class GFG { static int [][] mat = new int [ 10 ][ 6 ]; static void arrangeArrival( int num, int [][] mat) { for ( int i = 0 ; i < num; i++) { for ( int j = 0 ; j < num - i - 1 ; j++) { if (mat[j][ 1 ] > mat[j + 1 ][ 1 ]) { for ( int k = 0 ; k < 5 ; k++) { int temp = mat[j][k]; mat[j][k] = mat[j + 1 ][k]; mat[j + 1 ][k] = temp; } } } } } static void completionTime( int num, int [][] mat) { int temp, val = - 1 ; mat[ 0 ][ 3 ] = mat[ 0 ][ 1 ] + mat[ 0 ][ 2 ]; mat[ 0 ][ 5 ] = mat[ 0 ][ 3 ] - mat[ 0 ][ 1 ]; mat[ 0 ][ 4 ] = mat[ 0 ][ 5 ] - mat[ 0 ][ 2 ]; for ( int i = 1 ; i < num; i++) { temp = mat[i - 1 ][ 3 ]; int low = mat[i][ 2 ]; for ( int j = i; j < num; j++) { if (temp >= mat[j][ 1 ] && low >= mat[j][ 2 ]) { low = mat[j][ 2 ]; val = j; } } mat[val][ 3 ] = temp + mat[val][ 2 ]; mat[val][ 5 ] = mat[val][ 3 ] - mat[val][ 1 ]; mat[val][ 4 ] = mat[val][ 5 ] - mat[val][ 2 ]; for ( int k = 0 ; k < 6 ; k++) { int tem = mat[val][k]; mat[val][k] = mat[i][k]; mat[i][k] = tem; } } } public static void main(String[] args) { int num; Scanner sc = new Scanner(System.in); System.out.println( ""Enter number of Process: "" ); num = sc.nextInt(); System.out.println( ""...Enter the process ID..."" ); for ( int i = 0 ; i < num; i++) { System.out.println( ""...Process "" + (i + 1 ) + ""..."" ); System.out.println( ""Enter Process Id: "" ); mat[i][ 0 ] = sc.nextInt(); System.out.println( ""Enter Arrival Time: "" ); mat[i][ 1 ] = sc.nextInt(); System.out.println( ""Enter Burst Time: "" ); mat[i][ 2 ] = sc.nextInt(); } System.out.println( ""Before Arrange..."" ); System.out.println( ""Process ID\tArrival Time\tBurst Time"" ); for ( int i = 0 ; i < num; i++) { System.out.printf( ""%d\t\t%d\t\t%d

"" , mat[i][ 0 ], mat[i][ 1 ], mat[i][ 2 ]); } arrangeArrival(num, mat); completionTime(num, mat); System.out.println( ""Final Result..."" ); System.out.println( ""Process ID\tArrival Time\tBurst"" + "" Time\tWaiting Time\tTurnaround Time"" ); for ( int i = 0 ; i < num; i++) { System.out.printf( ""%d\t\t%d\t\t%d\t\t%d\t\t%d

"" , mat[i][ 0 ], mat[i][ 1 ], mat[i][ 2 ], mat[i][ 4 ], mat[i][ 5 ]); } sc.close(); } } chevron_right filter_none

Output:

Process ID Arrival Time Burst Time 1 2 3 2 0 4 3 4 2 4 5 4 Final Result... Process ID Arrival Time Burst Time Waiting Time Turnaround Time 2 0 4 0 4 3 4 2 0 2 1 2 3 4 7 4 5 4 4 8

In Set-2 we will discuss the preemptive version of SJF i.e. Shortest Remaining Time First

This article is contributed by Mahesh Kumar(NCE, Chandi). If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : anish3007, msujawal, sanjeev2552"
31,"

In previous post, we have discussed Set 1 of SJF i.e. non-preemptive. In this post we will discuss the preemptive version of SJF known as Shortest Remaining Time First (SRTF).

Shortest Remaining Time First (SRTF) scheduling

In the Shortest Remaining Time First (SRTF) scheduling algorithm, the process with the smallest amount of time remaining until completion is selected to execute. Since the currently executing process is the one with the shortest amount of time remaining by definition, and since that time should only reduce as execution progresses, processes will always run until they complete or a new process is added that requires a smaller amount of time.

Shortest Remaining Time First (Preemptive SJF): Example

Process Duration Order Arrival Time P1 9 1 0 P2 2 2 2

P1 waiting time: 4-2 = 2

P2 waiting time: 0

The average waiting time(AWT): (0 + 2) / 2 = 1





Advantage:

1- Short processes are handled very quickly.

2- The system also requires very little overhead since it only makes a decision when a process completes or a new process is added.

3- When a new process is added the algorithm only needs to compare the currently executing process with the new process, ignoring all other processes currently waiting to execute.

Disadvantage:

1- Like shortest job first, it has the potential for process starvation.

2- Long processes may be held off indefinitely if short processes are continually added.

Source:Wiki

Implementation:

1- Traverse until all process gets completely executed. a) Find process with minimum remaining time at every single time lap. b) Reduce its time by 1. c) Check if its remaining time becomes 0 d) Increment the counter of process completion. e) Completion time of current process = current_time +1; e) Calculate waiting time for each completed process. wt[i]= Completion time - arrival_time-burst_time f)Increment time lap by one. 2- Find turnaround time (waiting_time+burst_time).

C/C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; struct Process { int pid; int bt; int art; }; void findWaitingTime(Process proc[], int n, int wt[]) { int rt[n]; for ( int i = 0; i < n; i++) rt[i] = proc[i].bt; int complete = 0, t = 0, minm = INT_MAX; int shortest = 0, finish_time; bool check = false ; while (complete != n) { for ( int j = 0; j < n; j++) { if ((proc[j].art <= t) && (rt[j] < minm) && rt[j] > 0) { minm = rt[j]; shortest = j; check = true ; } } if (check == false ) { t++; continue ; } rt[shortest]--; minm = rt[shortest]; if (minm == 0) minm = INT_MAX; if (rt[shortest] == 0) { complete++; check = false ; finish_time = t + 1; wt[shortest] = finish_time - proc[shortest].bt - proc[shortest].art; if (wt[shortest] < 0) wt[shortest] = 0; } t++; } } void findTurnAroundTime(Process proc[], int n, int wt[], int tat[]) { for ( int i = 0; i < n; i++) tat[i] = proc[i].bt + wt[i]; } void findavgTime(Process proc[], int n) { int wt[n], tat[n], total_wt = 0, total_tat = 0; findWaitingTime(proc, n, wt); findTurnAroundTime(proc, n, wt, tat); cout << ""Processes "" << "" Burst time "" << "" Waiting time "" << "" Turn around time

"" ; for ( int i = 0; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; cout << "" "" << proc[i].pid << ""\t\t"" << proc[i].bt << ""\t\t "" << wt[i] << ""\t\t "" << tat[i] << endl; } cout << ""

Average waiting time = "" << ( float )total_wt / ( float )n; cout << ""

Average turn around time = "" << ( float )total_tat / ( float )n; } int main() { Process proc[] = { { 1, 6, 1 }, { 2, 8, 1 }, { 3, 7, 2 }, { 4, 3, 3 } }; int n = sizeof (proc) / sizeof (proc[0]); findavgTime(proc, n); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code class Process { int pid; int bt; int art; public Process( int pid, int bt, int art) { this .pid = pid; this .bt = bt; this .art = art; } } public class GFG { static void findWaitingTime(Process proc[], int n, int wt[]) { int rt[] = new int [n]; for ( int i = 0 ; i < n; i++) rt[i] = proc[i].bt; int complete = 0 , t = 0 , minm = Integer.MAX_VALUE; int shortest = 0 , finish_time; boolean check = false ; while (complete != n) { for ( int j = 0 ; j < n; j++) { if ((proc[j].art <= t) && (rt[j] < minm) && rt[j] > 0 ) { minm = rt[j]; shortest = j; check = true ; } } if (check == false ) { t++; continue ; } rt[shortest]--; minm = rt[shortest]; if (minm == 0 ) minm = Integer.MAX_VALUE; if (rt[shortest] == 0 ) { complete++; check = false ; finish_time = t + 1 ; wt[shortest] = finish_time - proc[shortest].bt - proc[shortest].art; if (wt[shortest] < 0 ) wt[shortest] = 0 ; } t++; } } static void findTurnAroundTime(Process proc[], int n, int wt[], int tat[]) { for ( int i = 0 ; i < n; i++) tat[i] = proc[i].bt + wt[i]; } static void findavgTime(Process proc[], int n) { int wt[] = new int [n], tat[] = new int [n]; int total_wt = 0 , total_tat = 0 ; findWaitingTime(proc, n, wt); findTurnAroundTime(proc, n, wt, tat); System.out.println( ""Processes "" + "" Burst time "" + "" Waiting time "" + "" Turn around time"" ); for ( int i = 0 ; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; System.out.println( "" "" + proc[i].pid + ""\t\t"" + proc[i].bt + ""\t\t "" + wt[i] + ""\t\t"" + tat[i]); } System.out.println( ""Average waiting time = "" + ( float )total_wt / ( float )n); System.out.println( ""Average turn around time = "" + ( float )total_tat / ( float )n); } public static void main(String[] args) { Process proc[] = { new Process( 1 , 6 , 1 ), new Process( 2 , 8 , 1 ), new Process( 3 , 7 , 2 ), new Process( 4 , 3 , 3 )}; findavgTime(proc, proc.length); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def findWaitingTime(processes, n, wt): rt = [ 0 ] * n for i in range (n): rt[i] = processes[i][ 1 ] complete = 0 t = 0 minm = 999999999 short = 0 check = False while (complete ! = n): for j in range (n): if ((processes[j][ 2 ] < = t) and (rt[j] < minm) and rt[j] > 0 ): minm = rt[j] short = j check = True if (check = = False ): t + = 1 continue rt[short] - = 1 minm = rt[short] if (minm = = 0 ): minm = 999999999 if (rt[short] = = 0 ): complete + = 1 check = False fint = t + 1 wt[short] = (fint - proc[short][ 1 ] - proc[short][ 2 ]) if (wt[short] < 0 ): wt[short] = 0 t + = 1 def findTurnAroundTime(processes, n, wt, tat): for i in range (n): tat[i] = processes[i][ 1 ] + wt[i] def findavgTime(processes, n): wt = [ 0 ] * n tat = [ 0 ] * n findWaitingTime(processes, n, wt) findTurnAroundTime(processes, n, wt, tat) print ( ""Processes Burst Time Waiting"" , ""Time Turn-Around Time"" ) total_wt = 0 total_tat = 0 for i in range (n): total_wt = total_wt + wt[i] total_tat = total_tat + tat[i] print ( "" "" , processes[i][ 0 ], ""\t\t"" , processes[i][ 1 ], ""\t\t"" , wt[i], ""\t\t"" , tat[i]) print ( ""

Average waiting time = %.5f "" % (total_wt / n) ) print ( ""Average turn around time = "" , total_tat / n) if __name__ = = ""__main__"" : proc = [[ 1 , 6 , 1 ], [ 2 , 8 , 1 ], [ 3 , 7 , 2 ], [ 4 , 3 , 3 ]] n = 4 findavgTime(proc, n) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; public class Process { public int pid; public int bt; public int art; public Process( int pid, int bt, int art) { this .pid = pid; this .bt = bt; this .art = art; } } public class GFG { static void findWaitingTime(Process []proc, int n, int []wt) { int []rt = new int [n]; for ( int i = 0; i < n; i++) rt[i] = proc[i].bt; int complete = 0, t = 0, minm = int .MaxValue; int shortest = 0, finish_time; bool check = false ; while (complete != n) { for ( int j = 0; j < n; j++) { if ((proc[j].art <= t) && (rt[j] < minm) && rt[j] > 0) { minm = rt[j]; shortest = j; check = true ; } } if (check == false ) { t++; continue ; } rt[shortest]--; minm = rt[shortest]; if (minm == 0) minm = int .MaxValue; if (rt[shortest] == 0) { complete++; check = false ; finish_time = t + 1; wt[shortest] = finish_time - proc[shortest].bt - proc[shortest].art; if (wt[shortest] < 0) wt[shortest] = 0; } t++; } } static void findTurnAroundTime(Process []proc, int n, int []wt, int []tat) { for ( int i = 0; i < n; i++) tat[i] = proc[i].bt + wt[i]; } static void findavgTime(Process []proc, int n) { int []wt = new int [n]; int []tat = new int [n]; int total_wt = 0, total_tat = 0; findWaitingTime(proc, n, wt); findTurnAroundTime(proc, n, wt, tat); Console.WriteLine( ""Processes "" + "" Burst time "" + "" Waiting time "" + "" Turn around time"" ); for ( int i = 0; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; Console.WriteLine( "" "" + proc[i].pid + ""\t\t"" + proc[i].bt + ""\t\t "" + wt[i] + ""\t\t"" + tat[i]); } Console.WriteLine( ""Average waiting time = "" + ( float )total_wt / ( float )n); Console.WriteLine( ""Average turn around time = "" + ( float )total_tat / ( float )n); } public static void Main(String[] args) { Process []proc = { new Process(1, 6, 1), new Process(2, 8, 1), new Process(3, 7, 2), new Process(4, 3, 3)}; findavgTime(proc, proc.Length); } } chevron_right filter_none

Processes Burst time Waiting time Turn around time 1 6 3 9 2 8 16 24 3 7 8 15 4 3 0 3 Average waiting time = 6.75 Average turn around time = 12.75

This article is contributed by Sahil Chhabra. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : eagleateme, SHUBHAMSINGH10, 29AjayKumar"
32,"Prerequisite – CPU Scheduling, SJF – Set 1 (Non- preemptive), Set 2 (Preemptive)

Shortest Job First (SJF) is an optimal scheduling algorithm as it gives maximum Throughput and minimum average waiting time(WT) and turn around time (TAT) but it is not practically implementable because Burst-Time of a process can’t be predicted in advance.

We may not know the length of the next CPU burst, but we may be able to predict its value. We expect the next CPU burst will be similar in length to the previous ones. By computing an approximation of the length of the next CPU burst, we can pick the process with the shortest predicted CPU burst.

There are two methods by which we can predict the burst time of the process :

1. Static method – We can predict the Burst-Time by two factors :"
33,"Prerequisite – CPU Scheduling | Longest Remaining Time First (LRTF) algorithm

We have given some process with arrival time and Burst Time and we have to find the completion time (CT), Turn Around Time(TAT), Average Turn Around Time (Avg TAT), Waiting Time(WT), Average Waiting Time (AWT) for the given processes.

Example: Consider the following table of arrival time and burst time for four processes P1, P2, P3 and P4.

Process Arrival time Burst Time P1 1 ms 2 ms P2 2 ms 4 ms P3 3 ms 6 ms p4 4 ms 8 ms

Gantt chart will be as following below,

Since, complietion time (CT) can be directly determined by Gantt chart, and

Turn Around Time (TAT) = (Complition Time) - (Arival Time) Also, Waiting Time (WT) = (Turn Around Time) - (Burst Time)

Therefore,

Output:

Total Turn Around Time = 68 ms So, Average Turn Around Time = 68/4 = 17.00 ms And, Total Waiting Time = 48 ms So, Average Waiting Time = 12.00 ms

Algorithm –

Step-1: Create a structure of process containing all necessary fields like AT (Arrival Time), BT(Burst Time), CT(Completion Time), TAT(Turn Around Time), WT(Waiting Time).

Create a structure of process containing all necessary fields like AT (Arrival Time), BT(Burst Time), CT(Completion Time), TAT(Turn Around Time), WT(Waiting Time). Step-2: Sort according to the AT;

Sort according to the AT; Step-3: Find the process having Largest Burst Time and execute for each single unit. Increase the total time by 1 and reduce the Burst Time of that process with 1.

Find the process having Largest Burst Time and execute for each single unit. Increase the total time by 1 and reduce the Burst Time of that process with 1. Step-4: When any process have 0 BT left, then update the CT(Completion Time of that process CT will be Total Time at that time).

When any process have 0 BT left, then update the CT(Completion Time of that process CT will be Total Time at that time). Step-2: After calculating the CT for each process, find TAT and WT. (TAT = CT - AT) (WT = TAT - BT)

Implementation of Algorithm –



C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; struct process { int processno; int AT; int BT; int BTbackup; int WT; int TAT; int CT; }; struct process p[4]; int totaltime = 0; int prefinaltotal = 0; bool compare(process p1, process p2) { return p1.AT < p2.AT; } int findlargest( int at) { int max = 0, i; for (i = 0; i < 4; i++) { if (p[i].AT <= at) { if (p[i].BT > p[max].BT) max = i; } } return max; } int findCT() { int index; int flag = 0; int i = p[0].AT; while (1) { if (i <= 4) { index = findlargest(i); } else index = findlargest(4); cout << ""Process executing at time "" << totaltime << "" is: P"" << index + 1 << ""\t"" ; p[index].BT -= 1; totaltime += 1; i++; if (p[index].BT == 0) { p[index].CT = totaltime; cout << "" Process P"" << p[index].processno << "" is completed at "" << totaltime; } cout << endl; if (totaltime == prefinaltotal) break ; } } int main() { int i; for (i = 0; i < 4; i++) { p[i].processno = i + 1; } for (i = 0; i < 4; i++) { p[i].AT = i + 1; } for (i = 0; i < 4; i++) { p[i].BT = 2 * (i + 1); p[i].BTbackup = p[i].BT; prefinaltotal += p[i].BT; } cout << ""PNo\tAT\tBT

"" ; for (i = 0; i < 4; i++) { cout << p[i].processno << ""\t"" ; cout << p[i].AT << ""\t"" ; cout << p[i].BT << ""\t"" ; cout << endl; } cout << endl; sort(p, p + 4, compare); totaltime += p[0].AT; prefinaltotal += p[0].AT; findCT(); int totalWT = 0; int totalTAT = 0; for (i = 0; i < 4; i++) { p[i].TAT = p[i].CT - p[i].AT; p[i].WT = p[i].TAT - p[i].BTbackup; totalWT += p[i].WT; totalTAT += p[i].TAT; } cout << ""After execution of all processes ...

"" ; cout << ""PNo\tAT\tBT\tCT\tTAT\tWT

"" ; for (i = 0; i < 4; i++) { cout << p[i].processno << ""\t"" ; cout << p[i].AT << ""\t"" ; cout << p[i].BTbackup << ""\t"" ; cout << p[i].CT << ""\t"" ; cout << p[i].TAT << ""\t"" ; cout << p[i].WT << ""\t"" ; cout << endl; } cout << endl; cout << ""Total TAT = "" << totalTAT << endl; cout << ""Average TAT = "" << totalTAT / 4.0 << endl; cout << ""Total WT = "" << totalWT << endl; cout << ""Average WT = "" << totalWT / 4.0 << endl; return 0; } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code p = [] for i in range ( 4 ): p.append([ 0 , 0 , 0 , 0 , 0 , 0 , 0 ]) totaltime = 0 prefinaltotal = 0 def findlargest(at): max = 0 for i in range ( 4 ): if (p[i][ 1 ] < = at): if (p[i][ 2 ] > p[ max ][ 2 ]) : max = i return max def findCT(totaltime): index = 0 flag = 0 i = p[ 0 ][ 1 ] while ( 1 ): if (i < = 4 ): index = findlargest(i) else : index = findlargest( 4 ) print ( ""Process execute at time "" , totaltime, end = "" "" ) print ( "" is: P"" , index + 1 , sep = "" "", end = "" "") p[index][ 2 ] - = 1 totaltime + = 1 i + = 1 if (p[index][ 2 ] = = 0 ): p[index][ 6 ] = totaltime print ( ""Process P"" , p[index][ 0 ], sep = "" "", end = "" "") print ( "" is completed at "" , totaltime, end = "" "" ) print () if (totaltime = = prefinaltotal): break if __name__ = = ""__main__"" : for i in range ( 4 ): p[i][ 0 ] = i + 1 for i in range ( 4 ): p[i][ 1 ] = i + 1 for i in range ( 4 ): p[i][ 2 ] = 2 * (i + 1 ) p[i][ 3 ] = p[i][ 2 ] prefinaltotal + = p[i][ 2 ] print ( ""PNo\tAT\tBT"" ) for i in range ( 4 ): print (p[i][ 0 ], ""\t"" , p[i][ 1 ], ""\t"" , p[i][ 2 ]) print () p = sorted (p, key = lambda p:p[ 1 ]) totaltime + = p[ 0 ][ 1 ] prefinaltotal + = p[ 0 ][ 1 ] findCT(totaltime) totalWT = 0 totalTAT = 0 for i in range ( 4 ): p[i][ 5 ] = p[i][ 6 ] - p[i][ 1 ] p[i][ 4 ] = p[i][ 5 ] - p[i][ 3 ] totalWT + = p[i][ 4 ] totalTAT + = p[i][ 5 ] print ( ""

After execution of all processes ... "" ) print ( ""PNo\tAT\tBT\tCT\tTAT\tWT"" ) for i in range ( 4 ): print (p[i][ 0 ], ""\t"" , p[i][ 1 ], ""\t"" , p[i][ 3 ], ""\t"" , end = "" "" ) print (p[i][ 6 ], ""\t"" , p[i][ 5 ], ""\t"" , p[i][ 4 ]) print () print ( ""Total TAT = "" , totalTAT) print ( ""Average TAT = "" , totalTAT / 4.0 ) print ( ""Total WT = "" , totalWT) print ( ""Average WT = "" , totalWT / 4.0 ) chevron_right filter_none

Output:

PNo AT BT 1 1 2 2 2 4 3 3 6 4 4 8 Process executing at time 1 is: P1 Process executing at time 2 is: P2 Process executing at time 3 is: P3 Process executing at time 4 is: P4 Process executing at time 5 is: P4 Process executing at time 6 is: P4 Process executing at time 7 is: P3 Process executing at time 8 is: P4 Process executing at time 9 is: P3 Process executing at time 10 is: P4 Process executing at time 11 is: P2 Process executing at time 12 is: P3 Process executing at time 13 is: P4 Process executing at time 14 is: P2 Process executing at time 15 is: P3 Process executing at time 16 is: P4 Process executing at time 17 is: P1 Process P1 is completed at 18 Process executing at time 18 is: P2 Process P2 is completed at 19 Process executing at time 19 is: P3 Process P3 is completed at 20 Process executing at time 20 is: P4 Process P4 is completed at 21 After execution of all processes ... PNo AT BT CT TAT WT 1 1 2 18 17 15 2 2 4 19 17 13 3 3 6 20 17 11 4 4 8 21 17 9 Total TAT = 68 Average TAT = 17 Total WT = 48 Average WT = 12

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : SHUBHAMSINGH10"
34,"Prerequisite – Process Management | CPU Scheduling

This is a pre-emptive version of Longest Job First (LJF) scheduling algorithm. In this scheduling algorithm, we find the process with the maximum remaining time and then process it. We check for the maximum remaining time after some interval of time(say 1 unit each) to check if another process having more Burst Time arrived up to that time.

Procedure:

Step-1: First, sort the processes in increasing order of their Arrival Time.

First, sort the processes in increasing order of their Arrival Time. Step-2: Choose the process having least arrival time but with most Burst Time. Then process it for 1 unit. Check if any other process arrives upto that time of execution or not.

Choose the process having least arrival time but with most Burst Time. Then process it for 1 unit. Check if any other process arrives upto that time of execution or not. Step-3: Repeat the above both steps until execute all the processes.

Example-1: Consider the following table of arrival time and burst time for four processes P1, P2, P3 and P4.

Process Arrival time Burst Time P1 1 ms 2 ms P2 2 ms 4 ms P3 3 ms 6 ms P4 4 ms 8 ms

Working: (for input 1):

At t = 1, Available Process : P1. So, select P1 and execute 1 ms. At t = 2, Available Process : P1, P2. So, select P2 and execute 1 ms (since BT(P1)=1 which is less than BT(P2) = 4) At t = 3, Available Process : P1, P2, P3. So, select P3 and execute 1 ms (since, BT(P1) = 1 , BT(P2) = 3 , BT(P3) = 6). Repeat the above steps until the execution of all processes.

Note that CPU will be idle for 0 to 1 unit time since there is no process available in the given interval.

Gantt chart will be as following below,

Since, complietion time (CT) can be directly determined by Gantt chart, and

Turn Around Time (TAT) = (Complition Time) - (Arival Time) Also, Waiting Time (WT) = (Turn Around Time) - (Burst Time)

Therefore, final table look like,

Output:

Total Turn Around Time = 68 ms So, Average Turn Around Time = 68/4 = 17.00 ms And, Total Waiting Time = 48 ms So Average Waiting Time = 48/4 = 12.00 ms

Example-2: Consider the following table of arrival time and burst time for four processes P1, P2, P3,P4 and P5.

Process Arrival time Burst Time P1 0 ms 2 ms P2 0 ms 3 ms P3 2 ms 2 ms P4 3 ms 5 ms P5 4 ms 4 ms

Similarly example-1, Gantt chart for this example,

Since, complietion time (CT) can be directly determined by Gantt chart, and

Turn Around Time (TAT) = (Complition Time) - (Arival Time) Also, Waiting Time (WT) = (Turn Around Time) - (Burst Time)

Therefore, final table look like,

Output:

Total Turn Around Time = 61 ms So, Average Turn Around Time = 61/5 = 12.20 ms And, Total Waiting Time = 45 ms So, Average Waiting Time = 45/5 = 9.00 ms

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
35,"Round Robin is a CPU scheduling algorithm where each process is assigned a fixed time slot in a cyclic way.

It is simple, easy to implement, and starvation-free as all processes get fair share of CPU.

One of the most commonly used technique in CPU scheduling as a core.

It is preemptive as processes are assigned CPU only for a fixed slice of time at most.

The disadvantage of it is more overhead of context switching.

SERIAL NO. ADVANTAGES DISADVANTAGES 1. There is fairness since every process gets equal share of CPU. There is Larger waiting time and Response time. 2. The newly created process is added to end of ready queue. There is Low throughput. 3. A round-robin scheduler generally employs time-sharing, giving each job a time slot or quantum. There is Context Switches. 4. While performing a round-robin scheduling,a particular time quantum is alloted to different jobs. Gantt chart seems to come too big (if quantum time is less for scheduling.For Example:1 ms for big scheduling.) 5. Each process get a chance to reschedule after a particular quantum time in this scheduling. Time consuming scheduling for small quantums .

Illustration:



How to compute below times in Round Robin using a program?

Completion Time: Time at which process completes its execution. Turn Around Time: Time Difference between completion time and arrival time. Turn Around Time = Completion Time – Arrival Time Waiting Time(W.T): Time Difference between turn around time and burst time.

Waiting Time = Turn Around Time – Burst Time

In this post, we have assumed arrival times as 0, so turn around and completion times are same.

The tricky part is to compute waiting times. Once waiting times are computed, turn around times can be quickly computed.

Steps to find waiting times of all processes:

1- Create an array rem_bt[] to keep track of remaining burst time of processes. This array is initially a copy of bt[] (burst times array) 2- Create another array wt[] to store waiting times of processes. Initialize this array as 0. 3- Initialize time : t = 0 4- Keep traversing the all processes while all processes are not done. Do following for i'th process if it is not done yet. a- If rem_bt[i] > quantum (i) t = t + quantum (ii) bt_rem[i] -= quantum; c- Else // Last cycle for this process (i) t = t + bt_rem[i]; (ii) wt[i] = t - bt[i] (ii) bt_rem[i] = 0; // This process is over

Once we have waiting times, we can compute turn around time tat[i] of a process as sum of waiting and burst times, i.e., wt[i] + bt[i]

Below is implementation of above steps.

C/C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> using namespace std; void findWaitingTime( int processes[], int n, int bt[], int wt[], int quantum) { int rem_bt[n]; for ( int i = 0 ; i < n ; i++) rem_bt[i] = bt[i]; int t = 0; while (1) { bool done = true ; for ( int i = 0 ; i < n; i++) { if (rem_bt[i] > 0) { done = false ; if (rem_bt[i] > quantum) { t += quantum; rem_bt[i] -= quantum; } else { t = t + rem_bt[i]; wt[i] = t - bt[i]; rem_bt[i] = 0; } } } if (done == true ) break ; } } void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } void findavgTime( int processes[], int n, int bt[], int quantum) { int wt[n], tat[n], total_wt = 0, total_tat = 0; findWaitingTime(processes, n, bt, wt, quantum); findTurnAroundTime(processes, n, bt, wt, tat); cout << ""Processes "" << "" Burst time "" << "" Waiting time "" << "" Turn around time

"" ; for ( int i=0; i<n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; cout << "" "" << i+1 << ""\t\t"" << bt[i] << ""\t "" << wt[i] << ""\t\t "" << tat[i] <<endl; } cout << ""Average waiting time = "" << ( float )total_wt / ( float )n; cout << ""

Average turn around time = "" << ( float )total_tat / ( float )n; } int main() { int processes[] = { 1, 2, 3}; int n = sizeof processes / sizeof processes[0]; int burst_time[] = {10, 5, 8}; int quantum = 2; findavgTime(processes, n, burst_time, quantum); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code public class GFG { static void findWaitingTime( int processes[], int n, int bt[], int wt[], int quantum) { int rem_bt[] = new int [n]; for ( int i = 0 ; i < n ; i++) rem_bt[i] = bt[i]; int t = 0 ; while ( true ) { boolean done = true ; for ( int i = 0 ; i < n; i++) { if (rem_bt[i] > 0 ) { done = false ; if (rem_bt[i] > quantum) { t += quantum; rem_bt[i] -= quantum; } else { t = t + rem_bt[i]; wt[i] = t - bt[i]; rem_bt[i] = 0 ; } } } if (done == true ) break ; } } static void findTurnAroundTime( int processes[], int n, int bt[], int wt[], int tat[]) { for ( int i = 0 ; i < n ; i++) tat[i] = bt[i] + wt[i]; } static void findavgTime( int processes[], int n, int bt[], int quantum) { int wt[] = new int [n], tat[] = new int [n]; int total_wt = 0 , total_tat = 0 ; findWaitingTime(processes, n, bt, wt, quantum); findTurnAroundTime(processes, n, bt, wt, tat); System.out.println( ""Processes "" + "" Burst time "" + "" Waiting time "" + "" Turn around time"" ); for ( int i= 0 ; i<n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; System.out.println( "" "" + (i+ 1 ) + ""\t\t"" + bt[i] + ""\t "" + wt[i] + ""\t\t "" + tat[i]); } System.out.println( ""Average waiting time = "" + ( float )total_wt / ( float )n); System.out.println( ""Average turn around time = "" + ( float )total_tat / ( float )n); } public static void main(String[] args) { int processes[] = { 1 , 2 , 3 }; int n = processes.length; int burst_time[] = { 10 , 5 , 8 }; int quantum = 2 ; findavgTime(processes, n, burst_time, quantum); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def findWaitingTime(processes, n, bt, wt, quantum): rem_bt = [ 0 ] * n for i in range (n): rem_bt[i] = bt[i] t = 0 while ( 1 ): done = True for i in range (n): if (rem_bt[i] > 0 ) : done = False if (rem_bt[i] > quantum) : t + = quantum rem_bt[i] - = quantum else : t = t + rem_bt[i] wt[i] = t - bt[i] rem_bt[i] = 0 if (done = = True ): break def findTurnAroundTime(processes, n, bt, wt, tat): for i in range (n): tat[i] = bt[i] + wt[i] def findavgTime(processes, n, bt, quantum): wt = [ 0 ] * n tat = [ 0 ] * n findWaitingTime(processes, n, bt, wt, quantum) findTurnAroundTime(processes, n, bt, wt, tat) print ( ""Processes Burst Time Waiting"" , ""Time Turn-Around Time"" ) total_wt = 0 total_tat = 0 for i in range (n): total_wt = total_wt + wt[i] total_tat = total_tat + tat[i] print ( "" "" , i + 1 , ""\t\t"" , bt[i], ""\t\t"" , wt[i], ""\t\t"" , tat[i]) print ( ""

Average waiting time = %.5f "" % (total_wt / n) ) print ( ""Average turn around time = %.5f "" % (total_tat / n)) if __name__ = = ""__main__"" : proc = [ 1 , 2 , 3 ] n = 3 burst_time = [ 10 , 5 , 8 ] quantum = 2 ; findavgTime(proc, n, burst_time, quantum) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; public class GFG { static void findWaitingTime( int []processes, int n, int []bt, int []wt, int quantum) { int []rem_bt = new int [n]; for ( int i = 0 ; i < n ; i++) rem_bt[i] = bt[i]; int t = 0; while ( true ) { bool done = true ; for ( int i = 0 ; i < n; i++) { if (rem_bt[i] > 0) { done = false ; if (rem_bt[i] > quantum) { t += quantum; rem_bt[i] -= quantum; } else { t = t + rem_bt[i]; wt[i] = t - bt[i]; rem_bt[i] = 0; } } } if (done == true ) break ; } } static void findTurnAroundTime( int []processes, int n, int []bt, int []wt, int []tat) { for ( int i = 0; i < n ; i++) tat[i] = bt[i] + wt[i]; } static void findavgTime( int []processes, int n, int []bt, int quantum) { int []wt = new int [n]; int []tat = new int [n]; int total_wt = 0, total_tat = 0; findWaitingTime(processes, n, bt, wt, quantum); findTurnAroundTime(processes, n, bt, wt, tat); Console.WriteLine( ""Processes "" + "" Burst time "" + "" Waiting time "" + "" Turn around time"" ); for ( int i = 0; i < n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; Console.WriteLine( "" "" + (i+1) + ""\t\t"" + bt[i] + ""\t "" + wt[i] + ""\t\t "" + tat[i]); } Console.WriteLine( ""Average waiting time = "" + ( float )total_wt / ( float )n); Console.Write( ""Average turn around time = "" + ( float )total_tat / ( float )n); } public static void Main() { int []processes = { 1, 2, 3}; int n = processes.Length; int []burst_time = {10, 5, 8}; int quantum = 2; findavgTime(processes, n, burst_time, quantum); } } chevron_right filter_none

Processes Burst time Waiting time Turn around time 1 10 13 23 2 5 10 15 3 8 13 21 Average waiting time = 12 Average turn around time = 19.6667

This article is contributed by Sahil Chhabra. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
36,"Prerequisite – Program for Round Robin scheduling

In the traditional Round Robin scheduling algorithm all processes were treated equally for processing. The objective of the Selfish Round Robin is to give better service to processes that have been executing for a while than to newcomers. Its a more logical and superior implementation compared to the normal Round Robin algorithm.



Implimentation :-

Processes in the ready list are partitioned into two lists: NEW and ACCEPTED.

The New processes wait while Accepted processes are serviced by the Round Robin.

Priority of a new process increases at rate ‘a’ while the priority of an accepted process increases at rate ‘b’.

When the priority of a new process reaches the priority of an accepted process, that new process becomes accepted.

If all accepted processes finish, the highest priority new process is accepted.

Let’s trace out the general working of this algorithm :-

STEP 1 : Assume that initially there are no ready processes, when the first one, A, arrives. It has priority 0 to begin with. Since there are no other accepted processes, A is accepted immediately.

STEP 2 : After a while another process, B, arrives. As long as b / a < 1, B’s priority will eventually catch up to A’s, so it is accepted; now both A and B have the same priority.

STEP 3 : All accepted processes share a common priority (which rises at rate b ); that makes this policy easy to implement i.e any new process’s priority is bound to get accepted at some point. So no process has to experience starvation.

STEP 4 : Even if b / a > 1, A will eventually finish, and then B can be accepted.

Adjusting the parameters a and b : -> If b / a >= 1, a new process is not accepted until all the accepted processes have finished, so SRR becomes FCFS. -> If b / a = 0, all processes are accepted immediately, so SRR becomes RR. -> If 0 < b / a < 1, accepted processes are selfish, but not completely.

Example on Selfish Round Robin –



Solution (where a = 2 and b = 1) –

Explanation –

Process A gets accepted as soon as it comes at time t = 0. So its priority is increased only by ‘b’ i.e ‘1’ after each second. B enters at time t = 1 and goes to the waiting queue. So its priority gets increased by ‘a’ i.e. ‘2’ at time t = 2. At this point priority of A = priority of B = 2.

So now both process A & B are in the accepted queue and are executed in a round robin fashion. At time t = 3 process C enters the waiting queue. At time t = 6 the priority of process C catches up to the priority of process B and then they start executing in a Round Robin manner. When B finishes execution at time t = 10, D is automatically promoted to the accepted queue.

Similarly when D finishes execution at time t = 15, E is automatically promoted to the accepted queue.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Siddhant-Bajaj Interested in everything CS/IT Aspire with my Acer Aspire R11 to crack GATE2019 Avid Follower of Ravindrababu Ravula Trying my best to keep right up my alley with competitive coding Open Source and Web Development Projects I am somewhat good at Chess and spend loads of time on geeksforgeeks"
37,"Prerequisite: Round Robin Scheduling with arrival time as 0

Round robin scheduling algorithm is used to schedule process fairly each job a time slot or quantum and the interrupting the job if it is not completed by then the job come after the other job which is arrived in the quantum time that makes these scheduling fairly

Note:

Round robin is cyclic in nature so starvation doesn’t occur

Round robin is a variant of first come, first served scheduling

No priority, special importance given to any process or task

RR scheduling is also known as Time slicing scheduling

Advantages:

Each process is served by CPU for a fixed time so priority is the same for each one

Starvation does not occur because of its cyclic nature.

Disadvantages:

Throughput depends on quantum time.

If we want to give some process priority, we cannot.

Process Arrival Time Burst Time Completion time Turn Around Time Waiting time P1 0 5 12 12 9 P2 1 4 11 10 6 P3 2 2 6 4 2 P4 3 1 7 4 3

Quantum time is 2 this means each process is only executing for 2 units of time at a time.

How to compute these process requests:-

Take the process which occurs first and start executing the process.(for quantum time only) Check if any other process request has arrived. If a process request arrives during the quantum time in which another process is executing, then add the new process to the Ready queue After the quantum time has passed, check for any processes in the Ready queue. If the ready queue is empty continue the current process. If the queue not empty and the current process is not complete, then add the current process to the end of the ready queue. Take the first process from the Ready queue and start executing it (same rules) Repeat all steps above from 2-5 If the process is complete and the ready queue is empty then the task is complete

After all these we get the three times which are:

Completion Time: the time taken for a process to complete. Turn Around Time: total time the process exists in the system. (completion time – arrival time). Waiting Time: total time the waiting for there complete execution. (turn around time – burst time ).

How to implement in a programming language

1. Create two arrays of burst time res_b[] and of arrival time res_a[] and copy the value of the b[] and a[] array for calculate the remaining time.(b[] is burst time, a[] arrival time). 2. Create an another array for wt[] to store waiting time. 3. Initialize Time : t=0; 4. Keep traversing the all process while all process are not done. Do following for i'th process if it is not done yet. a- if res_a[i]<= q (quantum time :- q) 1. if res_b[i]>q a. t=t+q b. res_b[i]-=q; c. a[i]+=q; 2. else res_b[i]<=q(for last to execute) a. t=t+b[i]; b. wt[i]=t-b[i]-a[i]; c.res_b[i]=0; b- else res_a[i]<q 1. Initialize j=0 to number of process if a[j]<a[i] (compare is there any other process come before these process) 1. if res_b[j]>q a. t=t+q b. res_b[j]-=q; c. a[j]+=q; 2. else res_b[j]<=q a. t=t+b[j]; b. wt[j]=t-b[j]-a[j]; c.res_b[j]=0; 2. now we executing the i'th process 1. if res_b[i]>q a. t=t+q b. res_b[i]-=q; c. a[i]+=q; 2. else res_b[i]<=q a. t=t+b[i]; b. wt[i]=t-b[i]-a[i]; c.res_b[i]=0;

Below is the implementation of the above approach:



C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> #include<iomanip> using namespace std; void CalcWaitingTime( int process[], int wt_time[], int n, int burst_time[], int quantum, int completion_time[], int arrival_time[]) { int rem_time[n]; for ( int i = 0; i < n; i++) rem_time[i] = burst_time[i]; int t = 0; int arrival = 0; while ( true ) { bool done = true ; for ( int i = 0; i < n; i++) { if (rem_time[i] > 0) { done = false ; if (rem_time[i] > quantum && arrival_time[i] <= arrival) { t += quantum; rem_time[i] -= quantum; arrival++; } else { if (arrival_time[i] <= arrival) { arrival++; t += rem_time[i]; rem_time[i] = 0; completion_time[i] = t; } } } } if (done== true ) break ; } } void CalcTurnAroundTime( int process[], int wt_time[], int n, int burst_time[], int tat_time[], int completion_time[], int arrival_time[]) { for ( int i = 0; i < n; i++) { tat_time[i] = completion_time[i] - arrival_time[i]; wt_time[i] = tat_time[i] - burst_time[i]; } } void CalcAvgTime( int process[], int n, int burst_time[], int quantum, int arrival_time[]) { int wt_time[n]; int tat_time[n]; int completion_time[n]; int total_wt = 0, total_tat = 0; CalcWaitingTime(process, wt_time, n, burst_time, quantum, completion_time, arrival_time); CalcTurnAroundTime(process, wt_time, n, burst_time, tat_time, completion_time, arrival_time); cout << setw(9) << ""PROCESS"" << setw(14) << ""ARRIVAL TIME"" << setw(12) << ""BURST TIME"" << setw(17) << ""COMPLETION TIME"" << setw(18) << ""TURN AROUND TIME"" << setw(16) << ""WAITING TIME

"" ; for ( int i = 0; i < n; i++) { total_wt = total_wt + wt_time[i]; total_tat = total_tat + tat_time[i]; cout << setw(6) << i + 1 << setw(11) << arrival_time[i] << setw(12) << burst_time[i] << setw(17) << completion_time[i] << setw(15) << tat_time[i] << setw(16) << wt_time[i] << endl; } cout << ""

AVERAGE WAITING TIME : "" << ( float )total_wt / ( float )n; cout << ""

AVERAGE TURN AROUND TIME : "" << ( float )total_tat / ( float )n; } int main() { int quantum = 2; int arrival_time[] = {0,1,2,3}; int process[] = {1,2,3,4}; int burst_time[] = {5,4,2,1}; int n = sizeof process / sizeof process[0]; CalcAvgTime(process, n, burst_time, quantum, arrival_time); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; public class RoundRobin { public static void findWaitingTime( int process[], int wt_time[], int n , int brusttime[], int quantum, int completion_time[], int arrival_time[]){ int rem_time[] = new int [n]; for ( int i= 0 ;i<wt_time.length;i++){ rem_time[i]= brusttime[i]; } int t= 0 ; int arrival= 0 ; while ( true ){ boolean done = true ; for ( int i= 0 ;i<n;i++){ if (rem_time[i]> 0 ){ done = false ; if (rem_time[i]>quantum && arrival_time[i]<=arrival){ t +=quantum; rem_time[i]-=quantum; arrival++; } else { if (arrival_time[i]<=arrival){ arrival++; t+=rem_time[i]; rem_time[i]= 0 ; completion_time[i]=t; } } } } if (done== true ) { break ; } } } public static void findTurnAroundTime( int process[] , int wt_time[], int n, int brusttime[], int tat_time[], int completion_time[], int arrival_time[]){ for ( int i= 0 ;i<n;i++){ tat_time[i]= completion_time[i]-arrival_time[i]; wt_time[i] = tat_time[i]-brusttime[i]; } } public static void findAvgTime( int process[], int n, int brusttime[], int quantum, int arrival_time[]){ int wt_time[] = new int [n]; int tat_time[] = new int [n]; int completion_time[] = new int [n]; findWaitingTime(process,wt_time,n,brusttime,quantum,completion_time,arrival_time); findTurnAroundTime(process,wt_time,n,brusttime,tat_time,completion_time,arrival_time); int total_wt = 0 , total_tat = 0 ; System.out.println( ""Processes "" + "" Arrival Time\t"" + "" Burst time "" + "" completion time"" + "" Turn Around Time "" + "" Waiting time"" ); for ( int i= 0 ; i<n; i++) { total_wt = total_wt + wt_time[i]; total_tat = total_tat + tat_time[i]; System.out.println( "" "" + (i+ 1 ) + ""\t\t"" + arrival_time[i]+ ""\t\t"" + + brusttime[i] + ""\t "" +completion_time[i]+ ""\t\t"" +tat_time[i] + ""\t\t "" + wt_time[i]); } System.out.println( ""Average waiting time = "" + ( float )total_wt / ( float )n); System.out.println( ""Average turn around time = "" + ( float )total_tat / ( float )n); } public static void main(String []agrs){ RoundRobin object = new RoundRobin(); Scanner scan = new Scanner(System.in); int quantum = 2 ; int arrival_time[] = new int []{ 0 , 1 , 2 , 3 }; int process[] = new int []{ 1 , 2 , 3 , 4 }; int brusttime[] = new int []{ 5 , 4 , 2 , 1 }; int n = process.length; findAvgTime(process,n,brusttime,quantum,arrival_time); scan.close(); } } chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; class GFG { public static void roundRobin(String []p, int []a, int []b, int n) { int res = 0; int resc = 0; String seq = """" ; int []res_b = new int [b.Length]; int []res_a = new int [a.Length]; for ( int i = 0; i < res_b.Length; i++) { res_b[i] = b[i]; res_a[i] = a[i]; } int t = 0; int []w = new int [p.Length]; int []comp = new int [p.Length]; while ( true ) { Boolean flag = true ; for ( int i = 0; i < p.Length; i++) { if (res_a[i] <= t) { if (res_a[i] <= n) { if (res_b[i] > 0) { flag = false ; if (res_b[i] > n) { t = t + n; res_b[i] = res_b[i] - n; res_a[i] = res_a[i] + n; seq += ""->"" + p[i]; } else { t = t + res_b[i]; comp[i] = t - a[i]; w[i] = t - b[i] - a[i]; res_b[i] = 0; seq += ""->"" + p[i]; } } } else if (res_a[i] > n) { for ( int j = 0; j < p.Length; j++) { if (res_a[j] < res_a[i]) { if (res_b[j] > 0) { flag = false ; if (res_b[j] > n) { t = t + n; res_b[j] = res_b[j] - n; res_a[j] = res_a[j] + n; seq += ""->"" + p[j]; } else { t = t + res_b[j]; comp[j] = t - a[j]; w[j] = t - b[j] - a[j]; res_b[j] = 0; seq += ""->"" + p[j]; } } } } if (res_b[i] > 0) { flag = false ; if (res_b[i] > n) { t = t + n; res_b[i] = res_b[i] - n; res_a[i] = res_a[i] + n; seq += ""->"" + p[i]; } else { t = t + res_b[i]; comp[i] = t - a[i]; w[i] = t - b[i] - a[i]; res_b[i] = 0; seq += ""->"" + p[i]; } } } } else if (res_a[i] > t) { t++; i--; } } if (flag) { break ; } } Console.WriteLine( ""name ctime wtime"" ); for ( int i = 0; i < p.Length; i++) { Console.WriteLine( "" "" + p[i] + ""\t"" + comp[i] + ""\t"" + w[i]); res = res + w[i]; resc = resc + comp[i]; } Console.WriteLine( ""Average waiting time is "" + ( float )res / p.Length); Console.WriteLine( ""Average compilation time is "" + ( float )resc / p.Length); Console.WriteLine( ""Sequence is like that "" + seq); } public static void Main(String []args) { String []name = { ""p1"" , ""p2"" , ""p3"" , ""p4"" }; int []arrivaltime = { 0, 1, 2, 3 }; int []bursttime = { 10, 4, 5, 3 }; int q = 3; roundRobin(name, arrivaltime, bursttime, q); } } chevron_right filter_none

Output Processes Arrival Time Burst time completion time Turn Around Time Waiting time 1 0 5 12 12 7 2 1 4 11 10 6 3 2 2 6 4 2 4 3 1 7 4 3 Average waiting time = 4.5 Average turn around time = 7.5

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Abhisheksharmaabhi My name is Abhishek i am currenty persuing the BE from Cgc LangranMohalli"
38,"Priority scheduling is one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with the highest priority is to be executed first and so on.

Processes with the same priority are executed on first come first served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement.

Implementation :

1- First input the processes with their burst time and priority. 2- Sort the processes, burst time and priority according to the priority. 3- Now simply apply FCFS algorithm.

Note: A major problem with priority scheduling is indefinite blocking or starvation. A solution to the problem of indefinite blockage of the low-priority process is aging. Aging is a technique of gradually increasing the priority of processes that wait in the system for a long period of time.

C++ filter_none edit

close play_arrow link

brightness_4

code #include<bits/stdc++.h> using namespace std; struct Process { int pid; int bt; int priority; }; bool comparison(Process a, Process b) { return (a.priority > b.priority); } void findWaitingTime(Process proc[], int n, int wt[]) { wt[0] = 0; for ( int i = 1; i < n ; i++ ) wt[i] = proc[i-1].bt + wt[i-1] ; } void findTurnAroundTime( Process proc[], int n, int wt[], int tat[]) { for ( int i = 0; i < n ; i++) tat[i] = proc[i].bt + wt[i]; } void findavgTime(Process proc[], int n) { int wt[n], tat[n], total_wt = 0, total_tat = 0; findWaitingTime(proc, n, wt); findTurnAroundTime(proc, n, wt, tat); cout << ""

Processes "" << "" Burst time "" << "" Waiting time "" << "" Turn around time

"" ; for ( int i=0; i<n; i++) { total_wt = total_wt + wt[i]; total_tat = total_tat + tat[i]; cout << "" "" << proc[i].pid << ""\t\t"" << proc[i].bt << ""\t "" << wt[i] << ""\t\t "" << tat[i] <<endl; } cout << ""

Average waiting time = "" << ( float )total_wt / ( float )n; cout << ""

Average turn around time = "" << ( float )total_tat / ( float )n; } void priorityScheduling(Process proc[], int n) { sort(proc, proc + n, comparison); cout<< ""Order in which processes gets executed

"" ; for ( int i = 0 ; i < n; i++) cout << proc[i].pid << "" "" ; findavgTime(proc, n); } int main() { Process proc[] = {{1, 10, 2}, {2, 5, 0}, {3, 8, 1}}; int n = sizeof proc / sizeof proc[0]; priorityScheduling(proc, n); return 0; } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def findWaitingTime(processes, n, wt): wt[ 0 ] = 0 for i in range ( 1 , n): wt[i] = processes[i - 1 ][ 1 ] + wt[i - 1 ] def findTurnAroundTime(processes, n, wt, tat): for i in range (n): tat[i] = processes[i][ 1 ] + wt[i] def findavgTime(processes, n): wt = [ 0 ] * n tat = [ 0 ] * n findWaitingTime(processes, n, wt) findTurnAroundTime(processes, n, wt, tat) print ( ""

Processes Burst Time Waiting"" , ""Time Turn-Around Time"" ) total_wt = 0 total_tat = 0 for i in range (n): total_wt = total_wt + wt[i] total_tat = total_tat + tat[i] print ( "" "" , processes[i][ 0 ], ""\t\t"" , processes[i][ 1 ], ""\t\t"" , wt[i], ""\t\t"" , tat[i]) print ( ""

Average waiting time = %.5f "" % (total_wt / n)) print ( ""Average turn around time = "" , total_tat / n) def priorityScheduling(proc, n): proc = sorted (proc, key = lambda proc:proc[ 2 ], reverse = True ); print ( ""Order in which processes gets executed"" ) for i in proc: print (i[ 0 ], end = "" "" ) findavgTime(proc, n) if __name__ = = ""__main__"" : proc = [[ 1 , 10 , 1 ], [ 2 , 5 , 0 ], [ 3 , 8 , 1 ]] n = 3 priorityScheduling(proc, n) chevron_right filter_none

Output:

Order in which processes gets executed 1 3 2 Processes Burst time Waiting time Turn around time 1 10 0 10 3 8 10 18 2 5 18 23 Average waiting time = 9.33333 Average turn around time = 17

In this post, the processes with arrival time 0 are discussed. In next set, we will be considering different arrival times to evaluate waiting times.

This article is contributed by Sahil Chhabra (akku). If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : SHUBHAMSINGH10"
39,"Implementing priority CPU scheduling. In this problem, we are using Min Heap as the data structure for implementing priority scheduling.

In this problem smaller numbers denote higher priority.

The following functions are used in the given code below:

struct process { processID, burst time, response time, priority, arrival time. }

void quicksort(process array[], low, high)– This function is used to arrange the processes in ascending order according to their arrival time.

int partition(process array[], int low, int high)– This function is used to partition the array for sorting.

void insert(process Heap[], process value, int *heapsize, int *currentTime)– It is used to include all the valid and eligible processes in the heap for execution. heapsize defines the number of processes in execution depending on the current time currentTime keeps record of the current CPU time.

void order(process Heap[], int *heapsize, int start)– It is used to reorder the heap according to priority if the processes after insertion of new process.

void extractminimum(process Heap[], int *heapsize, int *currentTime)– This function is used to find the process with highest priority from the heap. It also reorders the heap after extracting the highest priority process.

void scheduling(process Heap[], process array[], int n, int *heapsize, int *currentTime)– This function is responsible for executing the highest priority extracted from Heap[].

void process(process array[], int n)– This function is responsible for managing the entire execution of the processes as they arrive in the CPU according to their arrival time.

filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; struct Process { int processID; int burstTime; int tempburstTime; int responsetime; int arrivalTime; int priority; int outtime; int intime; }; void insert(Process Heap[], Process value, int * heapsize, int * currentTime) { int start = *heapsize, i; Heap[*heapsize] = value; if (Heap[*heapsize].intime == -1) Heap[*heapsize].intime = *currentTime; ++(*heapsize); while (start != 0 && Heap[(start - 1) / 2].priority > Heap[start].priority) { Process temp = Heap[(start - 1) / 2]; Heap[(start - 1) / 2] = Heap[start]; Heap[start] = temp; start = (start - 1) / 2; } } void order(Process Heap[], int * heapsize, int start) { int smallest = start; int left = 2 * start + 1; int right = 2 * start + 2; if (left < *heapsize && Heap[left].priority < Heap[smallest].priority) smallest = left; if (right < *heapsize && Heap[right].priority < Heap[smallest].priority) smallest = right; if (smallest != start) { Process temp = Heap[smallest]; Heap[smallest] = Heap[start]; Heap[start] = temp; order(Heap, heapsize, smallest); } } Process extractminimum(Process Heap[], int * heapsize, int * currentTime) { Process min = Heap[0]; if (min.responsetime == -1) min.responsetime = *currentTime - min.arrivalTime; --(*heapsize); if (*heapsize >= 1) { Heap[0] = Heap[*heapsize]; order(Heap, heapsize, 0); } return min; } bool compare(Process p1, Process p2) { return (p1.arrivalTime < p2.arrivalTime); } void scheduling(Process Heap[], Process array[], int n, int * heapsize, int * currentTime) { if (heapsize == 0) return ; Process min = extractminimum(Heap, heapsize, currentTime); min.outtime = *currentTime + 1; --min.burstTime; printf ( ""process id = %d current time = %d

"" , min.processID, *currentTime); if (min.burstTime > 0) { insert(Heap, min, heapsize, currentTime); return ; } for ( int i = 0; i < n; i++) if (array[i].processID == min.processID) { array[i] = min; break ; } } void priority(Process array[], int n) { sort(array, array + n, compare); int totalwaitingtime = 0, totalbursttime = 0, totalturnaroundtime = 0, i, insertedprocess = 0, heapsize = 0, currentTime = array[0].arrivalTime, totalresponsetime = 0; Process Heap[4 * n]; for ( int i = 0; i < n; i++) { totalbursttime += array[i].burstTime; array[i].tempburstTime = array[i].burstTime; } do { if (insertedprocess != n) { for (i = 0; i < n; i++) { if (array[i].arrivalTime == currentTime) { ++insertedprocess; array[i].intime = -1; array[i].responsetime = -1; insert(Heap, array[i], &heapsize, ¤tTime); } } } scheduling(Heap, array, n, &heapsize, ¤tTime); ++currentTime; if (heapsize == 0 && insertedprocess == n) break ; } while (1); for ( int i = 0; i < n; i++) { totalresponsetime += array[i].responsetime; totalwaitingtime += (array[i].outtime - array[i].intime - array[i].tempburstTime); totalbursttime += array[i].burstTime; } printf ( ""Average waiting time = %f

"" , (( float )totalwaitingtime / ( float )n)); printf ( ""Average response time =%f

"" , (( float )totalresponsetime / ( float )n)); printf ( ""Average turn around time = %f

"" , (( float )(totalwaitingtime + totalbursttime) / ( float )n)); } int main() { int n, i; Process a[5]; a[0].processID = 1; a[0].arrivalTime = 4; a[0].priority = 2; a[0].burstTime = 6; a[1].processID = 4; a[1].arrivalTime = 5; a[1].priority = 1; a[1].burstTime = 3; a[2].processID = 2; a[2].arrivalTime = 5; a[2].priority = 3; a[2].burstTime = 1; a[3].processID = 3; a[3].arrivalTime = 1; a[3].priority = 4; a[3].burstTime = 2; a[4].processID = 5; a[4].arrivalTime = 3; a[4].priority = 5; a[4].burstTime = 4; priority(a, 5); return 0; }

chevron_right filter_none

Output: process id = 3 current time = 1 process id = 3 current time = 2 process id = 5 current time = 3 process id = 1 current time = 4 process id = 4 current time = 5 process id = 4 current time = 6 process id = 4 current time = 7 process id = 1 current time = 8 process id = 1 current time = 9 process id = 1 current time = 10 process id = 1 current time = 11 process id = 1 current time = 12 process id = 2 current time = 13 process id = 5 current time = 14 process id = 5 current time = 15 process id = 5 current time = 16 Average waiting time = 4.400000 Average response time =1.600000 Average turn around time = 7.200000

The output displays the order in which the processes are executed in the memory and also shows the average waiting time, average response time and average turn around time for each process.

This article is contributed by Hardik Gaur. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : GitinKakkar"
40,"Prerequisite – Program for Priority Scheduling – Set 1

Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems. Each process is assigned first arrival time (less arrival time process first) if two processes have same arrival time, then compare to priorities (highest process first). Also, if two processes have same priority then compare to process number (less process number first). This process is repeated while all process get executed.

Implementation –

First input the processes with their arrival time, burst time and priority. Sort the processes, according to arrival time if two process arrival time is same then sort according process priority if two process priority are same then sort according to process number. Now simply apply FCFS algorithm.



Gantt Chart –



Examples –

Input : process no-> 1 2 3 4 5 arrival time-> 0 1 3 2 4 burst time-> 3 6 1 2 4 priority-> 3 4 9 7 8 Output : Process_no Start_time Complete_time Trun_Around_Time Wating_Time 1 0 3 3 0 2 3 9 8 2 4 9 11 9 7 3 11 12 9 8 5 12 16 12 8 Average Wating Time is : 5.0 Average Trun Around time is : 8.2

C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; #define totalprocess 5 struct process { int at,bt,pr,pno; }; process proc[50]; bool comp(process a,process b) { if (a.at == b.at) { return a.pr<b.pr; } else { return a.at<b.at; } } void get_wt_time( int wt[]) { int service[50]; service[0] = proc[0].at; wt[0]=0; for ( int i=1;i<totalprocess;i++) { service[i]=proc[i-1].bt+service[i-1]; wt[i]=service[i]-proc[i].at; if (wt[i]<0) { wt[i]=0; } } } void get_tat_time( int tat[], int wt[]) { for ( int i=0;i<totalprocess;i++) { tat[i]=proc[i].bt+wt[i]; } } void findgc() { int wt[50],tat[50]; double wavg=0,tavg=0; get_wt_time(wt); get_tat_time(tat,wt); int stime[50], ctime [50]; stime[0] = proc[0].at; ctime [0]=stime[0]+tat[0]; for ( int i=1;i<totalprocess;i++) { stime[i]= ctime [i-1]; ctime [i]=stime[i]+tat[i]-wt[i]; } cout<< ""Process_no\tStart_time\tComplete_time\tTurn_Around_Time\tWaiting_Time"" <<endl; for ( int i=0;i<totalprocess;i++) { wavg += wt[i]; tavg += tat[i]; cout<<proc[i].pno<< ""\t\t"" << stime[i]<< ""\t\t"" << ctime [i]<< ""\t\t"" << tat[i]<< ""\t\t\t"" <<wt[i]<<endl; } cout<< ""Average waiting time is : "" ; cout<<wavg/( float )totalprocess<<endl; cout<< ""average turnaround time : "" ; cout<<tavg/( float )totalprocess<<endl; } int main() { int arrivaltime[] = { 1, 2, 3, 4, 5 }; int bursttime[] = { 3, 5, 1, 7, 4 }; int priority[] = { 3, 4, 1, 7, 8 }; for ( int i=0;i<totalprocess;i++) { proc[i].at=arrivaltime[i]; proc[i].bt=bursttime[i]; proc[i].pr=priority[i]; proc[i].pno=i+1; } sort(proc,proc+totalprocess,comp); findgc(); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; class Process { int at, bt, pri, pno; Process( int pno, int at, int bt, int pri) { this .pno = pno; this .pri = pri; this .at = at; this .bt = bt; } } class GChart { int pno, stime, ctime, wtime, ttime; } class MyComparator implements Comparator { public int compare(Object o1, Object o2) { Process p1 = (Process)o1; Process p2 = (Process)o2; if (p1.at < p2.at) return (- 1 ); else if (p1.at == p2.at && p1.pri > p2.pri) return (- 1 ); else return ( 1 ); } } class FindGantChart { void findGc(LinkedList queue) { int time = 0 ; TreeSet prique = new TreeSet( new MyComparator()); LinkedList result = new LinkedList(); while (queue.size() > 0 ) prique.add((Process)queue.removeFirst()); Iterator it = prique.iterator(); time = ((Process)prique.first()).at; while (it.hasNext()) { Process obj = (Process)it.next(); GChart gc1 = new GChart(); gc1.pno = obj.pno; gc1.stime = time; time += obj.bt; gc1.ctime = time; gc1.ttime = gc1.ctime - obj.at; gc1.wtime = gc1.ttime - obj.bt; result.add(gc1); } new ResultOutput(result); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code totalprocess = 5 proc = [] for i in range ( 5 ): l = [] for j in range ( 4 ): l.append( 0 ) proc.append(l) def get_wt_time( wt): service = [ 0 ] * 5 service[ 0 ] = 0 wt[ 0 ] = 0 for i in range ( 1 , totalprocess): service[i] = proc[i - 1 ][ 1 ] + service[i - 1 ] wt[i] = service[i] - proc[i][ 0 ] + 1 if (wt[i] < 0 ) : wt[i] = 0 def get_tat_time(tat, wt): for i in range (totalprocess): tat[i] = proc[i][ 1 ] + wt[i] def findgc(): wt = [ 0 ] * 5 tat = [ 0 ] * 5 wavg = 0 tavg = 0 get_wt_time(wt) get_tat_time(tat, wt) stime = [ 0 ] * 5 ctime = [ 0 ] * 5 stime[ 0 ] = 1 ctime[ 0 ] = stime[ 0 ] + tat[ 0 ] for i in range ( 1 , totalprocess): stime[i] = ctime[i - 1 ] ctime[i] = stime[i] + tat[i] - wt[i] print ( ""Process_no\tStart_time\tComplete_time"" , ""\tTurn_Around_Time\tWaiting_Time"" ) for i in range (totalprocess): wavg + = wt[i] tavg + = tat[i] print (proc[i][ 3 ], ""\t\t"" , stime[i], ""\t\t"" , end = "" "" ) print (ctime[i], ""\t\t"" , tat[i], ""\t\t\t"" , wt[i]) print ( ""Average waiting time is : "" , end = "" "" ) print (wavg / totalprocess) print ( ""average turnaround time : "" , end = "" "" ) print (tavg / totalprocess) if __name__ = = ""__main__"" : arrivaltime = [ 1 , 2 , 3 , 4 , 5 ] bursttime = [ 3 , 5 , 1 , 7 , 4 ] priority = [ 3 , 4 , 1 , 7 , 8 ] for i in range (totalprocess): proc[i][ 0 ] = arrivaltime[i] proc[i][ 1 ] = bursttime[i] proc[i][ 2 ] = priority[i] proc[i][ 3 ] = i + 1 proc = sorted (proc, key = lambda x:x[ 2 ]) proc = sorted (proc) findgc() chevron_right filter_none

Process_no Start_time Complete_time Trun_Around_Time Wating_Time 1 1 4 3 0 2 4 9 7 2 3 9 10 7 6 4 10 17 13 6 5 17 21 16 12 Average Wating Time is : 5.2 Average Trun Around time is : 9.2

This article is contributed by Amit Verma . If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important Java and Collections concepts with the Fundamentals of Java and Java Collections Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Cyberfreak, SHUBHAMSINGH10, checkway1087"
41,"Prerequisites : Priority Scheduling

We have already discussed about the priority scheduling in this post. It is one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with the highest priority is to be executed first and so on.

In this post we will discuss a major problem related to priority scheduling and it’s solution.

Starvation or indefinite blocking is phenomenon associated with the Priority scheduling algorithms, in which a process ready to run for CPU can wait indefinitely because of low priority. In heavily loaded computer system, a steady stream of higher-priority processes can prevent a low-priority process from ever getting the CPU.

There has been rumors that in 1967 Priority Scheduling was used in IBM 7094 at MIT , and they found a low-priority process that had not been submitted till 1973.

As we see in the above example process having higher priority than other processes getting CPU earlier. We can think of a scenario in which only one process is having very low-priority (for example 127) and we are giving other process with high-priority, this can lead indefinitely waiting for the process for CPU which is having low-priority, this leads to Starvation. Further we have also discuss about the solution of starvation.

Differences between Deadlock and Starvation in OS :

Deadlock occurs when none of the processes in the set is able to move ahead due to occupancy of the required resources by some other process as shown in the figure below, on the other hand Starvation occurs when a process waits for an indefinite period of time to get the resource it requires. Other name of deadlock is Circular Waiting. Other name of starvation is Lived lock. When deadlock occurs no process can make progress, while in starvation apart from the victim process other processes can progress or proceed.

Solution to Starvation : Aging

Aging is a technique of gradually increasing the priority of processes that wait in the system for a long time.For example, if priority range from 127(low) to 0(high), we could increase the priority of a waiting process by 1 Every 15 minutes. Eventually even a process with an initial priority of 127 would take no more than 32 hours for priority 127 process to age to a priority-0 process.

This article is contributed by Saloni Gupta. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
42,"Prerequisite – CPU Scheduling

Given n processes with their Arrival times and Burst times, the task is to find average waiting time and average turn around time using HRRN scheduling algorithm.

The name itself states that we need to find the response ratio of all available processes and select the one with the highest Response Ratio. A process once selected will run till completion.

Criteria – Response Ratio

Mode – Non-Preemptive

Response Ratio = (W + S)/S

Here, W is the waiting time of the process so far and S is the Burst time of the process.



Performance of HRRN –

Shorter Processes are favoured. Aging without service increases ratio, longer jobs can get past shorter jobs.



Gantt Chart –

Explanation –

At t = 0 we have only one process available, so A gets scheduled.

Similarly at t = 3 we have only one process available, so B gets scheduled.

Now at t = 9 we have 3 processes available, C, D and E. Since, C, D and E were available after 4, 6 and 8 units respectively. Therefore, waiting time for C, D and E are (9 – 4 =)5, (9 – 6 =)3, and (9 – 8 =)1 unit respectively.

Using the formula given above we calculate the Response Ratios of C, D and E respectively as 2.25, 1.6 and 1.5.

Clearly C has the highest Response Ratio and so it gets scheduled

Next at t = 13 we have 2 jobs available D and E.

Response Ratios of D and E are 2.4 and 3.5 respectively.

So process E is selected next and process D is selected last.

Implementation of HRRN Scheduling –

Input the number of processes, their arrival times and burst times. Sort them according to their arrival times. At any given time calculate the response ratios and select the appropriate process to be scheduled. Calculate the turn around time as completion time – arrival time. Calculate the waiting time as turn around time – burst time. Turn around time divided by the burst time gives the normalized turn around time. Sum up the waiting and turn around times of all processes and divide by the number of processes to get the average waiting and turn around time.

Below is the implementation of above approach:

C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; struct process { char name; int at, bt, ct, wt, tt; int completed; float ntt; } p[10]; int n; void sortByArrival() { struct process temp; int i, j; for (i = 0; i < n - 1; i++) { for (j = i + 1; j < n; j++) { if (p[i].at > p[j].at) { temp = p[i]; p[i] = p[j]; p[j] = temp; } } } } int main() { int i, j, t, sum_bt = 0; char c; float avgwt = 0, avgtt = 0; n = 5; int arriv[] = { 0, 2, 4, 6, 8 }; int burst[] = { 3, 6, 4, 5, 2 }; for (i = 0, c = 'A' ; i < n; i++, c++) { p[i].name = c; p[i].at = arriv[i]; p[i].bt = burst[i]; p[i].completed = 0; sum_bt += p[i].bt; } sortByArrival(); cout << ""Name "" << "" Arrival Time "" << "" Burst Time "" << "" Waiting Time "" << "" TurnAround Time "" << "" Normalized TT"" ; for (t = p[0].at; t < sum_bt;) { float hrr = -9999; float temp; int loc; for (i = 0; i < n; i++) { if (p[i].at <= t && p[i].completed != 1) { temp = (p[i].bt + (t - p[i].at)) / p[i].bt; if (hrr < temp) { hrr = temp; loc = i; } } } t += p[loc].bt; p[loc].wt = t - p[loc].at - p[loc].bt; p[loc].tt = t - p[loc].at; avgtt += p[loc].tt; p[loc].ntt = (( float )p[loc].tt / p[loc].bt); p[loc].completed = 1; avgwt += p[loc].wt; cout<< ""

"" << p[loc].name << ""\t"" << p[loc].at; cout << ""\t\t"" << p[loc].bt << ""\t\t"" << p[loc].wt; cout << ""\t\t"" << p[loc].tt << ""\t\t"" << p[loc].ntt; } cout << ""

Average waiting time: "" << avgwt / n << endl; cout << ""Average Turn Around time:"" << avgtt / n; } chevron_right filter_none C filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> struct process { char name; int at, bt, ct, wt, tt; int completed; float ntt; } p[10]; int n; void sortByArrival() { struct process temp; int i, j; for (i = 0; i < n - 1; i++) { for (j = i + 1; j < n; j++) { if (p[i].at > p[j].at) { temp = p[i]; p[i] = p[j]; p[j] = temp; } } } } void main() { int i, j, t, sum_bt = 0; char c; float avgwt = 0, avgtt = 0; n = 5; int arriv[] = { 0, 2, 4, 6, 8 }; int burst[] = { 3, 6, 4, 5, 2 }; for (i = 0, c = 'A' ; i < n; i++, c++) { p[i].name = c; p[i].at = arriv[i]; p[i].bt = burst[i]; p[i].completed = 0; sum_bt += p[i].bt; } sortByArrival(); printf ( ""

Name\tArrival Time\tBurst Time\tWaiting Time"" ); printf ( ""\tTurnAround Time\t Normalized TT"" ); for (t = p[0].at; t < sum_bt;) { float hrr = -9999; float temp; int loc; for (i = 0; i < n; i++) { if (p[i].at <= t && p[i].completed != 1) { temp = (p[i].bt + (t - p[i].at)) / p[i].bt; if (hrr < temp) { hrr = temp; loc = i; } } } t += p[loc].bt; p[loc].wt = t - p[loc].at - p[loc].bt; p[loc].tt = t - p[loc].at; avgtt += p[loc].tt; p[loc].ntt = (( float )p[loc].tt / p[loc].bt); p[loc].completed = 1; avgwt += p[loc].wt; printf ( ""

%c\t\t%d\t\t"" , p[loc].name, p[loc].at); printf ( ""%d\t\t%d\t\t"" , p[loc].bt, p[loc].wt); printf ( ""%d\t\t%f"" , p[loc].tt, p[loc].ntt); } printf ( ""

Average waiting time:%f

"" , avgwt / n); printf ( ""Average Turn Around time:%f

"" , avgtt / n); } chevron_right filter_none

Name Arrival Time Burst Time Waiting Time TurnAround Time Normalized TT A 0 3 0 3 1.000000 B 2 6 1 7 1.166667 C 4 4 5 9 2.250000 E 8 2 5 7 3.500000 D 6 5 9 14 2.800000 Average waiting time:4.000000 Average Turn Around time:8.000000

This article is contributed by Siddhant Bajaj. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Shivi_Aggarwal"
43,"Prerequisite : CPU Scheduling

It may happen that processes in the ready queue can be divided into different classes where each class has its own scheduling needs. For example, a common division is a foreground (interactive) process and background (batch) processes.These two classes have different scheduling needs. For this kind of situation Multilevel Queue Scheduling is used.Now, let us see how it works.

Ready Queue is divided into separate queues for each class of processes. For example, let us take three different types of process System processes, Interactive processes and Batch Processes. All three process have there own queue. Now,look at the below figure.

All three different type of processes have there own queue. Each queue have its own Scheduling algorithm. For example, queue 1 and queue 2 uses Round Robin while queue 3 can use FCFS to schedule there processes.

Scheduling among the queues : What will happen if all the queues have some processes? Which process should get the cpu? To determine this Scheduling among the queues is necessary. There are two ways to do so –

Fixed priority preemptive scheduling method – Each queue has absolute priority over lower priority queue. Let us consider following priority order queue 1 > queue 2 > queue 3.According to this algorithm no process in the batch queue(queue 3) can run unless queue 1 and 2 are empty. If any batch process (queue 3) is running and any system (queue 1) or Interactive process(queue 2) entered the ready queue the batch process is preempted. Time slicing – In this method each queue gets certain portion of CPU time and can use it to schedule its own processes.For instance, queue 1 takes 50 percent of CPU time queue 2 takes 30 percent and queue 3 gets 20 percent of CPU time.

Example Problem :

Consider below table of four processes under Multilevel queue scheduling.Queue number denotes the queue of the process.

Priority of queue 1 is greater than queue 2. queue 1 uses Round Robin (Time Quantum = 2) and queue 2 uses FCFS.

Below is the gantt chart of the problem :

At starting both queues have process so process in queue 1 (P1, P2) runs first (because of higher priority) in the round robin fashion and completes after 7 units then process in queue 2 (P3) starts running (as there is no process in queue 1) but while it is running P4 comes in queue 1 and interrupts P3 and start running for 5 second and after its completion P3 takes the CPU and completes its execution.

Advantages:

The processes are permanently assigned to the queue, so it has advantage of low scheduling overhead.

Disadvantages:

Some processes may starve for CPU if some higher priority queues are never becoming empty.

It is inflexible in nature.

This article is contributed by Ashish Sharma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : itskawal2000"
44,"Prerequisite – CPU Scheduling, Multilevel Queue Scheduling

This Scheduling is like Multilevel Queue(MLQ) Scheduling but in this process can move between the queues. Multilevel Feedback Queue Scheduling (MLFQ) keep analyzing the behavior (time of execution) of processes and according to which it changes its priority.Now, look at the diagram and explanation below to understand it properly.



Now let us suppose that queue 1 and 2 follow round robin with time quantum 4 and 8 respectively and queue 3 follow FCFS.One implementation of MFQS is given below –

When a process starts executing then it first enters queue 1. In queue 1 process executes for 4 unit and if it completes in this 4 unit or it gives CPU for I/O operation in this 4 unit than the priority of this process does not change and if it again comes in the ready queue than it again starts its execution in Queue 1. If a process in queue 1 does not complete in 4 unit then its priority gets reduced and it shifted to queue 2. Above points 2 and 3 are also true for queue 2 processes but the time quantum is 8 unit.In a general case if a process does not complete in a time quantum than it is shifted to the lower priority queue. In the last queue, processes are scheduled in FCFS manner. A process in lower priority queue can only execute only when higher priority queues are empty. A process running in the lower priority queue is interrupted by a process arriving in the higher priority queue.

Well, above implementation may differ for example the last queue can also follow Round-robin Scheduling.

Problems in the above implementation – A process in the lower priority queue can suffer from starvation due to some short processes taking all the CPU time.

Solution – A simple solution can be to boost the priority of all the process after regular intervals and place them all in the highest priority queue.

What is the need of such complex Scheduling?



Firstly, it is more flexible than the multilevel queue scheduling.

To optimize turnaround time algorithms like SJF is needed which require the running time of processes to schedule them. But the running time of the process is not known in advance. MFQS runs a process for a time quantum and then it can change its priority(if it is a long process). Thus it learns from past behavior of the process and then predicts its future behavior.This way it tries to run shorter process first thus optimizing turnaround time.

MFQS also reduces the response time.

Example –

Consider a system which has a CPU bound process, which requires the burst time of 40 seconds.The multilevel Feed Back Queue scheduling algorithm is used and the queue time quantum ‘2’ seconds and in each level it is incremented by ‘5’ seconds.Then how many times the process will be interrupted and on which queue the process will terminate the execution?

Solution –

Process P needs 40 Seconds for total execution.

At Queue 1 it is executed for 2 seconds and then interrupted and shifted to queue 2.

At Queue 2 it is executed for 7 seconds and then interrupted and shifted to queue 3.

At Queue 3 it is executed for 12 seconds and then interrupted and shifted to queue 4.

At Queue 4 it is executed for 17 seconds and then interrupted and shifted to queue 5.

At Queue 5 it executes for 2 seconds and then it completes.

Hence the process is interrupted 4 times and completes on queue 5.

Advantages:

It is more flexible. It allows different processes to move between different queues. It prevents starvation by moving a process that waits too long for lower priority queue to the higher priority queue.

Disadvantages:

For the selection of the best scheduler, it require some other means to select the values. It produces more CPU overheads. It is most complex algorithm.

This article is contributed by Ashish Sharma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : itskawal2000"
45,"Prerequisite – CPU Scheduling, Process Management

Lottery Scheduling is type of process scheduling, somewhat different from other Scheduling. Processes are scheduled in a random manner. Lottery scheduling can be preemptive or non-preemptive. It also solves the problem of starvation. Giving each process at least one lottery ticket guarantees that it has non-zero probability of being selected at each scheduling operation.

In this scheduling every process have some tickets and scheduler picks a random ticket and process having that ticket is the winner and it is executed for a time slice and then another ticket is picked by the scheduler. These tickets represent the share of processes. A process having a higher number of tickets give it more chance to get chosen for execution.

Example – If we have two processes A and B having 60 and 40 tickets respectively out of total 100 tickets. CPU share of A is 60% and that of B is 40%.These shares are calculated probabilistically and not deterministically.

Explanation –

We have two processes A and B. A has 60 tickets (ticket number 1 to 60) and B have 40 tickets (ticket no. 61 to 100). Scheduler picks a random number from 1 to 100. If the picked no. is from 1 to 60 then A is executed otherwise B is executed. An example of 10 tickets picked by Scheduler may look like this – Ticket number - 73 82 23 45 32 87 49 39 12 09. Resulting Schedule - B B A A A B A A A A. A is executed 7 times and B is executed 3 times. As you can see that A takes 70% of CPU and B takes 30% which is not the same as what we need as we need A to have 60% of CPU and B should have 40% of CPU.This happens because shares are calculated probabilistically but in a long run(i.e when no. of tickets picked is more than 100 or 1000) we can achieve a share percentage of approx. 60 and 40 for A and B respectively.

Ways to manipulate tickets –

Ticket Currency –

Scheduler give a certain number of tickets to different users in a currency and users can give it to there processes in a different currency. E.g. Two users A and B are given 100 and 200 tickets respectively. User A is running two process and give 50 tickets to each in A’s own currency. B is running 1 process and gives it all 200 tickets in B’s currency. Now at the time of scheduling tickets of each process are converted into global currency i.e A’s process will have 50 tickets each and B’s process will have 200 tickets and scheduling is done on this basis.

Scheduler give a certain number of tickets to different users in a currency and users can give it to there processes in a different currency. E.g. Two users A and B are given 100 and 200 tickets respectively. User A is running two process and give 50 tickets to each in A’s own currency. B is running 1 process and gives it all 200 tickets in B’s currency. Now at the time of scheduling tickets of each process are converted into global currency i.e A’s process will have 50 tickets each and B’s process will have 200 tickets and scheduling is done on this basis. Transfer Tickets –

A process can pass its tickets to another process.

A process can pass its tickets to another process. Ticket inflation –

With this technique a process can temporarily raise or lower the number of tickets it own.

References –

Lottery scheduling – Wikipedia

eecs.berkeley.edu

This article is contributed by Ashish Sharma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : dk619"
46,"In multiple-processor scheduling multiple CPU’s are available and hence Load Sharing becomes possible. However multiple processor scheduling is more complex as compared to single processor scheduling. In multiple processor scheduling there are cases when the processors are identical i.e. HOMOGENEOUS, in terms of their functionality, we can use any processor available to run any process in the queue.

Approaches to Multiple-Processor Scheduling –

One approach is when all the scheduling decisions and I/O processing are handled by a single processor which is called the Master Server and the other processors executes only the user code. This is simple and reduces the need of data sharing. This entire scenario is called Asymmetric Multiprocessing.

A second approach uses Symmetric Multiprocessing where each processor is self scheduling. All processes may be in a common ready queue or each processor may have its own private queue for ready processes. The scheduling proceeds further by having the scheduler for each processor examine the ready queue and select a process to execute.

Processor Affinity –

Processor Affinity means a processes has an affinity for the processor on which it is currently running.

When a process runs on a specific processor there are certain effects on the cache memory. The data most recently accessed by the process populate the cache for the processor and as a result successive memory access by the process are often satisfied in the cache memory. Now if the process migrates to another processor, the contents of the cache memory must be invalidated for the first processor and the cache for the second processor must be repopulated. Because of the high cost of invalidating and repopulating caches, most of the SMP(symmetric multiprocessing) systems try to avoid migration of processes from one processor to another and try to keep a process running on the same processor. This is known as PROCESSOR AFFINITY.

There are two types of processor affinity:

Soft Affinity – When an operating system has a policy of attempting to keep a process running on the same processor but not guaranteeing it will do so, this situation is called soft affinity. Hard Affinity – Hard Affinity allows a process to specify a subset of processors on which it may run. Some systems such as Linux implements soft affinity but also provide some system calls like sched_setaffinity() that supports hard affinity.

Load Balancing –

Load Balancing is the phenomena which keeps the workload evenly distributed across all processors in an SMP system. Load balancing is necessary only on systems where each processor has its own private queue of process which are eligible to execute. Load balancing is unnecessary because once a processor becomes idle it immediately extracts a runnable process from the common run queue. On SMP(symmetric multiprocessing), it is important to keep the workload balanced among all processors to fully utilize the benefits of having more than one processor else one or more processor will sit idle while other processors have high workloads along with lists of processors awaiting the CPU.

There are two general approaches to load balancing :

Push Migration – In push migration a task routinely checks the load on each processor and if it finds an imbalance then it evenly distributes load on each processors by moving the processes from overloaded to idle or less busy processors. Pull Migration – Pull Migration occurs when an idle processor pulls a waiting task from a busy processor for its execution.

Multicore Processors –

In multicore processors multiple processor cores are places on the same physical chip. Each core has a register set to maintain its architectural state and thus appears to the operating system as a separate physical processor. SMP systems that use multicore processors are faster and consume less power than systems in which each processor has its own physical chip.

However multicore processors may complicate the scheduling problems. When processor accesses memory then it spends a significant amount of time waiting for the data to become available. This situation is called MEMORY STALL. It occurs for various reasons such as cache miss, which is accessing the data that is not in the cache memory. In such cases the processor can spend upto fifty percent of its time waiting for data to become available from the memory. To solve this problem recent hardware designs have implemented multithreaded processor cores in which two or more hardware threads are assigned to each core. Therefore if one thread stalls while waiting for the memory, core can switch to another thread.

There are two ways to multithread a processor :

Coarse-Grained Multithreading – In coarse grained multithreading a thread executes on a processor until a long latency event such as a memory stall occurs, because of the delay caused by the long latency event, the processor must switch to another thread to begin execution. The cost of switching between threads is high as the instruction pipeline must be terminated before the other thread can begin execution on the processor core. Once this new thread begins execution it begins filling the pipeline with its instructions. Fine-Grained Multithreading – This multithreading switches between threads at a much finer level mainly at the boundary of an instruction cycle. The architectural design of fine grained systems include logic for thread switching and as a result the cost of switching between threads is small.

Virtualization and Threading –

In this type of multiple-processor scheduling even a single CPU system acts like a multiple-processor system. In a system with Virtualization, the virtualization presents one or more virtual CPU to each of virtual machines running on the system and then schedules the use of physical CPU among the virtual machines. Most virtualized environments have one host operating system and many guest operating systems. The host operating system creates and manages the virtual machines. Each virtual machine has a guest operating system installed and applications run within that guest.Each guest operating system may be assigned for specific use cases,applications or users including time sharing or even real-time operation. Any guest operating-system scheduling algorithm that assumes a certain amount of progress in a given amount of time will be negatively impacted by the virtualization. A time sharing operating system tries to allot 100 milliseconds to each time slice to give users a reasonable response time. A given 100 millisecond time slice may take much more than 100 milliseconds of virtual CPU time. Depending on how busy the system is, the time slice may take a second or more which results in a very poor response time for users logged into that virtual machine. The net effect of such scheduling layering is that individual virtualized operating systems receive only a portion of the available CPU cycles, even though they believe they are receiving all cycles and that they are scheduling all of those cycles.Commonly, the time-of-day clocks in virtual machines are incorrect because timers take no longer to trigger than they would on dedicated CPU’s.

Virtualizations can thus undo the good scheduling-algorithm efforts of the operating systems within virtual machines.

Reference –

Operating System Principles – Galvin

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VighneshKamath, mangoman"
47,"On the basis of synchronization, processes are categorized as one of the following two types:

Independent Process : Execution of one process does not affects the execution of other processes.

: Execution of one process does not affects the execution of other processes. Cooperative Process : Execution of one process affects the execution of other processes.

Process synchronization problem arises in the case of Cooperative process also because resources are shared in Cooperative processes.



Race Condition

When more than one processes are executing the same code or accessing the same memory or any shared variable in that condition there is a possibility that the output or the value of the shared variable is wrong so for that all the processes doing the race to say that my output is correct this condition known as a race condition. Several processes access and process the manipulations over the same data concurrently, then the outcome depends on the particular order in which the access takes place.

A race condition is a situation that may occur inside a critical section. This happens when the result of multiple thread execution in the critical section differs according to the order in which the threads execute.

Race conditions in critical sections can be avoided if the critical section is treated as an atomic instruction. Also, proper thread synchronization using locks or atomic variables can prevent race conditions.



Critical Section Problem

Critical section is a code segment that can be accessed by only one process at a time. Critical section contains shared variables which need to be synchronized to maintain consistency of data variables.



In the entry section, the process requests for entry in the Critical Section.

Any solution to the critical section problem must satisfy three requirements:

Mutual Exclusion : If a process is executing in its critical section, then no other process is allowed to execute in the critical section.

: If a process is executing in its critical section, then no other process is allowed to execute in the critical section. Progress : If no process is executing in the critical section and other processes are waiting outside the critical section, then only those processes that are not executing in their remainder section can participate in deciding which will enter in the critical section next, and the selection can not be postponed indefinitely.

: If no process is executing in the critical section and other processes are waiting outside the critical section, then only those processes that are not executing in their remainder section can participate in deciding which will enter in the critical section next, and the selection can not be postponed indefinitely. Bounded Waiting : A bound must exist on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.



Peterson’s Solution

Peterson’s Solution is a classical software based solution to the critical section problem.

In Peterson’s solution, we have two shared variables:

boolean flag[i] :Initialized to FALSE, initially no one is interested in entering the critical section

int turn : The process whose turn is to enter the critical section.





Peterson’s Solution preserves all three conditions :

Mutual Exclusion is assured as only one process can access the critical section at any time.

Progress is also assured, as a process outside the critical section does not block other processes from entering the critical section.

Bounded Waiting is preserved as every process gets a fair chance.



Disadvantages of Peterson’s Solution It involves Busy waiting



It is limited to 2 processes. TestAndSet

TestAndSet is a hardware solution to the synchronization problem. In TestAndSet, we have a shared lock variable which can take either of the two values, 0 or 1.

0 Unlock 1 Lock

Before entering into the critical section, a process inquires about the lock. If it is locked, it keeps on waiting until it becomes free and if it is not locked, it takes the lock and executes the critical section.

In TestAndSet, Mutual exclusion and progress are preserved but bounded waiting cannot be preserved.



Question : The enter_CS() and leave_CS() functions to implement critical section of a process are realized using test-and-set instruction as follows:

int TestAndSet(int &lock) { int initial = lock; lock = 1; return initial; } void enter_CS(X) { while test-and-set(X) ; } void leave_CS(X) { X = 0; }

In the above solution, X is a memory location associated with the CS and is initialized to 0. Now, consider the following statements:

I. The above solution to CS problem is deadlock-free

II. The solution is starvation free.

III. The processes enter CS in FIFO order.

IV. More than one process can enter CS at the same time.



Which of the above statements is TRUE?

(A) I

(B) II and III

(C) II and IV

(D) IV

Click here for the Solution.

true

Semaphores

A semaphore is a signaling mechanism and a thread that is waiting on a semaphore can be signaled by another thread. This is different than a mutex as the mutex can be signaled only by the thread that called the wait function.

A semaphore uses two atomic operations, wait and signal for process synchronization.

A Semaphore is an integer variable, which can be accessed only through two operations wait() and signal().

There are two types of semaphores: Binary Semaphores and Counting Semaphores

Binary Semaphores: They can only be either 0 or 1. They are also known as mutex locks, as the locks can provide mutual exclusion. All the processes can share the same mutex semaphore that is initialized to 1. Then, a process has to wait until the lock becomes 0. Then, the process can make the mutex semaphore 1 and start its critical section. When it completes its critical section, it can reset the value of mutex semaphore to 0 and some other process can enter its critical section.

Counting Semaphores: They can have any value and are not restricted over a certain domain. They can be used to control access to a resource that has a limitation on the number of simultaneous accesses. The semaphore can be initialized to the number of instances of the resource. Whenever a process wants to use that resource, it checks if the number of remaining instances is more than zero, i.e., the process has an instance available. Then, the process can enter its critical section thereby decreasing the value of the counting semaphore by 1. After the process is over with the use of the instance of the resource, it can leave the critical section thereby adding 1 to the number of available instances of the resource.

true

References

www.csee.wvu.edu/~jdmooney/classes/cs550/notes/tech/mutex/Peterson.html

http://iit.qau.edu.pk/books/OS_8th_Edition.pdf



Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : AmishRanjan, vaishnavipandey, shreyashagrawal, ramswarup_kulhary, harmansinghh"
48,"Prerequisite – Process Synchronization | Introduction, Critical Section, Semaphores

Process Synchronization is a technique which is used to coordinate the process that use shared Data. There are two types of Processes in an Operating Systems:-

Independent Process –

The process that does not affect or is affected by the other process while its execution then the process is called Independent Process. Example The process that does not share any shared variable, database, files, etc. Cooperating Process –

The process that affect or is affected by the other process while execution, is called a Cooperating Process. Example The process that share file, variable, database, etc are the Cooperating Process.

Process Synchronization is mainly used for Cooperating Process that shares the resources.Let us consider an example of

//racing condition image

It is the condition where several processes tries to access the resources and modify the shared data concurrently and outcome of the process depends on the particular order of execution that leads to data inconsistency, this condition is called Race Condition.This condition can be avoided using the technique called Synchronization or Process Synchronization, in which we allow only one process to enter and manipulates the shared data in Critical Section.

//diagram of the view of CS

This setup can be defined in various regions like:

Entry Section –

It is part of the process which decide the entry of a particular process in the Critical Section, out of many other processes.

It is part of the process which decide the entry of a particular process in the Critical Section, out of many other processes. Critical Section –

It is the part in which only one process is allowed to enter and modify the shared variable.This part of the process ensures that only no other process can access the resource of shared data.

It is the part in which only one process is allowed to enter and modify the shared variable.This part of the process ensures that only no other process can access the resource of shared data. Exit Section –

This process allows the other process that are waiting in the Entry Section, to enter into the Critical Sections. It checks that a process that after a process has finished execution in Critical Section can be removed through this Exit Section.

This process allows the other process that are waiting in the Entry Section, to enter into the Critical Sections. It checks that a process that after a process has finished execution in Critical Section can be removed through this Exit Section. Remainder Section –

The other parts of the Code other than Entry Section, Critical Section and Exit Section are known as Remainder Section.

Critical Section problems must satisfy these three requirements:

Mutual Exclusion –

It states that no other process is allowed to execute in the critical section if a process is executing in critical section. Progress –

When no process is in the critical section, then any process from outside that request for execution can enter in the critical section without any delay. Only those process can enter that have requested and have finite time to enter the process. Bounded Waiting –

An upper bound must exist on the number of times a process enters so that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.

Process Synchronization are handled by two approaches:

Software Approach –

In Software Approach, Some specific Algorithm approach is used to maintain synchronization of the data. Like in Approach One or Approach Two, for a number of two process, a temporary variable like (turn) or boolean variable (flag) value is used to store the data. When the condition is True then the process in waiting State, known as Busy Waiting State. This does not satisfy all the Critical Section requirements. Another Software approach known as Peterson’s Solution is best for Synchronization. It uses two variables in the Entry Section so as to maintain consistency, like Flag (boolean variable) and Turn variable(storing the process states). It satisfy all the three Critical Section requirements. //Image of Peterson’s Algorithm Hardware Approach –

The Hardware Approach of synchronization can be done through Lock & Unlock technique.Locking part is done in the Entry Section, so that only one process is allowed to enter into the Critical Section, after it complete its execution, the process is moved to the Exit Section, where Unlock Operation is done so that another process in the Lock Section can repeat this process of Execution.This process is designed in such a way that all the three conditions of the Critical Sections are satisfied.



//Image of Lock

Using Interrupts –

These are easy to implement.When Interrupt are disabled then no other process is allowed to perform Context Switch operation that would allow only one process to enter into the Critical State.

//Image of Interrupts

Test_and_Set Operation –

This allows boolean value (True/False) as a hardware Synchronization, which is atomic in nature i.e no other interrupt is allowed to access.This is mainly used in Mutual Exclusion Application. Similar type operation can be achieved through Compare and Swap function. In this process, a variable is allowed to accessed in Critical Section while its lock operation is ON.Till then, the other process is in Busy Waiting State. Hence Critical Section Requirements are achieved.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

kartikeya shukla 1 Loves Coding##"
49,"Critical Section:

When more than one processes access a same code segment that segment is known as critical section. Critical section contains shared variables or resources which are needed to be synchronized to maintain consistency of data variable.

In simple terms a critical section is group of instructions/statements or region of code that need to be executed atomically (read this post for atomicity), such as accessing a resource (file, input or output port, global data, etc.).

In concurrent programming, if one thread tries to change the value of shared data at the same time as another thread tries to read the value (i.e. data race across threads), the result is unpredictable.

The access to such shared variable (shared memory, shared files, shared port, etc…) to be synchronized. Few programming languages have built-in support for synchronization.

It is critical to understand the importance of race condition while writing kernel mode programming (a device driver, kernel thread, etc.). since the programmer can directly access and modifying kernel data structures.

A simple solution to the critical section can be thought as shown below,

acquireLock(); Process Critical Section releaseLock();

A thread must acquire a lock prior to executing a critical section. The lock can be acquired by only one thread. There are various ways to implement locks in the above pseudo code. Let us discuss them in future articles.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
50,"A process can be of two types:

Independent process.

Co-operating process.

An independent process is not affected by the execution of other processes while a co-operating process can be affected by other executing processes. Though one can think that those processes, which are running independently, will execute very efficiently, in reality, there are many situations when co-operative nature can be utilised for increasing computational speed, convenience and modularity. Inter process communication (IPC) is a mechanism which allows processes to communicate with each other and synchronize their actions. The communication between these processes can be seen as a method of co-operation between them. Processes can communicate with each other through both:



Shared Memory Message passing

The Figure 1 below shows a basic structure of communication between processes via the shared memory method and via the message passing method.

An operating system can implement both method of communication. First, we will discuss the shared memory methods of communication and then message passing. Communication between processes using shared memory requires processes to share some variable and it completely depends on how programmer will implement it. One way of communication using shared memory can be imagined like this: Suppose process1 and process2 are executing simultaneously and they share some resources or use some information from another process. Process1 generate information about certain computations or resources being used and keeps it as a record in shared memory. When process2 needs to use the shared information, it will check in the record stored in shared memory and take note of the information generated by process1 and act accordingly. Processes can use shared memory for extracting information as a record from another process as well as for delivering any specific information to other processes.

Let’s discuss an example of communication between processes using shared memory method.

i) Shared Memory Method

Ex: Producer-Consumer problem

There are two processes: Producer and Consumer. Producer produces some item and Consumer consumes that item. The two processes share a common space or memory location known as a buffer where the item produced by Producer is stored and from which the Consumer consumes the item, if needed. There are two versions of this problem: the first one is known as unbounded buffer problem in which Producer can keep on producing items and there is no limit on the size of the buffer, the second one is known as the bounded buffer problem in which Producer can produce up to a certain number of items before it starts waiting for Consumer to consume it. We will discuss the bounded buffer problem. First, the Producer and the Consumer will share some common memory, then producer will start producing items. If the total produced item is equal to the size of buffer, producer will wait to get it consumed by the Consumer. Similarly, the consumer will first check for the availability of the item. If no item is available, Consumer will wait for Producer to produce it. If there are items available, Consumer will consume it. The pseudo code to demonstrate is provided below:

Shared Data between the two Processes

filter_none edit

close play_arrow link

brightness_4

code #define buff_max 25 #define mod % struct item{ --------- } int free_index = 0; int full_index = 0;

chevron_right filter_none

Producer Process Code

filter_none edit

close play_arrow link

brightness_4

code item nextProduced; while (1){ while ((free_index+1) mod buff_max == full_index); shared_buff[free_index] = nextProduced; free_index = (free_index + 1) mod buff_max; }

chevron_right filter_none

Consumer Process Code

filter_none edit

close play_arrow link

brightness_4

code item nextConsumed; while (1){ while ((free_index == full_index); nextConsumed = shared_buff[full_index]; full_index = (full_index + 1) mod buff_max; }

chevron_right filter_none

In the above code, the Producer will start producing again when the (free_index+1) mod buff max will be free because if it it not free, this implies that there are still items that can be consumed by the Consumer so there is no need to produce more. Similarly, if free index and full index point to the same index, this implies that there are no items to consume.





ii) Messaging Passing Method

Now, We will start our discussion of the communication between processes via message passing. In this method, processes communicate with each other without using any kind of shared memory. If two processes p1 and p2 want to communicate with each other, they proceed as follows:



Establish a communication link (if a link already exists, no need to establish it again.)

Start exchanging messages using basic primitives.

We need at least two primitives:

– send(message, destinaion) or send(message)

– receive(message, host) or receive(message)

The message size can be of fixed size or of variable size. If it is of fixed size, it is easy for an OS designer but complicated for a programmer and if it is of variable size then it is easy for a programmer but complicated for the OS designer. A standard message can have two parts: header and body.

The header part is used for storing message type, destination id, source id, message length, and control information. The control information contains information like what to do if runs out of buffer space, sequence number, priority. Generally, message is sent using FIFO style.

Message Passing through Communication Link.

Direct and Indirect Communication link

Now, We will start our discussion about the methods of implementing communication link. While implementing the link, there are some questions which need to be kept in mind like :

How are links established? Can a link be associated with more than two processes? How many links can there be between every pair of communicating processes? What is the capacity of a link? Is the size of a message that the link can accommodate fixed or variable? Is a link unidirectional or bi-directional?

A link has some capacity that determines the number of messages that can reside in it temporarily for which every link has a queue associated with it which can be of zero capacity, bounded capacity, or unbounded capacity. In zero capacity, the sender waits until the receiver informs the sender that it has received the message. In non-zero capacity cases, a process does not know whether a message has been received or not after the send operation. For this, the sender must communicate with the receiver explicitly. Implementation of the link depends on the situation, it can be either a direct communication link or an in-directed communication link.

Direct Communication links are implemented when the processes uses a specific process identifier for the communication, but it is hard to identify the sender ahead of time.

For example: the print server.



In-direct Communication is done via a shared mailbox (port), which consists of a queue of messages. The sender keeps the message in mailbox and the receiver picks them up.

Message Passing through Exchanging the Messages.

Synchronous and Asynchronous Message Passing:

A process that is blocked is one that is waiting for some event, such as a resource becoming available or the completion of an I/O operation. IPC is possible between the processes on same computer as well as on the processes running on different computer i.e. in networked/distributed system. In both cases, the process may or may not be blocked while sending a message or attempting to receive a message so message passing may be blocking or non-blocking. Blocking is considered synchronous and blocking send means the sender will be blocked until the message is received by receiver. Similarly, blocking receive has the receiver block until a message is available. Non-blocking is considered asynchronous and Non-blocking send has the sender sends the message and continue. Similarly, Non-blocking receive has the receiver receive a valid message or null. After a careful analysis, we can come to a conclusion that for a sender it is more natural to be non-blocking after message passing as there may be a need to send the message to different processes. However, the sender expects acknowledgement from the receiver in case the send fails. Similarly, it is more natural for a receiver to be blocking after issuing the receive as the information from the received message may be used for further execution. At the same time, if the message send keep on failing, the receiver will have to wait indefinitely. That is why we also consider the other possibility of message passing. There are basically three preferred combinations:

Blocking send and blocking receive

Non-blocking send and Non-blocking receive

Non-blocking send and Blocking receive (Mostly used)

In Direct message passing, The process which want to communicate must explicitly name the recipient or sender of communication.

e.g. send(p1, message) means send the message to p1.

similarly, receive(p2, message) means receive the message from p2.

In this method of communication, the communication link gets established automatically, which can be either unidirectional or bidirectional, but one link can be used between one pair of the sender and receiver and one pair of sender and receiver should not possess more than one pair of links. Symmetry and asymmetry between sending and receiving can also be implemented i.e. either both process will name each other for sending and receiving the messages or only the sender will name receiver for sending the message and there is no need for receiver for naming the sender for receiving the message. The problem with this method of communication is that if the name of one process changes, this method will not work.



In Indirect message passing, processes use mailboxes (also referred to as ports) for sending and receiving messages. Each mailbox has a unique id and processes can communicate only if they share a mailbox. Link established only if processes share a common mailbox and a single link can be associated with many processes. Each pair of processes can share several communication links and these links may be unidirectional or bi-directional. Suppose two process want to communicate though Indirect message passing, the required operations are: create a mail box, use this mail box for sending and receiving messages, then destroy the mail box. The standard primitives used are: send(A, message) which means send the message to mailbox A. The primitive for the receiving the message also works in the same way e.g. received (A, message). There is a problem in this mailbox implementation. Suppose there are more than two processes sharing the same mailbox and suppose the process p1 sends a message to the mailbox, which process will be the receiver? This can be solved by either enforcing that only two processes can share a single mailbox or enforcing that only one process is allowed to execute the receive at a given time or select any process randomly and notify the sender about the receiver. A mailbox can be made private to a single sender/receiver pair and can also be shared between multiple sender/receiver pairs. Port is an implementation of such mailbox which can have multiple sender and single receiver. It is used in client/server applications (in this case the server is the receiver). The port is owned by the receiving process and created by OS on the request of the receiver process and can be destroyed either on request of the same receiver process or when the receiver terminates itself. Enforcing that only one process is allowed to execute the receive can be done using the concept of mutual exclusion. Mutex mailbox is create which is shared by n process. Sender is non-blocking and sends the message. The first process which executes the receive will enter in the critical section and all other processes will be blocking and will wait.



Now, lets discuss the Producer-Consumer problem using message passing concept. The producer places items (inside messages) in the mailbox and the consumer can consume an item when at least one message present in the mailbox. The code is given below:



Producer Code

filter_none edit

close play_arrow link

brightness_4

code void Producer( void ){ int item; Message m; while (1){ receive(Consumer, &m); item = produce(); build_message(&m , item ) ; send(Consumer, &m); } }

chevron_right filter_none

Consumer Code

filter_none edit

close play_arrow link

brightness_4

code void Consumer( void ){ int item; Message m; while (1){ receive(Producer, &m); item = extracted_item(); send(Producer, &m); consume_item(item); } }

chevron_right filter_none

Examples of IPC systems

Posix : uses shared memory method. Mach : uses message passing Windows XP : uses message passing using local procedural calls

Communication in client/server Architecture:

There are various mechanism:

Pipe

Socket

Remote Procedural calls (RPCs)

The above three methods will be discussed in later articles as all of them are quite conceptual and deserve their own separate articles.



References:

Operating System Concepts by Galvin et al. Lecture notes/ppt of Ariel J. Frank, Bar-Ilan University

More Reference:

http://nptel.ac.in/courses/106108101/pdf/Lecture_Notes/Mod%207_LN.pdf

https://www.youtube.com/watch?v=lcRqHwIn5Dk



This article is contributed by Durgesh Pandey. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : ShubhamMaurya3, shubham_singh, 64josh"
51,"Prerequisite – Inter Process Communication,

Inter-process communication (IPC) is set of interfaces, which is usually programmed in order for the programs to communicate between series of processes. This allows running programs concurrently in an Operating System. These are the methods in IPC:

Pipes (Same Process) –

This allows flow of data in one direction only. Analogous to simplex systems (Keyboard). Data from the output is usually buffered until input process receives it which must have a common origin. Names Pipes (Different Processes) –

This is a pipe with a specific name it can be used in processes that don’t have a shared common process origin. E.g. is FIFO where the details written to a pipe is first named. Message Queuing –

This allows messages to be passed between processes using either a single queue or several message queue. This is managed by system kernel these messages are coordinated using an API. Semaphores –

This is used in solving problems associated with synchronization and to avoid race condition. These are integer values which are greater than or equal to 0. Shared memory –

This allows the interchange of data through a defined area of memory. Semaphore values have to be obtained before data can get access to shared memory. Sockets –

This method is mostly used to communicate over a network between a client and a server. It allows for a standard connection which is computer and OS independent.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : shreyashagrawal"
52,"Inter Process Communication through shared memory is a concept where two or more process can access the common memory. And communication is done via this shared memory where changes made by one process can be viewed by another process.

The problem with pipes, fifo and message queue – is that for two process to exchange information. The information has to go through the kernel."
53,"Prerequisite : Inter Process Communication

A message queue is a linked list of messages stored within the kernel and identified by a message queue identifier. A new queue is created or an existing queue opened by msgget().

New messages are added to the end of a queue by msgsnd(). Every message has a positive long integer type field, a non-negative length, and the actual data bytes (corresponding to the length), all of which are specified to msgsnd() when the message is added to a queue. Messages are fetched from a queue by msgrcv(). We don’t have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field.

All processes can exchange information through access to a common system message queue. The sending process places a message (via some (OS) message-passing module) onto a queue which can be read by another process. Each message is given an identification or type so that processes can select the appropriate message. Process must share a common key in order to gain access to the queue in the first place.

System calls used for message queues:

ftok(): is use to generate a unique key. msgget(): either returns the message queue identifier for a newly created message queue or returns the identifiers for a queue which exists with the same key value. msgsnd(): Data is placed on to a message queue by calling msgsnd(). msgrcv(): messages are retrieved from a queue. msgctl(): It performs various operations on a queue. Generally it is use to destroy message queue.

MESSAGE QUEUE FOR WRITER PROCESS

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <sys/ipc.h> #include <sys/msg.h> struct mesg_buffer { long mesg_type; char mesg_text[100]; } message; int main() { key_t key; int msgid; key = ftok( ""progfile"" , 65); msgid = msgget(key, 0666 | IPC_CREAT); message.mesg_type = 1; printf ( ""Write Data : "" ); gets (message.mesg_text); msgsnd(msgid, &message, sizeof (message), 0); printf ( ""Data send is : %s

"" , message.mesg_text); return 0; }

chevron_right filter_none

MESSAGE QUEUE FOR READER PROCESS

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <sys/ipc.h> #include <sys/msg.h> struct mesg_buffer { long mesg_type; char mesg_text[100]; } message; int main() { key_t key; int msgid; key = ftok( ""progfile"" , 65); msgid = msgget(key, 0666 | IPC_CREAT); msgrcv(msgid, &message, sizeof (message), 1, 0); printf ( ""Data Received is : %s

"" , message.mesg_text); msgctl(msgid, IPC_RMID, NULL); return 0; }

chevron_right filter_none

Output:



Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
54,"Prerequisites – Cloud computing, Load balancing in Cloud Computing, Inter-process Communication

In the development of models and technologies, message abstraction is a necessary aspect that enables distributed computing. Distributed system is defined as a system in which components reside at networked communication and synchronise its functions only by movement of messages. In this, message recognizes any discrete data that is moved from one entity to another. It includes any kind of data representation having restriction of size and time, whereas it invokes a remote procedure or a sequence of object instance or a common message. This is the reason that “message-based communication model” can be beneficial to refer various model for inter-process communication, which is based on the data streaming abstraction.

Various distributed programming model use this type of communication despite of the abstraction which is shown to developers for programming the co-ordination of shared components. Below are some major distributed programming models that uses “message-based communication model”.

Message Passing –

In this model, the concept of message as the major abstraction of model is introduced. The units which inter-change the data and information that is explicitly encode, in the form of message. According to then model, the schema and content of message changes or varies. Message Passing Interface and OpenMP are major example of this type of model.

In this model, the concept of message as the major abstraction of model is introduced. The units which inter-change the data and information that is explicitly encode, in the form of message. According to then model, the schema and content of message changes or varies. Message Passing Interface and OpenMP are major example of this type of model. Remote Procedure Call –

This model explores the keys of procedure call beyond the restrictions of a single process, thus pointing the execution of program in remote processes. In this, primary client-server is implied. A remote process maintains a server component, thus enabling client processes to invoke the approaches and returns the output of the execution. Messages, created by the Remote Procedure Call (RPC) implementation, retrieve the information of the procedure itself and that procedure is to execute having necessary arguments and also returns the values. The use of messages regarding this referred as marshal-ling of the arguments and return values.

This model explores the keys of procedure call beyond the restrictions of a single process, thus pointing the execution of program in remote processes. In this, primary client-server is implied. A remote process maintains a server component, thus enabling client processes to invoke the approaches and returns the output of the execution. Messages, created by the Remote Procedure Call (RPC) implementation, retrieve the information of the procedure itself and that procedure is to execute having necessary arguments and also returns the values. The use of messages regarding this referred as marshal-ling of the arguments and return values. Distributed Objects –

It is an implementation of Remote Procedure Call (RPC) model for the Object-oriented model, and contextualizes this for the remote invocation of methods extended by objects. Every process assigns a set of interfaces which are accessible remotely. Client process can demand a reference to these interfaces and invoke the methods available through them. The basic runtime infrastructure is in transformation the local method calls into a request to a remote process and collecting the result of the execution. The interaction within the caller and the remote process is done trough messages. This model is stateless by design, distributed object models introduce the complexity of object state management and lifetime. Common Object Request Broker Architecture (CORBA), Component Object Model (COM, DCOM and COM+), Java Remote Method Invocation (RMI), and .NET Remoting are some major examples which falls under Distributed object infrastructure.

It is an implementation of Remote Procedure Call (RPC) model for the Object-oriented model, and contextualizes this for the remote invocation of methods extended by objects. Every process assigns a set of interfaces which are accessible remotely. Client process can demand a reference to these interfaces and invoke the methods available through them. The basic runtime infrastructure is in transformation the local method calls into a request to a remote process and collecting the result of the execution. The interaction within the caller and the remote process is done trough messages. This model is stateless by design, distributed object models introduce the complexity of object state management and lifetime. Common Object Request Broker Architecture (CORBA), Component Object Model (COM, DCOM and COM+), Java Remote Method Invocation (RMI), and .NET Remoting are some major examples which falls under Distributed object infrastructure. Active objects –

Programming models based on active objects comprise by definition the presence of instances, whether they are agent of objects, despite the availability of requests. It means, that objects having particular control thread, which enables them to convey their activity. These models sometime make manual use of messages to encounter the execution of functions and a more complex and a more complex semantics is attached to the messages.

Programming models based on active objects comprise by definition the presence of instances, whether they are agent of objects, despite the availability of requests. It means, that objects having particular control thread, which enables them to convey their activity. These models sometime make manual use of messages to encounter the execution of functions and a more complex and a more complex semantics is attached to the messages. Web Services –

Web service technology delivers an approach of the RPC concept over the HTTP, thus enabling the communication of components that are evolved with numerous technologies. A web service is revealed as a remote object maintained on a Web server, and method invocations are transformed in HTTP requests wrapped with the help of specific protocol. It is necessary to observe that the concept of message is a basic abstraction of inter-process communication and it is utilized either implicitly or explicitly.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
55,"Prerequisite : C signal handling

In this post, the communication between child and parent processes is done using kill() and signal(), fork() system call.

fork() creates the child process from the parent. The pid can be checked to decide whether it is the child (if pid == 0) or the parent (pid = child process id).

creates the child process from the parent. The pid can be checked to decide whether it is the child (if pid == 0) or the parent (pid = child process id). The parent can then send messages to child using the pid and kill().

The child picks up these signals with signal() and calls appropriate functions.

Example of how 2 processes can talk to each other using kill() and signal():

filter_none edit

close play_arrow link

brightness_4

code #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <sys/types.h> #include <unistd.h> void sighup(); void sigint(); void sigquit(); void main() { int pid; if ((pid = fork()) < 0) { perror ( ""fork"" ); exit (1); } if (pid == 0) { signal (SIGHUP, sighup); signal (SIGINT, sigint); signal (SIGQUIT, sigquit); for (;;) ; } else { printf ( ""

PARENT: sending SIGHUP



"" ); kill(pid, SIGHUP); sleep(3); printf ( ""

PARENT: sending SIGINT



"" ); kill(pid, SIGINT); sleep(3); printf ( ""

PARENT: sending SIGQUIT



"" ); kill(pid, SIGQUIT); sleep(3); } } void sighup() { signal (SIGHUP, sighup); printf ( ""CHILD: I have received a SIGHUP

"" ); } void sigint() { signal (SIGINT, sigint); printf ( ""CHILD: I have received a SIGINT

"" ); } void sigquit() { printf ( ""My DADDY has Killed me!!!

"" ); exit (0); } chevron_right filter_none

Output:



Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
56,"Prerequisite: process-synchronization, Mutex vs Semaphore

Semaphore was proposed by Dijkstra in 1965 which is a very significant technique to manage concurrent processes by using a simple integer value, which is known as a semaphore. Semaphore is simply a variable which is non-negative and shared between threads. This variable is used to solve the critical section problem and to achieve process synchronization in the multiprocessing environment.

Semaphores are of two types:

Binary Semaphore – This is also known as mutex lock. It can have only two values – 0 and 1. Its value is initialized to 1. It is used to implement the solution of critical section problem with multiple processes. Counting Semaphore – Its value can range over an unrestricted domain. It is used to control access to a resource that has multiple instances.

Now let us see how it do so.

First, look at two operations which can be used to access and change the value of the semaphore variable.

Some point regarding P and V operation

P operation is also called wait, sleep or down operation and V operation is also called signal, wake-up or up operation. Both operations are atomic and semaphore(s) is always initialized to one.Here atomic means that variable on which read, modify and update happens at the same time/moment with no pre-emption i.e. in between read, modify and update no other operation is performed that may change the variable. A critical section is surrounded by both operations to implement process synchronization.See below image.critical section of Process P is in between P and V operation.

Now, let us see how it implements mutual exclusion. Let there be two processes P1 and P2 and a semaphore s is initialized as 1. Now if suppose P1 enters in its critical section then the value of semaphore s becomes 0. Now if P2 wants to enter its critical section then it will wait until s > 0, this can only happen when P1 finishes its critical section and calls V operation on semaphore s. This way mutual exclusion is achieved. Look at the below image for details which is Binary semaphore.

Implementation of binary semaphores:

filter_none edit

close play_arrow link

brightness_4

code struct semaphore { enum value(0, 1); Queue<process> q; } P(semaphore s) { if (s.value == 1) { s.value = 0; } else { q.push(P) sleep(); } } V(Semaphore s) { if (s.q is empty) { s.value = 1; } else { s.value = 1; q.pop(); wakeup(); } } chevron_right filter_none

The description above is for binary semaphore which can take only two values 0 and 1 and ensure the mutual exclusion. There is one other type of semaphore called counting semaphore which can take values greater than one.

Now suppose there is a resource whose number of instance is 4. Now we initialize S = 4 and rest is same as for binary semaphore. Whenever process wants that resource it calls P or wait function and when it is done it calls V or signal function. If the value of S becomes zero then a process has to wait until S becomes positive. For example, Suppose there are 4 process P1, P2, P3, P4 and they all call wait operation on S(initialized with 4). If another process P5 wants the resource then it should wait until one of the four processes calls signal function and value of semaphore becomes positive.

Limitations

One of the biggest limitation of semaphore is priority inversion. Deadlock, suppose a process is trying to wake up another process which is not in sleep state.Therefore a deadlock may block indefinitely. The operating system has to keep track of all calls to wait and to signal the semaphore.

Problem in this implementation of semaphore

Whenever any process waits then it continuously checks for semaphore value (look at this line while (s==0); in P operation) and waste CPU cycle. To avoid this another implementation is provided below.

Implementation of counting semaphore

filter_none edit

close play_arrow link

brightness_4

code struct Semaphore { int value; Queue<process> q; } P(Semaphore s) { s.value = s.value - 1; if (s.value < 0) { q.push(p); block(); } else return ; } V(Semaphore s) { s.value = s.value + 1; if (s.value <= 0) { q.pop(); wakeup(p); } else return ; } chevron_right filter_none

In this implementation whenever process waits it is added to a waiting queue of processes associated with that semaphore. This is done through system call block() on that process. When a process is completed it calls signal function and one process in the queue is resumed. It uses wakeup() system call.

This article is contributed by Ashish Sharma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
57,"What are the differences between Mutex vs Semaphore? When to use mutex and when to use semaphore?

Concrete understanding of Operating System concepts is required to design/develop smart applications. Our objective is to educate the reader on these concepts and learn from other expert geeks.

As per operating system terminology, mutex and semaphore are kernel resources that provide synchronization services (also called as synchronization primitives). Why do we need such synchronization primitives? Won’t be only one sufficient? To answer these questions, we need to understand few keywords. Please read the posts on atomicity and critical section. We will illustrate with examples to understand these concepts well, rather than following usual OS textual description.

The producer-consumer problem:

Note that the content is generalized explanation. Practical details vary with implementation.

Consider the standard producer-consumer problem. Assume, we have a buffer of 4096 byte length. A producer thread collects the data and writes it to the buffer. A consumer thread processes the collected data from the buffer. Objective is, both the threads should not run at the same time.

Using Mutex:

A mutex provides mutual exclusion, either producer or consumer can have the key (mutex) and proceed with their work. As long as the buffer is filled by producer, the consumer needs to wait, and vice versa.

At any point of time, only one thread can work with the entire buffer. The concept can be generalized using semaphore.

Using Semaphore:

A semaphore is a generalized mutex. In lieu of single buffer, we can split the 4 KB buffer into four 1 KB buffers (identical resources). A semaphore can be associated with these four buffers. The consumer and producer can work on different buffers at the same time.

Misconception:

There is an ambiguity between binary semaphore and mutex. We might have come across that a mutex is binary semaphore. But they are not! The purpose of mutex and semaphore are different. May be, due to similarity in their implementation a mutex would be referred as binary semaphore.

Strictly speaking, a mutex is locking mechanism used to synchronize access to a resource. Only one task (can be a thread or process based on OS abstraction) can acquire the mutex. It means there is ownership associated with mutex, and only the owner can release the lock (mutex).

Semaphore is signaling mechanism (“I am done, you can carry on” kind of signal). For example, if you are listening songs (assume it as one task) on your mobile and at the same time your friend calls you, an interrupt is triggered upon which an interrupt service routine (ISR) signals the call processing task to wakeup.

General Questions:

1. Can a thread acquire more than one lock (Mutex)?

Yes, it is possible that a thread is in need of more than one resource, hence the locks. If any lock is not available the thread will wait (block) on the lock.

2. Can a mutex be locked more than once?

A mutex is a lock. Only one state (locked/unlocked) is associated with it. However, a recursive mutex can be locked more than once (POSIX complaint systems), in which a count is associated with it, yet retains only one state (locked/unlocked). The programmer must unlock the mutex as many number times as it was locked.

3. What happens if a non-recursive mutex is locked more than once.

Deadlock. If a thread which had already locked a mutex, tries to lock the mutex again, it will enter into the waiting list of that mutex, which results in deadlock. It is because no other thread can unlock the mutex. An operating system implementer can exercise care in identifying the owner of mutex and return if it is already locked by same thread to prevent deadlocks.

4. Are binary semaphore and mutex same?

No. We suggest to treat them separately, as it is explained signalling vs locking mechanisms. But a binary semaphore may experience the same critical issues (e.g. priority inversion) associated with mutex. We will cover these in later article.

A programmer can prefer mutex rather than creating a semaphore with count 1.

5. What is a mutex and critical section?

Some operating systems use the same word critical section in the API. Usually a mutex is costly operation due to protection protocols associated with it. At last, the objective of mutex is atomic access. There are other ways to achieve atomic access like disabling interrupts which can be much faster but ruins responsiveness. The alternate API makes use of disabling interrupts.

6. What are events?

The semantics of mutex, semaphore, event, critical section, etc… are same. All are synchronization primitives. Based on their cost in using them they are different. We should consult the OS documentation for exact details.

7. Can we acquire mutex/semaphore in an Interrupt Service Routine?

An ISR will run asynchronously in the context of current running thread. It is not recommended to query (blocking call) the availability of synchronization primitives in an ISR. The ISR are meant be short, the call to mutex/semaphore may block the current running thread. However, an ISR can signal a semaphore or unlock a mutex.

8. What we mean by “thread blocking on mutex/semaphore” when they are not available?

Every synchronization primitive has a waiting list associated with it. When the resource is not available, the requesting thread will be moved from the running list of processor to the waiting list of the synchronization primitive. When the resource is available, the higher priority thread on the waiting list gets the resource (more precisely, it depends on the scheduling policies).

9. Is it necessary that a thread must block always when resource is not available?

Not necessary. If the design is sure ‘what has to be done when resource is not available‘, the thread can take up that work (a different code branch). To support application requirements the OS provides non-blocking API.

For example POSIX pthread_mutex_trylock() API. When mutex is not available the function returns immediately whereas the API pthread_mutex_lock() blocks the thread till resource is available.

References:

http://www.netrino.com/node/202

http://doc.trolltech.com/4.7/qsemaphore.html

Also compare mutex/semaphores with Peterson’s algorithm and Dekker’s algorithm. A good reference is the Art of Concurrency book. Also explore reader locks and writer locks in Qt documentation.

Exercise:

Implement a program that prints a message “An instance is running” when executed more than once in the same session. For example, if we observe word application or Adobe reader in Windows, we can see only one instance in the task manager. How to implement it?

Article compiled by Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
58,"The monitor is one of the ways to achieve Process synchronization. The monitor is supported by programming languages to achieve mutual exclusion between processes. For example Java Synchronized methods. Java provides wait() and notify() constructs.

It is the collection of condition variables and procedures combined together in a special kind of module or a package. The processes running outside the monitor can’t access the internal variable of the monitor but can call procedures of the monitor. Only one process at a time can execute code inside monitors.

Syntax:

Condition Variables:

Two different operations are performed on the condition variables of the monitor.

Wait. signal.

let say we have 2 condition variables

condition x, y; // Declaring variable

Wait operation

x.wait() : Process performing wait operation on any condition variable are suspended. The suspended processes are placed in block queue of that condition variable.

Note: Each condition variable has its unique block queue.

Signal operation

x.signal(): When a process performs signal operation on condition variable, one of the blocked processes is given chance.

If (x block queue empty) // Ignore signal else // Resume a process from block queue.

Advantages of Monitor:

Monitors have the advantage of making parallel programming easier and less error prone than using techniques such as semaphore.

Disadvantages of Monitor:

Monitors have to be implemented as part of the programming language . The compiler must generate code for them. This gives the compiler the additional burden of having to know what operating system facilities are available to control access to critical sections in concurrent processes. Some languages that do support monitors are Java,C#,Visual Basic,Ada and concurrent Euclid.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : shivanshukumarsingh1"
59,"Problem: Given 2 processes i and j, you need to write a program that can guarantee mutual exclusion between the two without any additional hardware support.

Solution: There can be multiple ways to solve this problem, but most of them require additional hardware support. The simplest and the most popular way to do this is by using Peterson’s Algorithm for mutual Exclusion. It was developed by Peterson in 1981 though the initial work in this direction was done by Theodorus Jozef Dekker who came up with Dekker’s algorithm in 1960, which was later refined by Peterson and came to be known as Peterson’s Algorithm.

Basically, Peterson’s algorithm provides guaranteed mutual exclusion by using only the shared memory. It uses two ideas in the algorithm:

Willingness to acquire lock. Turn to acquire lock.

Prerequisite: Multithreading in C

Explanation:

The idea is that first a thread expresses its desire to acquire a lock and sets flag[self] = 1 and then gives the other thread a chance to acquire the lock. If the thread desires to acquire the lock, then, it gets the lock and passes the chance to the 1st thread. If it does not desire to get the lock then the while loop breaks and the 1st thread gets the chance.

Implementation in C language

C filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <pthread.h> #include""mythreads.h"" int flag[2]; int turn; const int MAX = 1e9; int ans = 0; void lock_init() { flag[0] = flag[1] = 0; turn = 0; } void lock( int self) { flag[self] = 1; turn = 1-self; while (flag[1-self]==1 && turn==1-self) ; } void unlock( int self) { flag[self] = 0; } void * func( void *s) { int i = 0; int self = ( int *)s; printf ( ""Thread Entered: %d

"" , self); lock(self); for (i=0; i<MAX; i++) ans++; unlock(self); } int main() { pthread_t p1, p2; lock_init(); pthread_create(&p1, NULL, func, ( void *)0); pthread_create(&p2, NULL, func, ( void *)1); pthread_join(p1, NULL); pthread_join(p2, NULL); printf ( ""Actual Count: %d | Expected Count: %d

"" , ans, MAX*2); return 0; } chevron_right filter_none

C filter_none edit

close play_arrow link

brightness_4

code #ifndef __MYTHREADS_h__ #define __MYTHREADS_h__ #include <pthread.h> #include <assert.h> #include <sched.h> void Pthread_mutex_lock(pthread_mutex_t *m) { int rc = pthread_mutex_lock(m); assert (rc == 0); } void Pthread_mutex_unlock(pthread_mutex_t *m) { int rc = pthread_mutex_unlock(m); assert (rc == 0); } void Pthread_create(pthread_t * thread , const pthread_attr_t *attr, void *(*start_routine)( void *), void *arg) { int rc = pthread_create( thread , attr, start_routine, arg); assert (rc == 0); } void Pthread_join(pthread_t thread , void **value_ptr) { int rc = pthread_join( thread , value_ptr); assert (rc == 0); } #endif // __MYTHREADS_h__ chevron_right filter_none

Output:

Thread Entered: 1 Thread Entered: 0 Actual Count: 2000000000 | Expected Count: 2000000000

The produced output is 2*109 where 109 is incremented by both threads.

This article is contributed by Pinkesh Badjatiya . If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : pigeonlord01"
60,"Problem: Given 2 process i and j, you need to write a program that can guarantee mutual exclusion between the two without any additional hardware support.

We strongly recommend to refer below basic solution discussed in previous article.

Peterson’s Algorithm for Mutual Exclusion | Set 1

We would be resolving 2 issues in the previous algorithm.

Wastage of CPU clock cycles

In layman terms, when a thread was waiting for its turn, it ended in a long while loop which tested the condition millions of times per second thus doing unnecessary computation. There is a better way to wait, and it is known as “yield”.

To understand what it does, we need to dig deep into how the Process scheduler works in Linux. The idea mentioned here is a simplified version of the scheduler, the actual implementation has lots of complications.

Consider the following example,

There are three processes, P1, P2 and P3. Process P3 is such that it has a while loop similar to the one in our code, doing not so useful computation, and it exists from the loop only when P2 finishes its execution. The scheduler puts all of them in a round robin queue. Now, say the clock speed of processor is 1000000/sec, and it allocates 100 clocks to each process in each iteration. Then, first P1 will be run for 100 clocks (0.0001 seconds), then P2(0.0001 seconds) followed by P3(0.0001 seconds), now since there are no more processes, this cycle repeats untill P2 ends and then followed by P3’s execution and eventually its termination.

This is a complete waste of the 100 CPU clock cycles. To avoid this, we mutually give up the CPU time slice, i.e. yield, which essentially ends this time slice and the scheduler picks up the next process to run. Now, we test our condition once, then we give up the CPU. Considering our test takes 25 clock cycles, we save 75% of our computation in a time slice. To put this graphically,

Considering the processor clock speed as 1MHz this is a lot of saving!.

Different distributions provide different function to achieve this functionality. Linux provides sched_yield().

filter_none edit

close play_arrow link

brightness_4

code void lock( int self) { flag[self] = 1; turn = 1-self; while (flag[1-self] == 1 && turn == 1-self) sched_yield(); }

chevron_right filter_none

Memory fence.

The code in earlier tutorial might have worked on most systems, but is was not 100% correct. The logic was perfect, but most modern CPUs employ performance optimizations that can result in out-of-order execution. This reordering of memory operations (loads and stores) normally goes unnoticed within a single thread of execution, but can cause unpredictable behaviour in concurrent programs.

Consider this example,

filter_none edit

close play_arrow link

brightness_4

code while (f == 0); print x;

chevron_right filter_none

In the above example, the compiler considers the 2 statements as independent of each other and thus tries to increase the code efficiency by re-ordering them, which can lead to problems for concurrent programs. To avoid this we place a memory fence to give hint to the compiler about the possible relationship between the statements across the barrier.

So the order of statements,

flag[self] = 1;

turn = 1-self;

while (turn condition check)

yield();

has to be exactly the same in order for the lock to work, otherwise it will end up in a deadlock condition.

To ensure this, compilers provide a instruction that prevent ordering of statements across this barrier. In case of gcc, its __sync_synchronize().

So the modified code becomes,

Full Implementation in C:

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<pthread.h> #include ""mythreads.h"" int flag[2]; int turn; const int MAX = 1e9; int ans = 0; void lock_init() { flag[0] = flag[1] = 0; turn = 0; } void lock( int self) { flag[self]=1; turn = 1-self; __sync_synchronize(); while (flag[1-self]==1 && turn==1-self) sched_yield(); } void unlock( int self) { flag[self]=0; } void * func( void *s) { int i = 0; int self = ( int *)s; printf ( ""Thread Entered: %d

"" ,self); lock(self); for (i=0; i<MAX; i++) ans++; unlock(self); } int main() { pthread_t p1, p2; lock_init(); Pthread_create(&p1, NULL, func, ( void *)0); Pthread_create(&p2, NULL, func, ( void *)1); Pthread_join(p1, NULL); Pthread_join(p2, NULL); printf ( ""Actual Count: %d | Expected Count:"" "" %d

"" ,ans,MAX*2); return 0; }

chevron_right filter_none

filter_none edit

close play_arrow link

brightness_4

code #ifndef __MYTHREADS_h__ #define __MYTHREADS_h__ #include <pthread.h> #include <assert.h> #include <sched.h> void Pthread_mutex_lock(pthread_mutex_t *m) { int rc = pthread_mutex_lock(m); assert (rc == 0); } void Pthread_mutex_unlock(pthread_mutex_t *m) { int rc = pthread_mutex_unlock(m); assert (rc == 0); } void Pthread_create(pthread_t * thread , const pthread_attr_t *attr, void *(*start_routine)( void *), void *arg) { int rc = pthread_create( thread , attr, start_routine, arg); assert (rc == 0); } void Pthread_join(pthread_t thread , void **value_ptr) { int rc = pthread_join( thread , value_ptr); assert (rc == 0); } #endif // __MYTHREADS_h__

chevron_right filter_none

Output:

Thread Entered: 1 Thread Entered: 0 Actual Count: 2000000000 | Expected Count: 2000000000

This article is contributed by Pinkesh Badjatiya . If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
61,"Prerequisite – synchronization, Critical Section

Problem:The producer consumer problem (or bounded buffer problem) describes two processes, the producer and the consumer, which share a common, fixed-size buffer used as a queue. Producer produce an item and put it into buffer. If buffer is already full then producer will have to wait for an empty block in buffer. Consumer consume an item from buffer. If buffer is already empty then consumer will have to wait for an item in buffer. Implement Peterson’s Algorithm for the two processes using shared memory such that there is mutual exclusion between them. The solution should have free from synchronization problems.

Peterson’s algorithm –

filter_none edit

close play_arrow link

brightness_4

code flag[j] = true ; turn = i; while (flag[i] == true && turn == i) { flag[j] = false ; flag[i] = true ; turn = j; while (flag[j] == true && turn == j) { flag[i] = false ; chevron_right filter_none

Explanation of Peterson’s algorithm –

Peterson’s Algorithm is used to synchronize two processes. It uses two variables, a bool array flag of size 2 and an int variable turn to accomplish it.

In the solution i represents the Consumer and j represents the Producer. Initially the flags are false. When a process wants to execute it’s critical section, it sets it’s flag to true and turn as the index of the other process. This means that the process wants to execute but it will allow the other process to run first. The process performs busy waiting until the other process has finished it’s own critical section.

After this the current process enters it’s critical section and adds or removes a random number from the shared buffer. After completing the critical section, it sets it’s own flag to false, indication it does not wish to execute anymore.

The program runs for a fixed amount of time before exiting. This time can be changed by changing value of the macro RT.

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <time.h> #include <sys/types.h> #include <sys/ipc.h> #include <sys/shm.h> #include <stdbool.h> #define _BSD_SOURCE #include <sys/time.h> #include <stdio.h> #define BSIZE 8 // Buffer size #define PWT 2 // Producer wait time limit #define CWT 10 // Consumer wait time limit #define RT 10 // Program run-time in seconds int shmid1, shmid2, shmid3, shmid4; key_t k1 = 5491, k2 = 5812, k3 = 4327, k4 = 3213; bool * SHM1; int * SHM2; int * SHM3; int myrand( int n) { time_t t; srand ((unsigned) time (&t)); return ( rand () % n + 1); } int main() { shmid1 = shmget(k1, sizeof ( bool ) * 2, IPC_CREAT | 0660); shmid2 = shmget(k2, sizeof ( int ) * 1, IPC_CREAT | 0660); shmid3 = shmget(k3, sizeof ( int ) * BSIZE, IPC_CREAT | 0660); shmid4 = shmget(k4, sizeof ( int ) * 1, IPC_CREAT | 0660); if (shmid1 < 0 || shmid2 < 0 || shmid3 < 0 || shmid4 < 0) { perror ( ""Main shmget error: "" ); exit (1); } SHM3 = ( int *)shmat(shmid3, NULL, 0); int ix = 0; while (ix < BSIZE) SHM3[ix++] = 0; struct timeval t; time_t t1, t2; gettimeofday(&t, NULL); t1 = t.tv_sec; int * state = ( int *)shmat(shmid4, NULL, 0); *state = 1; int wait_time; int i = 0; int j = 1; if (fork() == 0) { SHM1 = ( bool *)shmat(shmid1, NULL, 0); SHM2 = ( int *)shmat(shmid2, NULL, 0); SHM3 = ( int *)shmat(shmid3, NULL, 0); if (SHM1 == ( bool *)-1 || SHM2 == ( int *)-1 || SHM3 == ( int *)-1) { perror ( ""Producer shmat error: "" ); exit (1); } bool * flag = SHM1; int * turn = SHM2; int * buf = SHM3; int index = 0; while (*state == 1) { flag[j] = true ; printf ( ""Producer is ready now.



"" ); *turn = i; while (flag[i] == true && *turn == i) ; index = 0; while (index < BSIZE) { if (buf[index] == 0) { int tempo = myrand(BSIZE * 3); printf ( ""Job %d has been produced

"" , tempo); buf[index] = tempo; break ; } index++; } if (index == BSIZE) printf ( ""Buffer is full, nothing can be produced!!!

"" ); printf ( ""Buffer: "" ); index = 0; while (index < BSIZE) printf ( ""%d "" , buf[index++]); printf ( ""

"" ); flag[j] = false ; if (*state == 0) break ; wait_time = myrand(PWT); printf ( ""Producer will wait for %d seconds



"" , wait_time); sleep(wait_time); } exit (0); } if (fork() == 0) { SHM1 = ( bool *)shmat(shmid1, NULL, 0); SHM2 = ( int *)shmat(shmid2, NULL, 0); SHM3 = ( int *)shmat(shmid3, NULL, 0); if (SHM1 == ( bool *)-1 || SHM2 == ( int *)-1 || SHM3 == ( int *)-1) { perror ( ""Consumer shmat error:"" ); exit (1); } bool * flag = SHM1; int * turn = SHM2; int * buf = SHM3; int index = 0; flag[i] = false ; sleep(5); while (*state == 1) { flag[i] = true ; printf ( ""Consumer is ready now.



"" ); *turn = j; while (flag[j] == true && *turn == j) ; if (buf[0] != 0) { printf ( ""Job %d has been consumed

"" , buf[0]); buf[0] = 0; index = 1; while (index < BSIZE) { buf[index - 1] = buf[index]; index++; } buf[index - 1] = 0; } else printf ( ""Buffer is empty, nothing can be consumed!!!

"" ); printf ( ""Buffer: "" ); index = 0; while (index < BSIZE) printf ( ""%d "" , buf[index++]); printf ( ""

"" ); flag[i] = false ; if (*state == 0) break ; wait_time = myrand(CWT); printf ( ""Consumer will sleep for %d seconds



"" , wait_time); sleep(wait_time); } exit (0); } while (1) { gettimeofday(&t, NULL); t2 = t.tv_sec; if (t2 - t1 > RT) { *state = 0; break ; } } wait(); wait(); printf ( ""The clock ran out.

"" ); return 0; }

chevron_right filter_none

Output:

Producer is ready now. Job 9 has been produced Buffer: 9 0 0 0 0 0 0 0 Producer will wait for 1 seconds Producer is ready now. Job 8 has been produced Buffer: 9 8 0 0 0 0 0 0 Producer will wait for 2 seconds Producer is ready now. Job 13 has been produced Buffer: 9 8 13 0 0 0 0 0 Producer will wait for 1 seconds Producer is ready now. Job 23 has been produced Buffer: 9 8 13 23 0 0 0 0 Producer will wait for 1 seconds Consumer is ready now. Job 9 has been consumed Buffer: 8 13 23 0 0 0 0 0 Consumer will sleep for 9 seconds Producer is ready now. Job 15 has been produced Buffer: 8 13 23 15 0 0 0 0 Producer will wait for 1 seconds Producer is ready now. Job 13 has been produced Buffer: 8 13 23 15 13 0 0 0 Producer will wait for 1 seconds Producer is ready now. Job 11 has been produced Buffer: 8 13 23 15 13 11 0 0 Producer will wait for 1 seconds Producer is ready now. Job 22 has been produced Buffer: 8 13 23 15 13 11 22 0 Producer will wait for 2 seconds Producer is ready now. Job 23 has been produced Buffer: 8 13 23 15 13 11 22 23 Producer will wait for 1 seconds The clock ran out.

This article is contributed by Nabaneet Roy. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Akanksha_Rai"
62,"Prerequisite – Process Synchronization, Inter Process Communication

To obtain such a mutual exclusion, bounded waiting, and progress there have been several algorithms implemented, one of which is Dekker’s Algorithm. To understand the algorithm let’s understand the solution to the critical section problem first.

A process is generally represented as :

do { //entry section critical section //exit section remainder section } while (TRUE);

The solution to critical section problem must ensure following three conditions:

Mutual Exclusion Progress Bounded Waiting

One of solution for ensuring above all factors is Peterson’s solution.

Another one is Dekker’s Solution. Dekker’s algorithm was the first provably-correct solution to the critical section problem. It allows two threads to share a single-use resource without conflict, using only shared memory for communication. It avoids the strict alternation of a naïve turn-taking algorithm, and was one of the first mutual exclusion algorithms to be invented.

Although there are many versions of Dekker’s Solution, the final or 5th version is the one that satisfies all of the above conditions and is the most efficient of them all.

Note – Dekker’s Solution, mentioned here, ensures mutual exclusion between two processes only, it could be extended to more than two processes with the proper use of arrays and variables.

Algorithm – It requires both an array of Boolean values and an integer variable:

var flag: array [0..1] of boolean; turn: 0..1; repeat flag[i] := true; while flag[j] do if turn = j then begin flag[i] := false; while turn = j do no-op; flag[i] := true; end; critical section turn := j; flag[i] := false; remainder section until false;

First Version of Dekker’s Solution – The idea is to use common or shared thread number between processes and stop the other process from entering its critical section if the shared thread indicates the former one already running.

filter_none edit

close play_arrow link

brightness_4

code Main() { int thread_number = 1; startThreads(); } Thread1() { do { while (threadnumber == 2) ; threadnumber = 2; } while (completed == false ) } Thread2() { do { while (threadnumber == 1) ; threadnumber = 1; } while (completed == false ) } chevron_right filter_none

The problem arising in the above implementation is lockstep synchronization, i.e each thread depends on the other for its execution. If one of the processes completes, then the second process runs, gives access to the completed one and waits for its turn, however, the former process is already completed and would never run to return the access back to the latter one. Hence, the second process waits infinitely then.

Second Version of Dekker’s Solution – To remove lockstep synchronization, it uses two flags to indicate its current status and updates them accordingly at the entry and exit section.

filter_none edit

close play_arrow link

brightness_4

code Main() { boolean thread1 = false ; boolean thread2 = false ; startThreads(); } Thread1() { do { while (thread2 == true ) ; thread1 = true ; thread1 = false ; } while (completed == false ) } Thread2() { do { while (thread1 == true ) ; thread2 = true ; thread2 = false ; } while (completed == false ) } chevron_right filter_none

The problem arising in the above version is mutual exclusion itself. If threads are preempted (stopped) during flag updation ( i.e during current_thread = true ) then, both the threads enter their critical section once the preempted thread is restarted, also the same can be observed at the start itself, when both the flags are false.

Third Version of Dekker’s Solution – To re-ensure mutual exclusion, it sets the flags before entry section itself.

filter_none edit

close play_arrow link

brightness_4

code Main() { boolean thread1wantstoenter = false ; boolean thread2wantstoenter = false ; startThreads(); } Thread1() { do { thread1wantstoenter = true ; while (thread2wantstoenter == true ) ; thread1wantstoenter = false ; } while (completed == false ) } Thread2() { do { thread2wantstoenter = true ; while (thread1wantstoenter == true ) ; thread2wantstoenter = false ; } while (completed == false ) } chevron_right filter_none

The problem with this version is deadlock possibility. Both threads could set their flag as true simultaneously and both will wait infinitely later on.

Fourth Version of Dekker’s Solution – Uses small time interval to recheck the condition, eliminates deadlock and ensures mutual exclusion as well.

filter_none edit

close play_arrow link

brightness_4

code Main() { boolean thread1wantstoenter = false ; boolean thread2wantstoenter = false ; startThreads(); } Thread1() { do { thread1wantstoenter = true ; while (thread2wantstoenter == true ) { thread1wantstoenter = false ; thread1wantstoenter = true ; } thread1wantstoenter = false ; } while (completed == false ) } Thread2() { do { thread2wantstoenter = true ; while (thread1wantstoenter == true ) { thread2wantstoenter = false ; thread2wantstoenter = true ; } thread2wantstoenter = false ; } while (completed == false ) } chevron_right filter_none

The problem with this version is the indefinite postponement. Also, random amount of time is erratic depending upon the situation in which the algorithm is being implemented, hence not an acceptable solution in business critical systems.

Dekker’s Algorithm : Final and completed Solution – -Idea is to use favoured thread notion to determine entry to the critical section. Favoured thread alternates between the thread providing mutual exclusion and avoiding deadlock, indefinite postponement or lockstep synchronization.

filter_none edit

close play_arrow link

brightness_4

code Main() { int favouredthread = 1; boolean thread1wantstoenter = false ; boolean thread2wantstoenter = false ; startThreads(); } Thread1() { do { thread1wantstoenter = true ; while (thread2wantstoenter == true ) { if (favaouredthread == 2) { thread1wantstoenter = false ; while (favouredthread == 2) ; thread1wantstoenter = true ; } } favouredthread = 2; thread1wantstoenter = false ; } while (completed == false ) } Thread2() { do { thread2wantstoenter = true ; while (thread1wantstoenter == true ) { if (favaouredthread == 1) { thread2wantstoenter = false ; while (favouredthread == 1) ; thread2wantstoenter = true ; } } favouredthread = 1; thread2wantstoenter = false ; } while (completed == false ) } chevron_right filter_none

This version guarantees a complete solution to the critical solution problem.

References –

Dekker’s Algorithm -csisdmz.ul.ie

Dekker’s algorithm – Wikipedia

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
63,"Prerequisite – Critical Section, Process Synchronization, Inter Process Communication

The Bakery algorithm is one of the simplest known solutions to the mutual exclusion problem for the general case of N process. Bakery Algorithm is a critical section solution for N processes. The algorithm preserves the first come first serve property.

Before entering its critical section, the process receives a number. Holder of the smallest number enters the critical section.

If processes Pi and Pj receive the same number, if i < j Pi is served first; else Pj is served first.

The numbering scheme always generates numbers in increasing order of enumeration; i.e., 1, 2, 3, 3, 3, 3, 4, 5, …

Notation – lexicographical order (ticket #, process id #) – Firstly the ticket number is compared. If same then the process ID is compared next, i.e.-

– (a, b) < (c, d) if a < c or if a = c and b < d – max(a [0], . . ., a [n-1]) is a number, k, such that k >= a[i] for i = 0, . . ., n - 1

Shared data – choosing is an array [0..n – 1] of boolean values; & number is an array [0..n – 1] of integer values. Both are initialized to False & Zero respectively.

Algorithm Pseudocode –

repeat choosing[i] := true; number[i] := max(number[0], number[1], ..., number[n - 1])+1; choosing[i] := false; for j := 0 to n - 1 do begin while choosing[j] do no-op; while number[j] != 0 and (number[j], j) < (number[i], i) do no-op; end; critical section number[i] := 0; remainder section until false;

Explanation –

Firstly the process sets its “choosing” variable to be TRUE indicating its intent to enter critical section. Then it gets assigned the highest ticket number corresponding to other processes. Then the “choosing” variable is set to FALSE indicating that it now has a new ticket number. This is in-fact the most important and confusing part of the algorithm.

It is actually a small critical section in itself ! The very purpose of the first three lines is that if a process is modifying its TICKET value then at that time some other process should not be allowed to check its old ticket value which is now obsolete. This is why inside the for loop before checking ticket value we first make sure that all other processes have the “choosing” variable as FALSE.

After that we proceed to check the ticket values of processes where process with least ticket number/process id gets inside the critical section. The exit section just resets the ticket value to zero.

Code – Here’s the C code implementation of the Bakery Algorithm. Run the following in a UNIX environment –

filter_none edit

close play_arrow link

brightness_4

code #include ""pthread.h"" #include ""stdio.h"" #include ""unistd.h"" #include ""string.h"" #define MEMBAR __sync_synchronize() #define THREAD_COUNT 8 volatile int tickets[THREAD_COUNT]; volatile int choosing[THREAD_COUNT]; volatile int resource; void lock( int thread ) { choosing[ thread ] = 1; MEMBAR; int max_ticket = 0; for ( int i = 0; i < THREAD_COUNT; ++i) { int ticket = tickets[i]; max_ticket = ticket > max_ticket ? ticket : max_ticket; } tickets[ thread ] = max_ticket + 1; MEMBAR; choosing[ thread ] = 0; MEMBAR; for ( int other = 0; other < THREAD_COUNT; ++other) { while (choosing[other]) { } MEMBAR; while (tickets[other] != 0 && (tickets[other] < tickets[ thread ] || (tickets[other] == tickets[ thread ] && other < thread ))) { } } } void unlock( int thread ) { MEMBAR; tickets[ thread ] = 0; } void use_resource( int thread ) { if (resource != 0) { printf ( ""Resource was acquired by %d, but is still in-use by %d!

"" , thread , resource); } resource = thread ; printf ( ""%d using resource...

"" , thread ); MEMBAR; sleep(2); resource = 0; } void * thread_body( void * arg) { long thread = ( long )arg; lock( thread ); use_resource( thread ); unlock( thread ); return NULL; } int main( int argc, char ** argv) { memset (( void *)tickets, 0, sizeof (tickets)); memset (( void *)choosing, 0, sizeof (choosing)); resource = 0; pthread_t threads[THREAD_COUNT]; for ( int i = 0; i < THREAD_COUNT; ++i) { pthread_create(&threads[i], NULL, &thread_body, ( void *)(( long )i)); } for ( int i = 0; i < THREAD_COUNT; ++i) { pthread_join(threads[i], NULL); } return 0; } chevron_right filter_none

Output:



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Siddhant-Bajaj Interested in everything CS/IT Aspire with my Acer Aspire R11 to crack GATE2019 Avid Follower of Ravindrababu Ravula Trying my best to keep right up my alley with competitive coding Open Source and Web Development Projects I am somewhat good at Chess and spend loads of time on geeksforgeeks"
64,"Prerequisite – Semaphores in operating system, Inter Process Communication

Producer consumer problem is a classical synchronization problem. We can solve this problem by using semaphores.

A semaphore S is an integer variable that can be accessed only through two standard operations : wait() and signal().

The wait() operation reduces the value of semaphore by 1 and the signal() operation increases its value by 1.

wait(S){ while(S<=0); // busy waiting S--; } signal(S){ S++; }

Semaphores are of two types:

Binary Semaphore – This is similar to mutex lock but not the same thing. It can have only two values – 0 and 1. Its value is initialized to 1. It is used to implement the solution of critical section problem with multiple processes. Counting Semaphore – Its value can range over an unrestricted domain. It is used to control access to a resource that has multiple instances.

Problem Statement – We have a buffer of fixed size. A producer can produce an item and can place in the buffer. A consumer can pick items and can consume them. We need to ensure that when a producer is placing an item in the buffer, then at the same time consumer should not consume any item. In this problem, buffer is the critical section.

To solve this problem, we need two counting semaphores – Full and Empty. “Full” keeps track of number of items in the buffer at any given time and “Empty” keeps track of number of unoccupied slots.

Initialization of semaphores –

mutex = 1

Full = 0 // Initially, all slots are empty. Thus full slots are 0

Empty = n // All slots are empty initially

Solution for Producer –

do{ //produce an item wait(empty); wait(mutex); //place in buffer signal(mutex); signal(full); }while(true)

When producer produces an item then the value of “empty” is reduced by 1 because one slot will be filled now. The value of mutex is also reduced to prevent consumer to access the buffer. Now, the producer has placed the item and thus the value of “full” is increased by 1. The value of mutex is also increased by 1 beacuse the task of producer has been completed and consumer can access the buffer.

Solution for Consumer –

do{ wait(full); wait(mutex); // remove item from buffer signal(mutex); signal(empty); // consumes item }while(true)

As the consumer is removing an item from buffer, therefore the value of “full” is reduced by 1 and the value is mutex is also reduced so that the producer cannot access the buffer at this moment. Now, the consumer has consumed the item, thus increasing the value of “empty” by 1. The value of mutex is also increased so that producer can access the buffer now.

See for implementation – Producer-Consumer solution using Semaphores in Java | Set 2

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ShikhinDahikar"
65,"Prerequisite – Process Synchronization, Semaphores, Dining-Philosophers Solution Using Monitors

The Dining Philosopher Problem – The Dining Philosopher Problem states that K philosophers seated around a circular table with one chopstick between each pair of philosophers. There is one chopstick between each philosopher. A philosopher may eat if he can pickup the two chopsticks adjacent to him. One chopstick may be picked up by any one of its adjacent followers but not both.

Semaphore Solution to Dining Philosopher –

Each philosopher is represented by the following pseudocode:

process P[i] while true do { THINK; PICKUP(CHOPSTICK[i], CHOPSTICK[i+1 mod 5]); EAT; PUTDOWN(CHOPSTICK[i], CHOPSTICK[i+1 mod 5]) }

There are three states of philosopher : THINKING, HUNGRY and EATING. Here there are two semaphores : Mutex and a semaphore array for the philosophers. Mutex is used such that no two philosophers may access the pickup or putdown at the same time. The array is used to control the behavior of each philosopher. But, semaphores can result in deadlock due to programming errors.

Code –

filter_none edit

close play_arrow link

brightness_4

code #include <pthread.h> #include <semaphore.h> #include <stdio.h> #define N 5 #define THINKING 2 #define HUNGRY 1 #define EATING 0 #define LEFT (phnum + 4) % N #define RIGHT (phnum + 1) % N int state[N]; int phil[N] = { 0, 1, 2, 3, 4 }; sem_t mutex; sem_t S[N]; void test( int phnum) { if (state[phnum] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) { state[phnum] = EATING; sleep(2); printf ( ""Philosopher %d takes fork %d and %d

"" , phnum + 1, LEFT + 1, phnum + 1); printf ( ""Philosopher %d is Eating

"" , phnum + 1); sem_post(&S[phnum]); } } void take_fork( int phnum) { sem_wait(&mutex); state[phnum] = HUNGRY; printf ( ""Philosopher %d is Hungry

"" , phnum + 1); test(phnum); sem_post(&mutex); sem_wait(&S[phnum]); sleep(1); } void put_fork( int phnum) { sem_wait(&mutex); state[phnum] = THINKING; printf ( ""Philosopher %d putting fork %d and %d down

"" , phnum + 1, LEFT + 1, phnum + 1); printf ( ""Philosopher %d is thinking

"" , phnum + 1); test(LEFT); test(RIGHT); sem_post(&mutex); } void * philospher( void * num) { while (1) { int * i = num; sleep(1); take_fork(*i); sleep(0); put_fork(*i); } } int main() { int i; pthread_t thread_id[N]; sem_init(&mutex, 0, 1); for (i = 0; i < N; i++) sem_init(&S[i], 0, 0); for (i = 0; i < N; i++) { pthread_create(&thread_id[i], NULL, philospher, &phil[i]); printf ( ""Philosopher %d is thinking

"" , i + 1); } for (i = 0; i < N; i++) pthread_join(thread_id[i], NULL); } chevron_right filter_none

Note – The below program may compile only with C compilers with semaphore and pthread library.

References –

Solution of Dining Philosophers – cs.gordon.edu

Solution of Dining Philosophers – cs.indiana.edu

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ssatyanand7"
66,"Prerequisite: Monitor, Process Synchronization

Dining-Philosophers Problem – N philosophers seated around a circular table

There is one chopstick between each philosopher

A philosopher must pick up its two nearest chopsticks in order to eat

A philosopher must pick up first one chopstick, then the second one, not both at once

We need an algorithm for allocating these limited resources(chopsticks) among several processes(philosophers) such that solution is free from deadlock and free from starvation.

There exist some algorithm to solve Dining – Philosopher Problem, but they may have deadlock situation. Also, a deadlock-free solution is not necessarily starvation-free. Semaphores can result in deadlock due to programming errors. Monitors alone are not sufficiency to solve this, we need monitors with condition variables

Monitor-based Solution to Dining Philosophers

We illustrate monitor concepts by presenting a deadlock-free solution to the dining-philosophers problem. Monitor is used to control access to state variables and condition variables. It only tells when to enter and exit the segment. This solution imposes the restriction that a philosopher may pick up her chopsticks only if both of them are available.

To code this solution, we need to distinguish among three states in which we may find a philosopher. For this purpose, we introduce the following data structure:

THINKING – When philosopher doesn’t want to gain access to either fork.

HUNGRY – When philosopher wants to enter the critical section.

EATING – When philosopher has got both the forks, i.e., he has entered the section.

Philosopher i can set the variable state[i] = EATING only if her two neighbors are not eating

(state[(i+4) % 5] != EATING) and (state[(i+1) % 5] != EATING).

filter_none edit

close play_arrow link

brightness_4

code monitor DP { status state[5]; condition self[5]; Pickup( int i) { state[i] = hungry; test(i); if (state[i] != eating) self[i].wait; } Putdown( int i) { state[i] = thinking; test((i + 1) % 5); test((i + 4) % 5); } test( int i) { if (state[(i + 1) % 5] != eating && state[(i + 4) % 5] != eating && state[i] == hungry) { state[i] = eating; self[i]. signal (); } } init() { for i = 0 to 4 state[i] = thinking; } } chevron_right filter_none

Above Program is a monitor solution to the dining-philosopher problem.

We also need to declare

condition self[5];

This allows philosopher i to delay herself when she is hungry but is unable to obtain the chopsticks she needs. We are now in a position to describe our solution to the dining-philosophers problem. The distribution of the chopsticks is controlled by the monitor Dining Philosophers. Each philosopher, before starting to eat, must invoke the operation pickup(). This act may result in the suspension of the philosopher process. After the successful completion of the operation, the philosopher may eat. Following this, the philosopher invokes the putdown() operation. Thus, philosopher i must invoke the operations pickup() and putdown() in the following sequence:

DiningPhilosophers.pickup(i); ... eat ... DiningPhilosophers.putdown(i);

It is easy to show that this solution ensures that no two neighbors are eating simultaneously and that no deadlocks will occur. We note, however, that it is possible for a philosopher to starve to death.

This article is contributed by Mayank Rana. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Palak Jain 5"
67,"Consider a situation where we have a file shared between many people.

If one of the people tries editing the file, no other person should be reading or writing at the same time, otherwise changes will not be visible to him/her.

However if some person is reading the file, then others may read it at the same time.

Precisely in OS we call this situation as the readers-writers problem

Problem parameters:

One set of data is shared among a number of processes

Once a writer is ready, it performs its write. Only one writer may write at a time

If a process is writing, no other process can read it

If at least one reader is reading, no other process can write

Readers may not write and only read

Solution when Reader has the Priority over Writer

Here priority means, no reader should wait if the share is currently opened for reading.

Three variables are used: mutex, wrt, readcnt to implement solution

semaphore mutex, wrt; // semaphore mutex is used to ensure mutual exclusion when readcnt is updated i.e. when any reader enters or exit from the critical section and semaphore wrt is used by both readers and writers int readcnt; // readcnt tells the number of processes performing read in the critical section, initially 0

Functions for sempahore :

– wait() : decrements the semaphore value.

– signal() : increments the semaphore value.

Writer process:

Writer requests the entry to critical section. If allowed i.e. wait() gives a true value, it enters and performs the write. If not allowed, it keeps on waiting. It exits the critical section.

do { // writer requests for critical section wait(wrt); // performs the write // leaves the critical section signal(wrt); } while(true);

Reader process:

Reader requests the entry to critical section. If allowed: it increments the count of number of readers inside the critical section. If this reader is the first reader entering, it locks the wrt semaphore to restrict the entry of writers if any reader is inside.

semaphore to restrict the entry of writers if any reader is inside. It then, signals mutex as any other reader is allowed to enter while others are already reading.

After performing reading, it exits the critical section. When exiting, it checks if no more reader is inside, it signals the semaphore “wrt” as now, writer can enter the critical section. If not allowed, it keeps on waiting.

do { // Reader wants to enter the critical section wait(mutex); // The number of readers has now increased by 1 readcnt++; // there is atleast one reader in the critical section // this ensure no writer can enter if there is even one reader // thus we give preference to readers here if (readcnt==1) wait(wrt); // other readers can enter while this current reader is inside // the critical section signal(mutex); // current reader performs reading here wait(mutex); // a reader wants to leave readcnt--; // that is, no reader is left in the critical section, if (readcnt == 0) signal(wrt); // writers can enter signal(mutex); // reader leaves } while(true);

Thus, the semaphore ‘wrt‘ is queued on both readers and writers in a manner such that preference is given to readers if writers are also there. Thus, no reader is waiting simply because a writer has requested to enter the critical section.

Article contributed by Ekta Goel. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Ankit Kumar Singh 2"
68,"Prerequisite – Process Synchronization, Monitors, Readers-Writers Problem

Considering a shared Database our objectives are:

Readers can access database only when there are no writers.

Writers can access database only when there are no readers or writers.

Only one thread can manipulate the state variables at a time.

Basic structure of a solution –

Reader() Wait until no writers Access database Check out – wake up a waiting writer Writer() Wait until no active readers or writers Access database Check out – wake up waiting readers or writer

–Now let’s suppose that a writer is active and a mixture of readers and writers now show up.

Who should get in next?

–Or suppose that a writer is waiting and an endless of stream of readers keep showing up.

Would it be fair for them to become active?

So we’ll implement a kind of back-and-forth form of fairness:



Once a reader is waiting, readers will get in next.

If a writer is waiting, one writer will get in next.



Implementation of the solution using monitors:-

The methods should be executed with mutual exclusion i.e. At each point in time, at most one thread may be executing any of its methods. Monitors also provide a mechanism for threads to temporarily give up exclusive access, in order to wait for some condition to be met, before regaining exclusive access and resuming their task. Monitors also have a mechanism for signaling other threads that such conditions have been met. So in this implementation only mutual exclusion is not enough. Threads attempting an operation may need to wait until some assertion P holds true. While a thread is waiting upon a condition variable, that thread is not considered to occupy the monitor, and so other threads may enter the monitor to change the monitor’s state.

Code –

filter_none edit

close play_arrow link

brightness_4

code int NReaders = 0; int WaitingReaders = 0; int NWriters = 0; int WaitingWriters = 0; Condition canRead = NULL; Condition canWrite = NULL; Void BeginWrite() { if (NWriters == 1 || NReaders > 0) { ++WaitingWriters; wait(CanWrite); --WaitingWriters; } NWriters = 1; } Void EndWrite() { NWriters = 0; if (WaitingReaders) Signal(CanRead); else Signal(CanWrite); } Void BeginRead() { if (NWriters == 1 || WaitingWriters > 0) { ++WaitingReaders; Wait(CanRead); --WaitingReaders; } ++NReaders; Signal(CanRead); } Void EndRead() { if (--NReaders == 0) Signal(CanWrite); } chevron_right filter_none

Understanding the solution:-

It wants to be fair.

If a writer is waiting, readers queue up. If a reader (or another writer) is active or waiting, writers queue up. This is mostly fair, although once it lets a reader in, it lets ALL waiting readers in all at once, even if some showed up “after” other waiting writers.





The code is “simplified” because we know there can only be one writer at a time.





It also takes advantage of the fact that signal is a no-op if nobody is waiting.

In the “EndWrite” code (it signals CanWrite without checking for waiting writers) In the EndRead code (same thing) In StartRead (signals CanRead at the end)

With Semaphores we never did have a “fair” solution of this sort. In fact it can be done but the code is quite tricky. Here the straightforward solution works in the desired way! Monitors are less error-prone and also easier to understand.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Siddhant-Bajaj Interested in everything CS/IT Aspire with my Acer Aspire R11 to crack GATE2019 Avid Follower of Ravindrababu Ravula Trying my best to keep right up my alley with competitive coding Open Source and Web Development Projects I am somewhat good at Chess and spend loads of time on geeksforgeeks"
69,"Prerequisite – Inter Process Communication

Problem : The analogy is based upon a hypothetical barber shop with one barber. There is a barber shop which has one barber, one barber chair, and n chairs for waiting for customers if there are any to sit on the chair.

If there is no customer, then the barber sleeps in his own chair.

When a customer arrives, he has to wake up the barber.

If there are many customers and the barber is cutting a customer’s hair, then the remaining customers either wait if there are empty chairs in the waiting room or they leave if no chairs are empty.

Solution : The solution to this problem includes three semaphores.First is for the customer which counts the number of customers present in the waiting room (customer in the barber chair is not included because he is not waiting). Second, the barber 0 or 1 is used to tell whether the barber is idle or is working, And the third mutex is used to provide the mutual exclusion which is required for the process to execute. In the solution, the customer has the record of the number of customers waiting in the waiting room if the number of customers is equal to the number of chairs in the waiting room then the upcoming customer leaves the barbershop.

When the barber shows up in the morning, he executes the procedure barber, causing him to block on the semaphore customers because it is initially 0. Then the barber goes to sleep until the first customer comes up.

When a customer arrives, he executes customer procedure the customer acquires the mutex for entering the critical region, if another customer enters thereafter, the second one will not be able to anything until the first one has released the mutex. The customer then checks the chairs in the waiting room if waiting customers are less then the number of chairs then he sits otherwise he leaves and releases the mutex.

If the chair is available then customer sits in the waiting room and increments the variable waiting value and also increases the customer’s semaphore this wakes up the barber if he is sleeping.

At this point, customer and barber are both awake and the barber is ready to give that person a haircut. When the haircut is over, the customer exits the procedure and if there are no customers in waiting room barber sleeps.

Algorithm for Sleeping Barber problem:

filter_none edit

close play_arrow link

brightness_4

code Semaphore Customers = 0; Semaphore Barber = 0; Mutex Seats = 1; int FreeSeats = N; Barber { while ( true ) { down(Customers); down(Seats); FreeSeats++; up(Barber); up(Seats); } } Customer { while ( true ) { down(Seats); if (FreeSeats > 0) { FreeSeats--; up(Customers); up(Seats); down(Barber); } else { up(Seats); } } } chevron_right filter_none

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : Kumar Shubham 10"
70,"Prerequisites – Process Synchronization

A lock variable provides the simplest synchronization mechanism for processes. Some noteworthy points regarding Lock Variables are-

Its a software mechanism implemented in user mode, i.e. no support required from the Operating System. Its a busy waiting solution (keeps the CPU busy even when its technically waiting). It can be used for more than two processes.

When Lock = 0 implies critical section is vacant (initial value ) and Lock = 1 implies critical section occupied.

The pseudocode looks something like this –

Entry section - while(lock != 0); Lock = 1; //critical section Exit section - Lock = 0;

A more formal approach to the Lock Variable method for process synchronization can be seen in the following code snippet :

filter_none edit

close play_arrow link

brightness_4

code char buffer[SIZE]; int count = 0, start = 0, end = 0; struct lock l; lock_init(&l); void put( char c) { lock_acquire(&l); while (count == SIZE) { lock_release(&l); lock_acquire(&l); } count++; buffer[start] = c; start++; if (start == SIZE) { start = 0; } lock_release(&l); } char get() { char c; lock_acquire(&l); while (count == 0) { lock_release(&l); lock_acquire(&l); } count--; c = buffer[end]; end++; if (end == SIZE) { end = 0; } lock_release(&l); return c; } chevron_right filter_none

Here we can see a classic implementation of the reader-writer’s problem. The buffer here is the shared memory and many processes are either trying to read or write a character to it. To prevent any ambiguity of data we restrict concurrent access by using a lock variable. We have also applied a constraint on the number of readers/writers that can have access.

Now every Synchronization mechanism is judged on the basis of three primary parameters :

Mutual Exclusion. Progress. Bounded Waiting.

Of which mutual exclusion is the most important of all parameters. The Lock Variable doesn’t provide mutual exclusion in some cases. This fact can be best verified by writing its pseudo-code in the form of an assembly language code as given below.

1. Load Lock, R0 ; (Store the value of Lock in Register R0.) 2. CMP R0, #0 ; (Compare the value of register R0 with 0.) 3. JNZ Step 1 ; (Jump to step 1 if value of R0 is not 0.) 4. Store #1, Lock ; (Set new value of Lock as 1.) Enter critical section 5. Store #0, Lock ; (Set the value of lock as 0 again.)

Now let’s suppose that processes P1 and P2 are competing for Critical Section and their sequence of execution be as follows (initial alue of Lock = 0) –

P1 executes statement 1 and gets pre-empted. P2 executes statement 1, 2, 3, 4 and enters Critical Section and gets pre-empted. P1 executes statement 2, 3, 4 and also enters Critical Section.

Here initially the R0 of process P1 stores lock value as 0 but fails to update the lock value as 1. So when P2 executes it also finds the LOCK value as 0 and enters Critical Section by setting LOCK value as 1. But the real problem arises when P1 executes again it doesn’t check the updated value of Lock. It only checks the previous value stored in R0 which was 0 and it enters critical section.

This is only one possible sequence of execution among many others. Some may even provide mutual exclusion but we cannot dwell on that. According to murphy’s law “Anything that can go wrong will go wrong“. So like all easy things the Lock Variable Synchronization method comes with its fair share of Demerits but its a good starting point for us to develop better Synchronization Algorithms to take care of the problems that we face here.

This article is contributed by Siddhant Bajaj 2. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
71,"Prerequisite : Multithreading in C

Thread synchronization is defined as a mechanism which ensures that two or more concurrent processes or threads do not simultaneously execute some particular program segment known as a critical section. Processes’ access to critical section is controlled by using synchronization techniques. When one thread starts executing the critical section (a serialized segment of the program) the other thread should wait until the first thread finishes. If proper synchronization techniques are not applied, it may cause a race condition where the values of variables may be unpredictable and vary depending on the timings of context switches of the processes or threads.

Thread Synchronization Problems

An example code to study synchronization problems :

filter_none edit

close play_arrow link

brightness_4

code #include <pthread.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> pthread_t tid[2]; int counter; void * trythis( void * arg) { unsigned long i = 0; counter += 1; printf ( ""

Job %d has started

"" , counter); for (i = 0; i < (0xFFFFFFFF); i++) ; printf ( ""

Job %d has finished

"" , counter); return NULL; } int main( void ) { int i = 0; int error; while (i < 2) { error = pthread_create(&(tid[i]), NULL, &trythis, NULL); if (error != 0) printf ( ""

Thread can't be created : [%s]"" , strerror (error)); i++; } pthread_join(tid[0], NULL); pthread_join(tid[1], NULL); return 0; }

chevron_right filter_none

How to compile above program?

To compile a multithreaded program using gcc, we need to link it with the pthreads library. Following is the command used to compile the program.

gfg@ubuntu:~/$ gcc filename.c -lpthread

In this example, two threads(jobs) are created and in the start function of these threads, a counter is maintained to get the logs about job number which is started and when it is completed.

Output :

Job 1 has started Job 2 has started Job 2 has finished Job 2 has finished

Problem: From the last two logs, one can see that the log ‘Job 2 has finished’ is repeated twice while no log for ‘Job 1 has finished’ is seen.

Why it has occurred ?

On observing closely and visualizing the execution of the code, we can see that :

The log ‘Job 2 has started’ is printed just after ‘Job 1 has Started’ so it can easily be concluded that while thread 1 was processing the scheduler scheduled the thread 2.

If we take the above assumption true then the value of the ‘counter’ variable got incremented again before job 1 got finished.

So, when Job 1 actually got finished, then the wrong value of counter produced the log ‘Job 2 has finished’ followed by the ‘Job 2 has finished’ for the actual job 2 or vice versa as it is dependent on scheduler.

So we see that its not the repetitive log but the wrong value of the ‘counter’ variable that is the problem.

The actual problem was the usage of the variable ‘counter’ by a second thread when the first thread was using or about to use it.

In other words, we can say that lack of synchronization between the threads while using the shared resource ‘counter’ caused the problems or in one word we can say that this problem happened due to ‘Synchronization problem’ between two threads.

How to solve it ? The most popular way of achieving thread synchronization is by using Mutexes. Mutex A Mutex is a lock that we set before using a shared resource and release after using it.



When the lock is set, no other thread can access the locked region of code.



So we see that even if thread 2 is scheduled while thread 1 was not done accessing the shared resource and the code is locked by thread 1 using mutexes then thread 2 cannot even access that region of code.



So this ensures synchronized access of shared resources in the code. Working of a mutex

Suppose one thread has locked a region of code using mutex and is executing that piece of code. Now if scheduler decides to do a context switch, then all the other threads which are ready to execute the same region are unblocked. Only one of all the threads would make it to the execution but if this thread tries to execute the same region of code that is already locked then it will again go to sleep. Context switch will take place again and again but no thread would be able to execute the locked region of code until the mutex lock over it is released. Mutex lock will only be released by the thread who locked it. So this ensures that once a thread has locked a piece of code then no other thread can execute the same region until it is unlocked by the thread who locked it.

Hence, this system ensures synchronization among the threads while working on shared resources.

A mutex is initialized and then a lock is achieved by calling the following two functions : The first function initializes a mutex and through second function any critical region in the code can be locked.

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr) : Creates a mutex, referenced by mutex, with attributes specified by attr. If attr is NULL, the default mutex attribute (NONRECURSIVE) is used. Returned value

If successful, pthread_mutex_init() returns 0, and the state of the mutex becomes initialized and unlocked.

If unsuccessful, pthread_mutex_init() returns -1. int pthread_mutex_lock(pthread_mutex_t *mutex) : Locks a mutex object, which identifies a mutex. If the mutex is already locked by another thread, the thread waits for the mutex to become available. The thread that has locked a mutex becomes its current owner and remains the owner until the same thread has unlocked it. When the mutex has the attribute of recursive, the use of the lock may be different. When this kind of mutex is locked multiple times by the same thread, then a count is incremented and no waiting thread is posted. The owning thread must call pthread_mutex_unlock() the same number of times to decrement the count to zero. Returned value

If successful, pthread_mutex_lock() returns 0.

If unsuccessful, pthread_mutex_lock() returns -1.

The mutex can be unlocked and destroyed by calling following two functions :The first function releases the lock and the second function destroys the lock so that it cannot be used anywhere in future.

int pthread_mutex_unlock(pthread_mutex_t *mutex) : Releases a mutex object. If one or more threads are waiting to lock the mutex, pthread_mutex_unlock() causes one of those threads to return from pthread_mutex_lock() with the mutex object acquired. If no threads are waiting for the mutex, the mutex unlocks with no current owner. When the mutex has the attribute of recursive the use of the lock may be different. When this kind of mutex is locked multiple times by the same thread, then unlock will decrement the count and no waiting thread is posted to continue running with the lock. If the count is decremented to zero, then the mutex is released and if any thread is waiting for it is posted. Returned value

If successful, pthread_mutex_unlock() returns 0.

If unsuccessful, pthread_mutex_unlock() returns -1 int pthread_mutex_destroy(pthread_mutex_t *mutex) : Deletes a mutex object, which identifies a mutex. Mutexes are used to protect shared resources. mutex is set to an invalid value, but can be reinitialized using pthread_mutex_init(). Returned value

If successful, pthread_mutex_destroy() returns 0.

If unsuccessful, pthread_mutex_destroy() returns -1.



An example to show how mutexes are used for thread synchronization

filter_none edit

close play_arrow link

brightness_4

code #include <pthread.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> pthread_t tid[2]; int counter; pthread_mutex_t lock; void * trythis( void * arg) { pthread_mutex_lock(&lock); unsigned long i = 0; counter += 1; printf ( ""

Job %d has started

"" , counter); for (i = 0; i < (0xFFFFFFFF); i++) ; printf ( ""

Job %d has finished

"" , counter); pthread_mutex_unlock(&lock); return NULL; } int main( void ) { int i = 0; int error; if (pthread_mutex_init(&lock, NULL) != 0) { printf ( ""

mutex init has failed

"" ); return 1; } while (i < 2) { error = pthread_create(&(tid[i]), NULL, &trythis, NULL); if (error != 0) printf ( ""

Thread can't be created :[%s]"" , strerror (error)); i++; } pthread_join(tid[0], NULL); pthread_join(tid[1], NULL); pthread_mutex_destroy(&lock); return 0; }

chevron_right filter_none

In the above code:

A mutex is initialized in the beginning of the main function.

The same mutex is locked in the ‘trythis()’ function while using the shared resource ‘counter’.

At the end of the function ‘trythis()’ the same mutex is unlocked.

At the end of the main function when both the threads are done, the mutex is destroyed.

Output :

Job 1 started Job 1 finished Job 2 started Job 2 finished

So this time the start and finish logs of both the jobs are present. So thread synchronization took place by the use of Mutex.

References :

Synchronization (computer science)

Lock (computer science)

This article is contributed by Kishlay Verma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : shashibhusan, adenprior"
72,"Let us first put ‘priority inversion’ in the context of the Big Picture i.e. where does this come from.

In Operating System, one of the important concepts is Task Scheduling. There are several Scheduling methods such as First Come First Serve, Round Robin, Priority-based scheduling, etc. Each scheduling method has its pros and cons. As you might have guessed, Priority Inversion comes under Priority-based Scheduling. Basically, it’s a problem which arises sometimes when Priority-based scheduling is used by OS. In Priority-based scheduling, different tasks are given different priority so that higher priority tasks can intervene in lower priority tasks if possible.

So, in priority-based scheduling, if lower priority task (L) is running and if a higher priority task (H) also needs to run, the lower priority task (L) would be preempted by higher priority task (H). Now, suppose both lower and higher priority tasks need to share a common resource (say access to the same file or device) to achieve their respective work. In this case, since there are resource sharing and task synchronization is needed, several methods/techniques can be used for handling such scenarios. For sake of our topic on Priority Inversion, let us mention a synchronization method say mutex. Just to recap on the mutex, a task acquires mutex before entering critical section (CS) and releases mutex after exiting critical section (CS). While running in CS, task access this common resource. More details on this can be referred here. Now, say both L and H shares a common Critical Section (CS) i.e. the same mutex is needed for this CS.

Coming to our discussion of priority inversion, let us examine some scenarios.

1) L is running but not in CS; H needs to run; H preempts L; H starts running; H relinquishes or releases control; L resumes and starts running

2) L is running in CS; H needs to run but not in CS; H preempts L; H starts running; H relinquishes control; L resumes and starts running.

3) L is running in CS; H also needs to run in CS; H waits for L to come out of CS; L comes out of CS; H enters CS and starts running

Please note that the above scenarios don’t show the problem of any Priority Inversion (not even scenario 3). Basically, so long as lower priority task isn’t running in shared CS, higher priority task can preempt it. But if L is running in shared CS and H also needs to run in CS, H waits until L comes out of CS. The idea is that CS should be small enough so that it doesn’t result in H waiting for a long time while L was in CS. That’s why writing a CS code requires careful consideration. In any of the above scenarios, priority inversion (i.e. reversal of priority) didn’t occur because the tasks are running as per the design.

Now let us add another task of middle priority say M. Now the task priorities are in the order of L < M < H. In our example, M doesn’t share the same Critical Section (CS). In this case, the following sequence of task running would result in ‘Priority Inversion’ problem.

4) L is running in CS ; H also needs to run in CS ; H waits for L to come out of CS ; M interrupts L and starts running ; M runs till completion and relinquishes control ; L resumes and starts running till the end of CS ; H enters CS and starts running.

Note that neither L nor H share CS with M.

Here, we can see that running of M has delayed the running of both L and H. Precisely speaking, H is of higher priority and doesn’t share CS with M; but H had to wait for M. This is where Priority based scheduling didn’t work as expected because priorities of M and H got inverted in spite of not sharing any CS. This problem is called Priority Inversion. This is what the heck was Priority Inversion! In a system with priority based scheduling, higher priority tasks can face this problem and it can result in unexpected behavior/result. In general purpose OS, it can result in slower performance. In RTOS, it can result in more severe outcomes. The most famous ‘Priority Inversion’ problem was what happened at Mars Pathfinder.

If we have a problem, there has to be solution for this. For Priority Inversion as well, there’re different solutions such as Priority Inheritance, etc. This is going to be our next article 🙂

But for the inpatients, this can be referred for time being.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Akanksha_Rai"
73,"Both of these concepts come under Priority scheduling in Operating System. But are they same ?

In one line, Priority Inversion is a problem while Priority Inheritance is a solution. Literally, Priority Inversion means that priority of tasks get inverted and Priority Inheritance means that priority of tasks get inherited. Both of these phenomena happen in priority scheduling. Basically, in Priority Inversion, higher priority task (H) ends up waiting for middle priority task (M) when H is sharing critical section with lower priority task (L) and L is already in critical section. Effectively, H waiting for M results in inverted priority i.e. Priority Inversion. One of the solution for this problem is Priority Inheritance. In Priority Inheritance, when L is in critical section, L inherits priority of H at the time when H starts pending for critical section. By doing so, M doesn’t interrupt L and H doesn’t wait for M to finish. Please note that inheriting of priority is done temporarily i.e. L goes back to its old priority when L comes out of critical section.

More details on these can be found here.

Please do Like/Tweet/G+1 if you find the above useful. Also, please do leave us comment for further clarification or info. We would love to help and learn 🙂

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
74,"Prerequisite – Process Synchronization | Introduction, Critical Section, Semaphores

Process Synchronization is a technique which is used to coordinate the process that use shared Data. There are two types of Processes in an Operating Systems:-

Independent Process –

The process that does not affect or is affected by the other process while its execution then the process is called Independent Process. Example The process that does not share any shared variable, database, files, etc. Cooperating Process –

The process that affect or is affected by the other process while execution, is called a Cooperating Process. Example The process that share file, variable, database, etc are the Cooperating Process.

Process Synchronization is mainly used for Cooperating Process that shares the resources.Let us consider an example of

//racing condition image

It is the condition where several processes tries to access the resources and modify the shared data concurrently and outcome of the process depends on the particular order of execution that leads to data inconsistency, this condition is called Race Condition.This condition can be avoided using the technique called Synchronization or Process Synchronization, in which we allow only one process to enter and manipulates the shared data in Critical Section.

//diagram of the view of CS

This setup can be defined in various regions like:

Entry Section –

It is part of the process which decide the entry of a particular process in the Critical Section, out of many other processes.

It is part of the process which decide the entry of a particular process in the Critical Section, out of many other processes. Critical Section –

It is the part in which only one process is allowed to enter and modify the shared variable.This part of the process ensures that only no other process can access the resource of shared data.

It is the part in which only one process is allowed to enter and modify the shared variable.This part of the process ensures that only no other process can access the resource of shared data. Exit Section –

This process allows the other process that are waiting in the Entry Section, to enter into the Critical Sections. It checks that a process that after a process has finished execution in Critical Section can be removed through this Exit Section.

This process allows the other process that are waiting in the Entry Section, to enter into the Critical Sections. It checks that a process that after a process has finished execution in Critical Section can be removed through this Exit Section. Remainder Section –

The other parts of the Code other than Entry Section, Critical Section and Exit Section are known as Remainder Section.

Critical Section problems must satisfy these three requirements:

Mutual Exclusion –

It states that no other process is allowed to execute in the critical section if a process is executing in critical section. Progress –

When no process is in the critical section, then any process from outside that request for execution can enter in the critical section without any delay. Only those process can enter that have requested and have finite time to enter the process. Bounded Waiting –

An upper bound must exist on the number of times a process enters so that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted.

Process Synchronization are handled by two approaches:

Software Approach –

In Software Approach, Some specific Algorithm approach is used to maintain synchronization of the data. Like in Approach One or Approach Two, for a number of two process, a temporary variable like (turn) or boolean variable (flag) value is used to store the data. When the condition is True then the process in waiting State, known as Busy Waiting State. This does not satisfy all the Critical Section requirements. Another Software approach known as Peterson’s Solution is best for Synchronization. It uses two variables in the Entry Section so as to maintain consistency, like Flag (boolean variable) and Turn variable(storing the process states). It satisfy all the three Critical Section requirements. //Image of Peterson’s Algorithm Hardware Approach –

The Hardware Approach of synchronization can be done through Lock & Unlock technique.Locking part is done in the Entry Section, so that only one process is allowed to enter into the Critical Section, after it complete its execution, the process is moved to the Exit Section, where Unlock Operation is done so that another process in the Lock Section can repeat this process of Execution.This process is designed in such a way that all the three conditions of the Critical Sections are satisfied.



//Image of Lock

Using Interrupts –

These are easy to implement.When Interrupt are disabled then no other process is allowed to perform Context Switch operation that would allow only one process to enter into the Critical State.

//Image of Interrupts

Test_and_Set Operation –

This allows boolean value (True/False) as a hardware Synchronization, which is atomic in nature i.e no other interrupt is allowed to access.This is mainly used in Mutual Exclusion Application. Similar type operation can be achieved through Compare and Swap function. In this process, a variable is allowed to accessed in Critical Section while its lock operation is ON.Till then, the other process is in Busy Waiting State. Hence Critical Section Requirements are achieved.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

kartikeya shukla 1 Loves Coding##"
75,"Prerequisite – Inter Process Communication,

Inter-process communication (IPC) is set of interfaces, which is usually programmed in order for the programs to communicate between series of processes. This allows running programs concurrently in an Operating System. These are the methods in IPC:

Pipes (Same Process) –

This allows flow of data in one direction only. Analogous to simplex systems (Keyboard). Data from the output is usually buffered until input process receives it which must have a common origin. Names Pipes (Different Processes) –

This is a pipe with a specific name it can be used in processes that don’t have a shared common process origin. E.g. is FIFO where the details written to a pipe is first named. Message Queuing –

This allows messages to be passed between processes using either a single queue or several message queue. This is managed by system kernel these messages are coordinated using an API. Semaphores –

This is used in solving problems associated with synchronization and to avoid race condition. These are integer values which are greater than or equal to 0. Shared memory –

This allows the interchange of data through a defined area of memory. Semaphore values have to be obtained before data can get access to shared memory. Sockets –

This method is mostly used to communicate over a network between a client and a server. It allows for a standard connection which is computer and OS independent.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : shreyashagrawal"
76,"A process in operating systems uses different resources and uses resources in the following way.

1) Requests a resource

2) Use the resource

2) Releases the resource

Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting for another resource acquired by some other process.

Consider an example when two trains are coming toward each other on the same track and there is only one track, none of the trains can move once they are in front of each other. A similar situation occurs in operating systems when there are two or more processes that hold some resources and wait for resources held by other(s). For example, in the below diagram, Process 1 is holding Resource 1 and waiting for resource 2 which is acquired by process 2, and process 2 is waiting for resource 1.



Deadlock can arise if the following four conditions hold simultaneously (Necessary Conditions)

Mutual Exclusion: One or more than one resource are non-shareable (Only one process can use at a time)

Hold and Wait: A process is holding at least one resource and waiting for resources.

No Preemption: A resource cannot be taken from a process unless the process releases the resource.

Circular Wait: A set of processes are waiting for each other in circular form.

Methods for handling deadlock

There are three ways to handle deadlock

1) Deadlock prevention or avoidance: The idea is to not let the system into a deadlock state.

One can zoom into each category individually, Prevention is done by negating one of above mentioned necessary conditions for deadlock.

Avoidance is kind of futuristic in nature. By using strategy of “Avoidance”, we have to make an assumption. We need to ensure that all information about resources which process will need are known to us prior to execution of the process. We use Banker’s algorithm (Which is in-turn a gift from Dijkstra) in order to avoid deadlock.

2) Deadlock detection and recovery: Let deadlock occur, then do preemption to handle it once occurred.

3) Ignore the problem altogether: If deadlock is very rare, then let it happen and reboot the system. This is the approach that both Windows and UNIX take.

Exercise:

1) Suppose n processes, P1, …. Pn share m identical resource units, which can be reserved and released one at a time. The maximum resource requirement of process Pi is Si, where Si > 0. Which one of the following is a sufficient condition for ensuring that deadlock does not occur? (GATE CS 2005)



(A) A

(B) B

(C) C

(D) D

For solution, see Question 4 of https://www.geeksforgeeks.org/operating-systems-set-16/

See QUIZ ON DEADLOCK for more questions.

References:

http://www2.latech.edu/~box/os/ch07.pdf

http://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/7_Deadlocks.html

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : BJP_supporting_Leftist, rithesharjun"
77,"In the previous post, we have discussed Deadlock Prevention and Avoidance. In this post, Deadlock Detection and Recovery technique to handle deadlock is discussed.

Deadlock Detection

If resources have single instance:

In this case for Deadlock detection we can run an algorithm to check for cycle in the Resource Allocation Graph. Presence of cycle in the graph is the sufficient condition for deadlock.

In the above diagram, resource 1 and resource 2 have single instances. There is a cycle R1 → P1 → R2 → P2. So, Deadlock is Confirmed. If there are multiple instances of resources:

Detection of the cycle is necessary but not sufficient condition for deadlock detection, in this case, the system may or may not be in deadlock varies according to different situations.

Deadlock Recovery

A traditional operating system such as Windows doesn’t deal with deadlock recovery as it is time and space consuming process. Real-time operating systems use Deadlock recovery."
78,"Prerequisite – Deadlock and Starvation

Livelock occurs when two or more processes continually repeat the same interaction in response to changes in the other processes without doing any useful work. These processes are not in the waiting state, and they are running concurrently. This is different from a deadlock because in a deadlock all processes are in the waiting state.

Example:

Imagine a pair of processes using two resources, as shown:

filter_none edit

close play_arrow link

brightness_4

code void process_A( void ) { enter_reg(& resource_1); enter_reg(& resource_2); use_both_resources(); leave_reg(& resource_2); leave_reg(& resource_1); } void process_B( void ) { enter_reg(& resource_1); enter_reg(& resource_2); use_both_resources(); leave_reg(& resource_2); leave_reg(& resource_1); } chevron_right filter_none

Each of the two processes needs the two resources and they use the polling primitive enter_reg to try to acquire the locks necessary for them. In case the attempt fails, the process just tries again.

If process A runs first and acquires resource 1 and then process B runs and acquires resource 2, no matter which one runs next, it will make no further progress, but neither of the two processes blocks. What actually happens is that it uses up its CPU quantum over and over again without any progress being made but also without any sort of blocking. Thus this situation is not that of a deadlock( as no process is being blocked) but we have something functionally equivalent to deadlock: LIVELOCK.

What leads to Livelocks?

Occurrence of livelocks can occur in the most surprising of ways. The total number of allowed processes in some systems, is determined by the number of entries in the process table. Thus process table slots can be referred to as Finite Resources. If a fork fails because of the table being full, waiting a random time and trying again would be a reasonable approach for the program doing the fork.

Consider a UNIX system having 100 process slots. Ten programs are running, each of which having to create 12 (sub)processes. After each process has created 9 processes, the 10 original processes and the 90 new processes have exhausted the table. Each of the 10 original processes now sits in an endless loop forking and failing – which is aptly the situation of a deadlock. The probability of this happening is very little but it could happen.

Difference between Deadlock, Starvation, and Livelock:

A livelock is similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing. Livelock is a special case of resource starvation; the general definition only states that a specific process is not progressing.

Livelock:

filter_none edit

close play_arrow link

brightness_4

code var l1 = .... var l2 = .... Thread.Start( ()=> { while ( true ) { if (!l1.Lock(1000)) { continue ; } if (!l2.Lock(1000)) { continue ; } }); Thread.Start( ()=> { while ( true ) { if (!l2.Lock(1000)) { continue ; } if (!l1.Lock(1000)) { continue ; } }); chevron_right filter_none

Deadlock:

filter_none edit

close play_arrow link

brightness_4

code var p = new object(); lock(p) { lock(p) { } chevron_right filter_none

A deadlock is a state in which each member of a group of actions, is waiting for some other member to release a lock. A livelock on the other hand is almost similar to a deadlock, except that the states of the processes involved in a livelock constantly keep on changing with regard to one another, none progressing. Thus Livelock is a special case of resource starvation, as stated from the general definition, the process is not progressing.

Starvation:

Starvation is a problem which is closely related to both, Livelock and Deadlock. In a dynamic system, requests for resources keep on happening. Thereby, some policy is needed to make a decision about who gets the resource when. This process, being reasonable, may lead to a some processes never getting serviced even though they are not deadlocked.

filter_none edit

close play_arrow link

brightness_4

code Queue q = ..... while (q.Count & gt; 0) { var c = q.Dequeue(); ......... q.Enqueue(c); q.Enqueue(c); } chevron_right filter_none

Starvation happens when “greedy” threads make shared resources unavailable for long periods. For instance, suppose an object provides a synchronized method that often takes a long time to return. If one thread invokes this method frequently, other threads that also need frequent synchronized access to the same object will often be blocked.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
79,"Deadlock Characteristics

As discussed in the previous post, deadlock has following characteristics.

Mutual Exclusion Hold and Wait No preemption Circular wait

Deadlock Prevention

We can prevent Deadlock by eliminating any of the above four conditions.

Eliminate Mutual Exclusion

It is not possible to dis-satisfy the mutual exclusion because some resources, such as the tape drive and printer, are inherently non-shareable.

Eliminate Hold and wait

Allocate all required resources to the process before the start of its execution, this way hold and wait condition is eliminated but it will lead to low device utilization. for example, if a process requires printer at a later time and we have allocated printer before the start of its execution printer will remain blocked till it has completed its execution. The process will make a new request for resources after releasing the current set of resources. This solution may lead to starvation.

Eliminate No Preemption

Preempt resources from the process when resources required by other high priority processes.

Eliminate Circular Wait

Each resource will be assigned with a numerical number. A process can request the resources increasing/decreasing. order of numbering.

For Example, if P1 process is allocated R5 resources, now next time if P1 ask for R4, R3 lesser than R5 such request will not be granted, only request for resources more than R5 will be granted.

Deadlock Avoidance

Deadlock avoidance can be done with Banker’s Algorithm.

Banker’s Algorithm

Bankers’s Algorithm is resource allocation and deadlock avoidance algorithm which test all the request made by processes for resources, it checks for the safe state, if after granting request system remains in the safe state it allows the request and if there is no safe state it doesn’t allow the request made by the process.

Inputs to Banker’s Algorithm:

Max need of resources by each process. Currently allocated resources by each process. Max free available resources in the system.

The request will only be granted under the below condition:

If the request made by the process is less than equal to max need to that process. If the request made by the process is less than equal to the freely available resource in the system.

Example:

Total resources in system: A B C D 6 5 7 6

Available system resources are: A B C D 3 1 1 2

Processes (currently allocated resources): A B C D P1 1 2 2 1 P2 1 0 3 3 P3 1 2 1 0

Processes (maximum resources): A B C D P1 3 3 2 2 P2 1 2 3 4 P3 1 3 5 0

Need = maximum resources - currently allocated resources. Processes (need resources): A B C D P1 2 1 0 1 P2 0 2 0 1 P3 0 1 4 0

Note:Deadlock prevention is more strict that Deadlock Avoidance.

Following are Gate Previous Year Question

http://quiz.geeksforgeeks.org/gate-gate-cs-2014-set-1-question-41/

http://quiz.geeksforgeeks.org/gate-gate-cs-2014-set-3-question-41/

http://quiz.geeksforgeeks.org/gate-gate-cs-2010-question-46/

References

https://en.wikipedia.org/wiki/Banker’s_algorithm

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : VaibhavRai3"
80,"The banker’s algorithm is a resource allocation and deadlock avoidance algorithm that tests for safety by simulating the allocation for predetermined maximum possible amounts of all resources, then makes an “s-state” check to test for possible activities, before deciding whether allocation should be allowed to continue.

Why Banker’s algorithm is named so?

Banker’s algorithm is named so because it is used in banking system to check whether loan can be sanctioned to a person or not. Suppose there are n number of account holders in a bank and the total sum of their money is S. If a person applies for a loan then the bank first subtracts the loan amount from the total money that bank has and if the remaining amount is greater than S then only the loan is sanctioned. It is done because if all the account holders comes to withdraw their money then the bank can easily do it.

In other words, the bank would never allocate its money in such a way that it can no longer satisfy the needs of all its customers. The bank would try to be in safe state always.

Following Data structures are used to implement the Banker’s Algorithm:

Let ‘n’ be the number of processes in the system and ‘m’ be the number of resources types.

Available :

It is a 1-d array of size ‘m’ indicating the number of available resources of each type.

indicating the number of available resources of each type. Available[ j ] = k means there are ‘k’ instances of resource type R j

Max :

It is a 2-d array of size ‘ n*m’ that defines the maximum demand of each process in a system.

that defines the maximum demand of each process in a system. Max[ i, j ] = k means process P i may request at most ‘k’ instances of resource type R j.

Allocation :

It is a 2-d array of size ‘n*m’ that defines the number of resources of each type currently allocated to each process.

that defines the number of resources of each type currently allocated to each process. Allocation[ i, j ] = k means process P i is currently allocated ‘k’ instances of resource type R j

Need :

It is a 2-d array of size ‘n*m’ that indicates the remaining resource need of each process.

that indicates the remaining resource need of each process. Need [ i, j ] = k means process P i currently need ‘k’ instances of resource type R j

currently need instances of resource type for its execution. Need [ i, j ] = Max [ i, j ] – Allocation [ i, j ]

Allocation i specifies the resources currently allocated to process P i and Need i specifies the additional resources that process P i may still request to complete its task.

Banker’s algorithm consists of Safety algorithm and Resource request algorithm

Safety Algorithm

The algorithm for finding out whether or not a system is in a safe state can be described as follows:

1) Let Work and Finish be vectors of length ‘m’ and ‘n’ respectively.

Initialize: Work = Available

Finish[i] = false; for i=1, 2, 3, 4….n 2) Find an i such that both

a) Finish[i] = false

b) Need i <= Work

if no such i exists goto step (4) 3) Work = Work + Allocation[i]

Finish[i] = true

goto step (2) 4) if Finish [i] = true for all i

then the system is in a safe state

Resource-Request Algorithm

Let Request i be the request array for process P i . Request i [j] = k means process P i wants k instances of resource type R j . When a request for resources is made by process P i , the following actions are taken:

1) If Request i <= Need i

Goto step (2) ; otherwise, raise an error condition, since the process has exceeded its maximum claim. 2) If Request i <= Available

Goto step (3); otherwise, P i must wait, since the resources are not available. 3) Have the system pretend to have allocated the requested resources to process Pi by modifying the state as

follows:

Available = Available – Requesti

Allocation i = Allocation i + Request i

Need i = Need i – Request i





Example:

Considering a system with five processes P 0 through P 4 and three resources of type A, B, C. Resource type A has 10 instances, B has 5 instances and type C has 7 instances. Suppose at time t 0 following snapshot of the system has been taken:

Question1. What will be the content of the Need matrix?

Need [i, j] = Max [i, j] – Allocation [i, j]

So, the content of Need Matrix is:

Question2. Is the system in a safe state? If Yes, then what is the safe sequence?

Applying the Safety algorithm on the given system,

Question3. What will happen if process P 1 requests one additional instance of resource type A and two instances of resource type C?

We must determine whether this new system state is safe. To do so, we again execute Safety algorithm on the above data structures.

Hence the new system state is safe, so we can immediately grant the request for process P 1 .



Code for Banker’s Algorithm"
81,"As Banker’s algorithm using some kind of table like allocation, request, available all that thing to understand what is the state of the system. Similarly, if you want to understand the state of the system instead of using those table, actually tables are very easy to represent and understand it, but then still you could even represent the same information in the graph. That graph is called Resource Allocation Graph (RAG).

So, resource allocation graph is explained to us what is the state of the system in terms of processes and resources. Like how many resources are available, how many are allocated and what is the request of each process. Everything can be represented in terms of the diagram. One of the advantages of having a diagram is, sometimes it is possible to see a deadlock directly by using RAG, but then you might not be able to know that by looking at the table. But the tables are better if the system contains lots of process and resource and Graph is better if the system contains less number of process and resource.

We know that any graph contains vertices and edges. So RAG also contains vertices and edges. In RAG vertices are two type –

1. Process vertex – Every process will be represented as a process vertex.Generally, the process will be represented with a circle.

2. Resource vertex – Every resource will be represented as a resource vertex. It is also two type –

Single instance type resource – It represents as a box, inside the box, there will be one dot.So the number of dots indicate how many instances are present of each resource type.

It represents as a box, inside the box, there will be one dot.So the number of dots indicate how many instances are present of each resource type. Multi-resource instance type resource – It also represents as a box, inside the box, there will be many dots present.

Now coming to the edges of RAG.There are two types of edges in RAG –

1. Assign Edge – If you already assign a resource to a process then it is called Assign edge.

2. Request Edge – It means in future the process might want some resource to complete the execution, that is called request edge.

So, if a process is using a resource, an arrow is drawn from the resource node to the process node. If a process is requesting a resource, an arrow is drawn from the process node to the resource node.

Example 1 (Single instances RAG) –

If there is a cycle in the Resource Allocation Graph and each resource in the cycle provides only one instance, then the processes will be in deadlock. For example, if process P1 holds resource R1, process P2 holds resource R2 and process P1 is waiting for R2 and process P2 is waiting for R1, then process P1 and process P2 will be in deadlock.

Here’s another example, that shows Processes P1 and P2 acquiring resources R1 and R2 while process P3 is waiting to acquire both resources. In this example, there is no deadlock because there is no circular dependency.

So cycle in single-instance resource type is the sufficient condition for deadlock.

Example 2 (Multi-instances RAG) –

From the above example, it is not possible to say the RAG is in a safe state or in an unsafe state.So to see the state of this RAG, let’s construct the allocation matrix and request matrix.

The total number of processes are three; P1, P2 & P3 and the total number of resources are two; R1 & R2.

Allocation matrix – For constructing the allocation matrix, just go to the resources and see to which process it is allocated.

R1 is allocated to P1, therefore write 1 in allocation matrix and similarly, R2 is allocated to P2 as well as P3 and for the remaining element just write 0.

Request matrix – In order to find out the request matrix, you have to go to the process and see the outgoing edges.

P1 is requesting resource R2, so write 1 in the matrix and similarly, P2 requesting R1 and for the remaining element write 0. So now available resource is = (0, 0). Checking deadlock (safe or not) – So, there is no deadlock in this RAG.Even though there is a cycle, still there is no deadlock.Therefore in multi-instance resource cycle is not sufficient condition for deadlock. Above example is the same as the previous example except that, the process P3 requesting for resource R1.

So the table becomes as shown in below.



So,the Available resource is = (0, 0), but requirement are (0, 1), (1, 0) and (1, 0).So you can’t fulfill any one requirement.Therefore, it is in deadlock. Therefore, every cycle in a multi-instance resource type graph is not a deadlock, if there has to be a deadlock, there has to be a cycle.So, in case of RAG with multi-instance resource type, the cycle is a necessary condition for deadlock, but not sufficient.

GATE CS Corner Questions

Practicing the following questions will help you test your knowledge. All questions have been asked in GATE in previous years or in GATE Mock Tests. It is highly recommended that you practice them.

Reference –

A. Silberschatz, P. Galvin, G. Gagne, “Operating Systems Concepts (8th Edition)”, Wiley India Pvt. Ltd.

This article is contributed by Samit Mandal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
82,"The Operating System allocates resources when a program need them. When the program terminates, the resources are de-allocated, and allocated to other programs that need them. Now the question is, what strategy does the operating system use to allocate these resources to user programs?

There are two Resource allocation techniques:

Resource partitioning approach –

In this approach, the operating system decides beforehand, that what resources should be allocated to which user program. It divides the resources in the system to many resource partitions, where each partition may include various resources – for example, 1 MB memory, disk blocks, and a printer. Then, it allocates one resource partition to each user program before the program’s initiation. A resource table records the resource partition and its current allocation status (Allocated or Free). Advantages:



Easy to Implement

Less Overhead Disadvantages: Lacks flexibility – if a resource partition contains more resources than what a particular process requires, the additional resources are wasted.

if a resource partition contains more resources than what a particular process requires, the additional resources are wasted. If a program needs more resources than a single resource partition, it cannot execute (Though free resources are present in other partitions). An example resource table may look like: Pool based approach –

In this approach, there is a common pool of resources. The operating System checks the allocation status in the resource table whenever a program makes a request for a resource. If the resource is free, it allocates the resource to the program. Advantages: Allocated resources are not wasted.

Any resource requirement can be fulfilled if the resource is free (unlike Partitioning approach) Disadvantages: Overhead of allocating and de-allocating the resources on every request and release.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : Harshit kalal"
83,"Prerequisite: Banker’s Algorithm

The banker’s algorithm is a resource allocation and deadlock avoidance algorithm that tests for safety by simulating the allocation for predetermined maximum possible amounts of all resources, then makes an “s-state” check to test for possible activities, before deciding whether allocation should be allowed to continue.

Following Data structures are used to implement the Banker’s Algorithm:

Let ‘n’ be the number of processes in the system and ‘m’ be the number of resources types.

Available :

It is a 1-d array of size ‘m’ indicating the number of available resources of each type.

indicating the number of available resources of each type. Available[ j ] = k means there are ‘k’ instances of resource type R j

Max :

It is a 2-d array of size ‘ n*m’ that defines the maximum demand of each process in a system.

that defines the maximum demand of each process in a system. Max[ i, j ] = k means process P i may request at most ‘k’ instances of resource type R j.

Allocation :

It is a 2-d array of size ‘n*m’ that defines the number of resources of each type currently allocated to each process.

that defines the number of resources of each type currently allocated to each process. Allocation[ i, j ] = k means process P i is currently allocated ‘k’ instances of resource type R j

Need :

It is a 2-d array of size ‘n*m’ that indicates the remaining resource need of each process.

that indicates the remaining resource need of each process. Need [ i, j ] = k means process P i currently allocated ‘k’ instances of resource type R j

currently allocated instances of resource type Need [ i, j ] = Max [ i, j ] – Allocation [ i, j ]

Allocation i specifies the resources currently allocated to process P i and Need i specifies the additional resources that process P i may still request to complete its task.

Banker’s algorithm consist of Safety algorithm and Resource request algorithm

Safety Algorithm

The algorithm for finding out whether or not a system is in a safe state can be described as follows:

Let Work and Finish be vectors of length ‘m’ and ‘n’ respectively.

Initialize: Work= Available

Finish [i]=false; for i=1,2,……,n



Find an i such that both

a) Finish [i]=false

b) Need_i<=work



if no such i exists goto step (4) Work=Work + Allocation_i

Finish[i]= true

goto step(2) If Finish[i]=true for all i,

then the system is in safe state.

Safe sequence is the sequence in which the processes can be safely executed.

In this post, implementation of Safety algorithm of Banker’s Algorithm is done.

C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> using namespace std; const int P = 5; const int R = 3; void calculateNeed( int need[P][R], int maxm[P][R], int allot[P][R]) { for ( int i = 0 ; i < P ; i++) for ( int j = 0 ; j < R ; j++) need[i][j] = maxm[i][j] - allot[i][j]; } bool isSafe( int processes[], int avail[], int maxm[][R], int allot[][R]) { int need[P][R]; calculateNeed(need, maxm, allot); bool finish[P] = {0}; int safeSeq[P]; int work[R]; for ( int i = 0; i < R ; i++) work[i] = avail[i]; int count = 0; while (count < P) { bool found = false ; for ( int p = 0; p < P; p++) { if (finish[p] == 0) { int j; for (j = 0; j < R; j++) if (need[p][j] > work[j]) break ; if (j == R) { for ( int k = 0 ; k < R ; k++) work[k] += allot[p][k]; safeSeq[count++] = p; finish[p] = 1; found = true ; } } } if (found == false ) { cout << ""System is not in safe state"" ; return false ; } } cout << ""System is in safe state.

Safe"" "" sequence is: "" ; for ( int i = 0; i < P ; i++) cout << safeSeq[i] << "" "" ; return true ; } int main() { int processes[] = {0, 1, 2, 3, 4}; int avail[] = {3, 3, 2}; int maxm[][R] = {{7, 5, 3}, {3, 2, 2}, {9, 0, 2}, {2, 2, 2}, {4, 3, 3}}; int allot[][R] = {{0, 1, 0}, {2, 0, 0}, {3, 0, 2}, {2, 1, 1}, {0, 0, 2}}; isSafe(processes, avail, maxm, allot); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; class GFG { static int P = 5 ; static int R = 3 ; static void calculateNeed( int need[][], int maxm[][], int allot[][]) { for ( int i = 0 ; i < P ; i++) for ( int j = 0 ; j < R ; j++) need[i][j] = maxm[i][j] - allot[i][j]; } static boolean isSafe( int processes[], int avail[], int maxm[][], int allot[][]) { int [][]need = new int [P][R]; calculateNeed(need, maxm, allot); boolean []finish = new boolean [P]; int []safeSeq = new int [P]; int []work = new int [R]; for ( int i = 0 ; i < R ; i++) work[i] = avail[i]; int count = 0 ; while (count < P) { boolean found = false ; for ( int p = 0 ; p < P; p++) { if (finish[p] == false ) { int j; for (j = 0 ; j < R; j++) if (need[p][j] > work[j]) break ; if (j == R) { for ( int k = 0 ; k < R ; k++) work[k] += allot[p][k]; safeSeq[count++] = p; finish[p] = true ; found = true ; } } } if (found == false ) { System.out.print( ""System is not in safe state"" ); return false ; } } System.out.print( ""System is in safe state.

Safe"" + "" sequence is: "" ); for ( int i = 0 ; i < P ; i++) System.out.print(safeSeq[i] + "" "" ); return true ; } public static void main(String[] args) { int processes[] = { 0 , 1 , 2 , 3 , 4 }; int avail[] = { 3 , 3 , 2 }; int maxm[][] = {{ 7 , 5 , 3 }, { 3 , 2 , 2 }, { 9 , 0 , 2 }, { 2 , 2 , 2 }, { 4 , 3 , 3 }}; int allot[][] = {{ 0 , 1 , 0 }, { 2 , 0 , 0 }, { 3 , 0 , 2 }, { 2 , 1 , 1 }, { 0 , 0 , 2 }}; isSafe(processes, avail, maxm, allot); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code P = 5 R = 3 def calculateNeed(need, maxm, allot): for i in range (P): for j in range (R): need[i][j] = maxm[i][j] - allot[i][j] def isSafe(processes, avail, maxm, allot): need = [] for i in range (P): l = [] for j in range (R): l.append( 0 ) need.append(l) calculateNeed(need, maxm, allot) finish = [ 0 ] * P safeSeq = [ 0 ] * P work = [ 0 ] * R for i in range (R): work[i] = avail[i] count = 0 while (count < P): found = False for p in range (P): if (finish[p] = = 0 ): for j in range (R): if (need[p][j] > work[j]): break if (j = = R - 1 ): for k in range (R): work[k] + = allot[p][k] safeSeq[count] = p count + = 1 finish[p] = 1 found = True if (found = = False ): print ( ""System is not in safe state"" ) return False print ( ""System is in safe state."" , ""

Safe sequence is: "" , end = "" "" ) print ( * safeSeq) return True if __name__ = = ""__main__"" : processes = [ 0 , 1 , 2 , 3 , 4 ] avail = [ 3 , 3 , 2 ] maxm = [[ 7 , 5 , 3 ], [ 3 , 2 , 2 ], [ 9 , 0 , 2 ], [ 2 , 2 , 2 ], [ 4 , 3 , 3 ]] allot = [[ 0 , 1 , 0 ], [ 2 , 0 , 0 ], [ 3 , 0 , 2 ], [ 2 , 1 , 1 ], [ 0 , 0 , 2 ]] isSafe(processes, avail, maxm, allot) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; class GFG { static int P = 5; static int R = 3; static void calculateNeed( int [,]need, int [,]maxm, int [,]allot) { for ( int i = 0 ; i < P ; i++) for ( int j = 0 ; j < R ; j++) need[i,j] = maxm[i,j] - allot[i,j]; } static bool isSafe( int []processes, int []avail, int [,]maxm, int [,]allot) { int [,]need = new int [P,R]; calculateNeed(need, maxm, allot); bool []finish = new bool [P]; int []safeSeq = new int [P]; int []work = new int [R]; for ( int i = 0; i < R ; i++) work[i] = avail[i]; int count = 0; while (count < P) { bool found = false ; for ( int p = 0; p < P; p++) { if (finish[p] == false ) { int j; for (j = 0; j < R; j++) if (need[p,j] > work[j]) break ; if (j == R) { for ( int k = 0 ; k < R ; k++) work[k] += allot[p,k]; safeSeq[count++] = p; finish[p] = true ; found = true ; } } } if (found == false ) { Console.Write( ""System is not in safe state"" ); return false ; } } Console.Write( ""System is in safe state.

Safe"" + "" sequence is: "" ); for ( int i = 0; i < P ; i++) Console.Write(safeSeq[i] + "" "" ); return true ; } static public void Main () { int []processes = {0, 1, 2, 3, 4}; int []avail = {3, 3, 2}; int [,]maxm = {{7, 5, 3}, {3, 2, 2}, {9, 0, 2}, {2, 2, 2}, {4, 3, 3}}; int [,]allot = {{0, 1, 0}, {2, 0, 0}, {3, 0, 2}, {2, 1, 1}, {0, 0, 2}}; isSafe(processes, avail, maxm, allot); } } chevron_right filter_none

Output:

System is in safe state. Safe sequence is: 1 3 4 0 2

Illustration :

Considering a system with five processes P0 through P4 and three resources types A, B, C. Resource type A has 10 instances, B has 5 instances and type C has 7 instances. Suppose at time t0 following snapshot of the system has been taken:



We must determine whether the new system state is safe. To do so, we need to execute Safety algorithm on the above given allocation chart.



Following is the resource allocation graph:



Executing safety algorithm shows that sequence < P1, P3, P4, P0, P2 > satisfies safety requirement.

Time complexity = O(n*n*m) where n = number of processes and m = number of resources.

This article is contributed by Sahil Chhabra (akku). If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
84,"Prerequisite – Resource Allocation Graph (RAG), Banker’s Algorithm, Program for Banker’s Algorithm

Banker’s Algorithm is a resource allocation and deadlock avoidance algorithm. This algorithm test for safety simulating the allocation for predetermined maximum possible amounts of all resources, then makes an “s-state” check to test for possible activities, before deciding whether allocation should be allowed to continue.

In simple terms, it checks if allocation of any resource will lead to deadlock or not, OR is it safe to allocate a resource to a process and if not then resource is not allocated to that process. Determining a safe sequence(even if there is only 1) will assure that system will not go into deadlock.

Banker’s algorithm is generally used to find if a safe sequence exist or not. But here we will determine the total number of safe sequences and print all safe sequences.

The data structure used are:

Available vector

Max Matrix

Allocation Matrix

Need Matrix

Example:

Input:

Output: Safe sequences are: P2--> P4--> P1--> P3 P2--> P4--> P3--> P1 P4--> P2--> P1--> P3 P4--> P2--> P3--> P1 There are total 4 safe-sequences

Explanation:

Total resources are R1 = 10, R2 = 5, R3 = 7 and allocated resources are R1 = (0+2+3+2 =) 7, R2 = (1+0+0+1 =) 2, R3 = (0+0+2+1 =) 3. Therefore, remaining resources are R1 = (10 – 7 =) 3, R2 = (5 – 2 =) 3, R3 = (7 – 3 =) 4.

Remaining available = Total resources – allocated resources

and

Remaining need = max – allocated



So, we can start from either P2 or P4. We can not satisfy remaining need from available resources of either P1 or P3 in first or second attempt step of Banker’s algorithm. There are only four possible safe sequences. These are :

P2–> P4–> P1–> P3

P2–> P4–> P3–> P1

P4–> P2–> P1–> P3

P4–> P2–> P3–> P1

Implementation:

C++ filter_none edit

close play_arrow link

brightness_4

code #include <iostream> #include <string.h> #include <vector> #define P 4 #define R 3 int total = 0; using namespace std; bool is_available( int process_id, int allocated[][R], int max[][R], int need[][R], int available[]) { bool flag = true ; for ( int i = 0; i < R; i++) { if (need[process_id][i] > available[i]) flag = false ; } return flag; } void safe_sequence( bool marked[], int allocated[][R], int max[][R], int need[][R], int available[], vector< int > safe) { for ( int i = 0; i < P; i++) { if (!marked[i] && is_available(i, allocated, max, need, available)) { marked[i] = true ; for ( int j = 0; j < R; j++) available[j] += allocated[i][j]; safe.push_back(i); safe_sequence(marked, allocated, max, need, available, safe); safe.pop_back(); marked[i] = false ; for ( int j = 0; j < R; j++) available[j] -= allocated[i][j]; } } if (safe.size() == P) { total++; for ( int i = 0; i < P; i++) { cout << ""P"" << safe[i] + 1; if (i != (P - 1)) cout << ""--> "" ; } cout << endl; } } int main() { int allocated[P][R] = { { 0, 1, 0 }, { 2, 0, 0 }, { 3, 0, 2 }, { 2, 1, 1 } }; int max[P][R] = { { 7, 5, 3 }, { 3, 2, 2 }, { 9, 0, 2 }, { 2, 2, 2 } }; int resources[R] = { 10, 5, 7 }; int available[R]; for ( int i = 0; i < R; i++) { int sum = 0; for ( int j = 0; j < P; j++) sum += allocated[j][i]; available[i] = resources[i] - sum; } vector< int > safe; bool marked[P]; memset (marked, false , sizeof (marked)); int need[P][R]; for ( int i = 0; i < P; i++) for ( int j = 0; j < R; j++) need[i][j] = max[i][j] - allocated[i][j]; cout << ""Safe sequences are:"" << endl; safe_sequence(marked, allocated, max, need, available, safe); cout << ""

There are total "" << total << "" safe-sequences"" << endl; return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; public class GFG { static int P = 4 ; static int R = 3 ; static int total = 0 ; static boolean is_available( int process_id, int allocated[][], int max[][], int need[][], int available[]) { boolean flag = true ; for ( int i = 0 ; i < R; i++) { if (need[process_id][i] > available[i]) { flag = false ; } } return flag; } static void safe_sequence( boolean marked[], int allocated[][], int max[][], int need[][], int available[], Vector<Integer> safe) { for ( int i = 0 ; i < P; i++) { if (!marked[i] && is_available(i, allocated, max, need, available)) { marked[i] = true ; for ( int j = 0 ; j < R; j++) { available[j] += allocated[i][j]; } safe.add(i); safe_sequence(marked, allocated, max, need, available, safe); safe.removeElementAt(safe.size() - 1 ); marked[i] = false ; for ( int j = 0 ; j < R; j++) { available[j] -= allocated[i][j]; } } } if (safe.size() == P) { total++; for ( int i = 0 ; i < P; i++) { System.out.print( ""P"" + (safe.get(i) + 1 )); if (i != (P - 1 )) { System.out.print( ""--> "" ); } } System.out.println( """" );; } } public static void main(String[] args) { int allocated[][] = {{ 0 , 1 , 0 }, { 2 , 0 , 0 }, { 3 , 0 , 2 }, { 2 , 1 , 1 }}; int max[][] = {{ 7 , 5 , 3 }, { 3 , 2 , 2 }, { 9 , 0 , 2 }, { 2 , 2 , 2 }}; int resources[] = { 10 , 5 , 7 }; int [] available = new int [R]; for ( int i = 0 ; i < R; i++) { int sum = 0 ; for ( int j = 0 ; j < P; j++) { sum += allocated[j][i]; } available[i] = resources[i] - sum; } Vector<Integer> safe = new Vector<Integer>(); boolean [] marked = new boolean [P]; int [][] need = new int [P][R]; for ( int i = 0 ; i < P; i++) { for ( int j = 0 ; j < R; j++) { need[i][j] = max[i][j] - allocated[i][j]; } } System.out.println( ""Safe sequences are:"" ); safe_sequence(marked, allocated, max, need, available, safe); System.out.println( ""

There are total "" + total + "" safe-sequences"" ); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code P = 4 R = 3 total = 0 def is_available(process_id, allocated, max , need, available): flag = True for i in range (R): if (need[process_id][i] > available[i]): flag = False return flag def safe_sequence(marked, allocated, max , need, available, safe): global total, P, R for i in range (P): if ( not marked[i] and is_available(i, allocated, max , need, available)): marked[i] = True for j in range (R): available[j] + = allocated[i][j] safe.append(i) safe_sequence(marked, allocated, max , need, available, safe) safe.pop() marked[i] = False for j in range (R): available[j] - = allocated[i][j] if ( len (safe) = = P): total + = 1 for i in range (P): print ( ""P"" + str (safe[i] + 1 ), end = '') if (i ! = (P - 1 )): print ( ""--> "" , end = '') print () if __name__ = = ""__main__"" : allocated = [ [ 0 , 1 , 0 ], [ 2 , 0 , 0 ], [ 3 , 0 , 2 ], [ 2 , 1 , 1 ]] max = [ [ 7 , 5 , 3 ], [ 3 , 2 , 2 ], [ 9 , 0 , 2 ], [ 2 , 2 , 2 ] ] resources = [ 10 , 5 , 7 ] available = [ 0 for i in range (R)] for i in range (R): sum = 0 for j in range (P): sum + = allocated[j][i] available[i] = resources[i] - sum safe = [] marked = [ False for i in range (P)] need = [[ 0 for j in range (R)] for i in range (P)] for i in range (P): for j in range (R): need[i][j] = ( max [i][j] - allocated[i][j]) print ( ""Safe sequences are:"" ) safe_sequence(marked, allocated, max , need, available, safe) print ( ""

There are total "" + str (total) + "" safe-sequences"" ) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Collections.Generic; class GFG { static int P = 4; static int R = 3; static int total = 0; static Boolean is_available( int process_id, int [,]allocated, int [,]max, int [,]need, int []available) { Boolean flag = true ; for ( int i = 0; i < R; i++) { if (need[process_id, i] > available[i]) { flag = false ; } } return flag; } static void safe_sequence(Boolean []marked, int [,]allocated, int [,]max, int [,]need, int []available, List< int > safe) { for ( int i = 0; i < P; i++) { if (!marked[i] && is_available(i, allocated, max, need, available)) { marked[i] = true ; for ( int j = 0; j < R; j++) { available[j] += allocated[i, j]; } safe.Add(i); safe_sequence(marked, allocated, max, need, available, safe); safe.RemoveAt(safe.Count - 1); marked[i] = false ; for ( int j = 0; j < R; j++) { available[j] -= allocated[i, j]; } } } if (safe.Count == P) { total++; for ( int i = 0; i < P; i++) { Console.Write( ""P"" + (safe[i] + 1)); if (i != (P - 1)) { Console.Write( ""--> "" ); } } Console.WriteLine( """" );; } } public static void Main(String[] args) { int [,]allocated = {{0, 1, 0}, {2, 0, 0}, {3, 0, 2}, {2, 1, 1}}; int [,]max = {{7, 5, 3}, {3, 2, 2}, {9, 0, 2}, {2, 2, 2}}; int []resources = {10, 5, 7}; int [] available = new int [R]; for ( int i = 0; i < R; i++) { int sum = 0; for ( int j = 0; j < P; j++) { sum += allocated[j,i]; } available[i] = resources[i] - sum; } List< int > safe = new List< int >(); Boolean[] marked = new Boolean[P]; int [,] need = new int [P, R]; for ( int i = 0; i < P; i++) { for ( int j = 0; j < R; j++) { need[i, j] = max[i, j] - allocated[i, j]; } } Console.WriteLine( ""Safe sequences are:"" ); safe_sequence(marked, allocated, max, need, available, safe); Console.WriteLine( ""

There are total "" + total + "" safe-sequences"" ); } } chevron_right filter_none

Output:

Safe sequences are: P2--> P4--> P1--> P3 P2--> P4--> P3--> P1 P4--> P2--> P1--> P3 P4--> P2--> P3--> P1 There are total 4 safe-sequences

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
85,"If a system does not employ either a deadlock prevention or deadlock avoidance algorithm then a deadlock situation may occur. In this case-



Apply an algorithm to examine state of system to determine whether deadlock has has occurred or not.

Apply an algorithm to recover from the deadlock. For more refer- Deadlock Recovery

Deadlock Avoidance Algorithm/ Bankers Algorithm:

The algorithm employs several time varying data structures:



Available- A vector of length m indicates the number of available resources of each type.

A vector of length m indicates the number of available resources of each type. Allocation- An n*m matrix defines the number of resources of each type currently allocated to a process. Column represents resource and resource represent process.

An n*m matrix defines the number of resources of each type currently allocated to a process. Column represents resource and resource represent process. Request- An n*m matrix indicates the current request of each process. If request[i][j] equals k then process P i is requesting k more instances of resource type R j .

This algorithm has already been discussed here



Now, Bankers algorithm includes a Safety Algorithm / Deadlock Detection Algorithm

The algorithm for finding out whether or not a system is in a safe state can be described as follows:

Steps of Algorithm:



Let Work and Finish be vectors of length m and n respectively. Initialize Work= Available. For i=0, 1, …., n-1, if Request i = 0, then Finish[i] = true; otherwise, Finish[i]= false. Find an index i such that both

a) Finish[i] == false

b) Request i <= Work

If no such i exists go to step 4. Work= Work+ Allocation i

Finish[i]= true

Go to Step 2. If Finish[i]== false for some i, 0<=i<n, then the system is in a deadlocked state. Moreover, if Finish[i]==false the process P i is deadlocked.

For example,



In this, Work = [0, 0, 0] &

Finish = [false, false, false, false, false] i=0 is selected as both Finish[0] = false and [0, 0, 0]<=[0, 0, 0]. Work =[0, 0, 0]+[0, 1, 0] =>[0, 1, 0] &

Finish = [true, false, false, false, false]. i=2 is selected as both Finish[2] = false and [0, 0, 0]<=[0, 1, 0]. Work =[0, 1, 0]+[3, 0, 3] =>[3, 1, 3] &

Finish = [true, false, true, false, false]. i=1 is selected as both Finish[1] = false and [2, 0, 2]<=[3, 1, 3]. Work =[3, 1, 3]+[2, 0, 0] =>[5, 1, 3] &

Finish = [true, true, true, false, false]. i=3 is selected as both Finish[3] = false and [1, 0, 0]<=[5, 1, 3]. Work =[5, 1, 3]+[2, 1, 1] =>[7, 2, 4] &

Finish = [true, true, true, true, false]. i=4 is selected as both Finish[4] = false and [0, 0, 2]<=[7, 2, 4]. Work =[7, 2, 4]+[0, 0, 2] =>[7, 2, 6] &

Finish = [true, true, true, true, true]. Since Finish is a vector of all true it means there is no deadlock in this example.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

aastha98 Student at Netaji Subhas Institute of Technology"
86,"Given: A system has R identical resources, P processes competing for them and N is the maximum need of each process. The task is to find the minimum number of Resources required So that deadlock will never occur.

Formula:

R >= P * (N - 1) + 1

Examples:

Input : P = 3, N = 4 Output : R >= 10 Input : P = 7, N = 2 Output : R >= 8

Approach:

Consider, 3 process A, B and C.

Let, Need of each process is 4

Therefore, The maximum resources require will be 3 * 4 = 12 i.e, Give 4 resources to each Process.

And, The minimum resources required will be 3 * (4 – 1) + 1 = 10.

i.e, Give 3 Resources to each of the Process, and we are left out with 1 Resource.

That 1 resource will be given to any of the Process A, B or C.

So that after using that resource by any one of the Process, It left the resources and that resources will be used by any other Process and thus Deadlock will Never Occur.

C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; int Resources( int process, int need) { int minResources = 0; minResources = process * (need - 1) + 1; return minResources; } int main() { int process = 3, need = 4; cout << ""R >= "" << Resources(process, need); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code class GFG { static int Resources( int process, int need) { int minResources = 0 ; minResources = process * (need - 1 ) + 1 ; return minResources; } public static void main(String args[]) { int process = 3 , need = 4 ; System.out.print( ""R >= "" ); System.out.print(Resources(process, need)); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def Resources(process, need): minResources = 0 minResources = process * (need - 1 ) + 1 return minResources if __name__ = = ""__main__"" : process, need = 3 , 4 print ( ""R >="" , Resources(process, need)) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; class GFG { static int Resources( int process, int need) { int minResources = 0; minResources = process * (need - 1) + 1; return minResources; } public static void Main() { int process = 3, need = 4; Console.Write( ""R >= "" ); Console.Write(Resources(process, need)); } } chevron_right filter_none

Output:

R >= 10

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
87,"In a distributed system deadlock can neither be prevented nor avoided as the system is so vast that it is impossible to do so. Therefore, only deadlock detection can be implemented. The techniques of deadlock detection in the distributed system require the following:

Progress – The method should be able to detect all the deadlocks in the system.

The method should be able to detect all the deadlocks in the system. Safety – The method should not detect false or phantom deadlocks.

There are three approaches to detect deadlocks in distributed systems. They are as follows:

Centralized approach –

In the centralized approach, there is only one responsible resource to detect deadlock. The advantage of this approach is that it is simple and easy to implement, while the drawbacks include excessive workload at one node, single-point failure (that is the whole system is dependent on one node if that node fails the whole system crashes) which in turns makes the system less reliable. Distributed approach –

In the distributed approach different nodes work together to detect deadlocks. No single point failure ( that is the whole system is dependent on one node if that node fails the whole system crashes) as the workload is equally divided among all nodes. The speed of deadlock detection also increases. Hierarchical approach –

This approach is the most advantageous. It is the combination of both centralized and distributed approaches of deadlock detection in a distributed system. In this approach, some selected nodes or cluster of nodes are responsible for deadlock detection and these selected nodes are controlled by a single node.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : Vidit_Gupta"
88,"Prerequisite – Deadlock Introduction, deadlock detection

In the centralized approach of deadlock detection, two techniques are used namely: Completely centralized algorithm and Ho Ramamurthy algorithm (One phase and Two-phase).

Completely Centralized Algorithm –

In a network of n sites, one site is chosen as a control site. This site is responsible for deadlock detection. It has control over all resources of the system. If a site requires a resource it requests the control site, the control site allocates and de-allocates resources and maintains a wait for graph. And at regular interval of time, it checks the wait for graph to detect a cycle. If cycle exits then it will declare system as deadlock otherwise the system will continue working. The major drawbacks of this technique are as follows: A site has to send request even for using its own resource. There is a possibility of phantom deadlock.

In a network of n sites, one site is chosen as a control site. This site is responsible for deadlock detection. It has control over all resources of the system. If a site requires a resource it requests the control site, the control site allocates and de-allocates resources and maintains a wait for graph. And at regular interval of time, it checks the wait for graph to detect a cycle. If cycle exits then it will declare system as deadlock otherwise the system will continue working. The major drawbacks of this technique are as follows: HO Ramamurthy (Two-Phase Algorithm) –

In this technique a resource status table is maintained by the central or control site, if a cycle is detected then the system is not declared deadlock at first, the cycle is checked again as the system is distributed some or the other resource is vacant or freed by sites at every instant of time. Now, after checking if a cycle is detected again then, the system is declared as deadlock. This technique reduces the possibility of phantom deadlock but on the other hand time consumption is more.

In this technique a resource status table is maintained by the central or control site, if a cycle is detected then the system is not declared deadlock at first, the cycle is checked again as the system is distributed some or the other resource is vacant or freed by sites at every instant of time. Now, after checking if a cycle is detected again then, the system is declared as deadlock. This technique reduces the possibility of phantom deadlock but on the other hand time consumption is more. HO Ramamurthy (One Phase Algorithm) –

In this technique a resource status table and a process table is maintained by the central or control site if the cycle is detected in both processes and resource tables then, the system is declared as deadlock. This technique reduces time consumption but space complexity increases.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : RakshithSathish"
89,"What is a Thread?

A thread is a path of execution within a process. A process can contain multiple threads.

Why Multithreading?

A thread is also known as lightweight process. The idea is to achieve parallelism by dividing a process into multiple threads. For example, in a browser, multiple tabs can be different threads. MS Word uses multiple threads: one thread to format the text, another thread to process inputs, etc. More advantages of multithreading are discussed below

Process vs Thread?

The primary difference is that threads within the same process run in a shared memory space, while processes run in separate memory spaces.

Threads are not independent of one another like processes are, and as a result threads share with other threads their code section, data section, and OS resources (like open files and signals). But, like process, a thread has its own program counter (PC), register set, and stack space.

Advantages of Thread over Process

1. Responsiveness: If the process is divided into multiple threads, if one thread completes its execution, then its output can be immediately returned.

2. Faster context switch: Context switch time between threads is lower compared to process context switch. Process context switching requires more overhead from the CPU.

3. Effective utilization of multiprocessor system: If we have multiple threads in a single process, then we can schedule multiple threads on multiple processor. This will make process execution faster.

4. Resource sharing: Resources like code, data, and files can be shared among all threads within a process.

Note: stack and registers can’t be shared among the threads. Each thread has its own stack and registers.

5. Communication: Communication between multiple threads is easier, as the threads shares common address space. while in process we have to follow some specific communication technique for communication between two process.

6. Enhanced throughput of the system: If a process is divided into multiple threads, and each thread function is considered as one job, then the number of jobs completed per unit of time is increased, thus increasing the throughput of the system.

Types of Threads

There are two types of threads.

User Level Thread

Kernel Level Thread

Refer User Thread vs Kernel Thread for more details.

Below are previous years’ gate questions on threads:

http://quiz.geeksforgeeks.org/gate-gate-cs-2011-question-16/

http://quiz.geeksforgeeks.org/gate-gate-cs-2007-question-17/

http://quiz.geeksforgeeks.org/gate-gate-cs-2014-set-1-question-30/

Reference:

Multithreading in C

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : chrismaher37"
90,"Thread is a single sequence stream within a process. Threads have same properties as of the process so they are called as light weight processes. Threads are executed one after another but gives the illusion as if they are executing in parallel. Each thread has different states. Each thread has

A program counter A register set A stack space

Threads are not independent of each other as they share the code, data, OS resources etc.

Similarity between Threads and Processes –

Only one thread or process is active at a time

Within process both execute sequentiall

Both can create children

Differences between Threads and Processes –

Threads are not independent, processes are.

Threads are designed to assist each other, processes may or may not do it

Types of Threads:

User Level thread (ULT) –

Is implemented in the user level library, they are not created using the system calls. Thread switching does not need to call OS and to cause interrupt to Kernel. Kernel doesn’t know about the user level thread and manages them as if they were single-threaded processes. Advantages of ULT – Can be implemented on an OS that does’t support multithreading.

Simple representation since thread has only program counter, register set, stack space.

Simple to create since no intervention of kernel.

Thread switching is fast since no OS calls need to be made. Disadvantages of ULT – No or less co-ordination among the threads and Kernel.

If one thread causes a page fault, the entire process blocks. Kernel Level Thread (KLT) –

Kernel knows and manages the threads. Instead of thread table in each process, the kernel itself has thread table (a master one) that keeps track of all the threads in the system. In addition kernel also maintains the traditional process table to keep track of the processes. OS kernel provides system call to create and manage threads. Advantages of KLT – Since kernel has full knowledge about the threads in the system, scheduler may decide to give more time to processes having large number of threads.

Good for applications that frequently block. Disadvantages of KLT – Slow and inefficient.

It requires thread control block so it is an overhead.

Summary:

Each ULT has a process that keeps track of the thread using the Thread table. Each KLT has Thread Table (TCB) as well as the Process Table (PCB).

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : wertyu, magbene"
91,"User level thread Kernel level thread User thread are implemented by users. kernel threads are implemented by OS. OS doesn’t recognized user level threads. Kernel threads are recognized by OS. Implementation of User threads is easy. Implementation of Kernel thread is complicated. Context switch time is less. Context switch time is more. Context switch requires no hardware support. Hardware support is needed. If one user level thread perform blocking operation then entire process will be blocked. If one kernel thread perform blocking operation then another thread can continue execution. User level threads are designed as dependent threads. Kernel level threads are designed as independent threads. Example : Java thread, POSIX threads. Example : Window Solaris.

Below is the Previous Year Gate Question

http://quiz.geeksforgeeks.org/gate-gate-cs-2007-question-17/



References:

http://www.cs.iit.edu/~cs561/cs450/ChilkuriDineshThreads/dinesh%27s%20files/User%20and%20Kernel%20Level%20Threads.html

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : pp_pankaj"
92,"Prerequisite – Thread, Difference between multitasking, multithreading and multiprocessing

A multitasking operating system is an operating system that gives you the perception of 2 or more tasks/jobs/processes running at the same time. It does this by dividing system resources amongst these tasks/jobs/processes and switching between the tasks/jobs/processes while they are executing over and over again. Usually CPU processes only one task at a time but the switching is so fast that it looks like CPU is executing multiple processes at a time. They can support either preemptive multitasking, where the OS doles out time to applications (virtually all modern OSes) or cooperative multitasking, where the OS waits for the program to give back control (Windows 3.x, Mac OS 9 and earlier), leading to hangs and crashes. Also known as Timesharing, multitasking is a logical extension of multiprogramming.

Multitasking programming is of two types –

Process-based Multitasking Thread-based Multitasking.

Process Based Multitasking Programming –

In process based multitasking two or more processes and programs can be run concurrently.

In process based multitasking a process or a program is the smallest unit.

Program is a bigger unit.

Process based multitasking requires more overhead.

Process requires its own address space.

Process to Process communication is expensive.

Here, it is unable to gain access over idle time of CPU.

It is comparatively heavy weight.

It has slower data rate multi-tasking.

Example – We can listen to music and browse internet at the same time. The processes in this example are the music player and browser.

Thread Based Multitasking Programming –

In thread based multitasking two or more threads can be run concurrently.

In thread based multitasking a thread is the smallest unit.

Thread is a smaller unit.

Thread based multitasking requires less overhead.

Threads share same address space.

Thread to Thread communication is not expensive.

It allows taking gain access over idle time taken by CPU.

It is comparatively light weight.

It has faster data rate multi-tasking.

Examples – Using a browser we can navigate through the webpage and at the same time download a file. In this example, navigation is one thread and downloading is another thread. Also in a word-processing application like MS Word, we can type text in one thread and spell checker checks for mistakes in another thread.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
93,"Many operating systems support kernel thread and user thread in a combined way. Example of such system is Solaris. Multi threading model are of three types.

Many to many model. Many to one model. one to one model.

Many to Many Model

In this model, we have multiple user threads multiplex to same or lesser number of kernel level threads. Number of kernel level threads are specific to the machine, advantage of this model is if a user thread is blocked we can schedule others user thread to other kernel thread. Thus, System doesn’t block if a particular thread is blocked.

Many to One Model

In this model, we have multiple user threads mapped to one kernel thread. In this model when a user thread makes a blocking system call entire process blocks. As we have only one kernel thread and only one user thread can access kernel at a time, so multiple threads are not able access multiprocessor at the same time.

One to One Model

In this model, one to one relationship between kernel and user thread. In this model multiple thread can run on multiple processor. Problem with this model is that creating a user thread requires the corresponding kernel thread.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
94,"In a non multi threaded environment, a server listens to the port for some request and when the request comes, it processes the request and then resume listening to another request. The time taken while processing of request makes other users wait unnecessarily. Instead a better approach would be to pass the request to a worker thread and continue listening to port.

For example, a multi threaded web browser allow user interaction in one thread while an video is being loaded in another thread. So instead of waiting for the whole web-page to load the user can continue viewing some portion of the web-page."
95,"Prerequisites: fork() in C, Zombie Process

Zombie state : When a process is created in UNIX using fork() system call, the address space of the Parent process is replicated. If the parent process calls wait() system call, then the execution of parent is suspended until the child is terminated. At the termination of the child, a ‘SIGCHLD’ signal is generated which is delivered to the parent by the kernel. Parent, on receipt of ‘SIGCHLD’ reaps the status of the child from the process table. Even though, the child is terminated, there is an entry in the process table corresponding to the child where the status is stored. When parent collects the status, this entry is deleted. Thus, all the traces of the child process are removed from the system. If the parent decides not to wait for the child’s termination and it executes its subsequent task, then at the termination of the child, the exit status is not read. Hence, there remains an entry in the process table even after the termination of the child. This state of the child process is known as the Zombie state.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid == 0) { for (i=0; i<20; i++) printf ( ""I am Child

"" ); } else { printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

Output :

Now check the process table using the following command in the terminal

$ ps -eaf

Here the entry [a.out] defunct shows the zombie process.

Why do we need to prevent the creation of Zombie process?

There is one process table per system. The size of the process table is finite. If too many zombie processes are generated, then the process table will be full. That is, the system will not be able to generate any new process, then the system will come to a standstill. Hence, we need to prevent the creation of zombie processes.

Different ways in which the creation of Zombie can be Prevented

1. Using wait() system call : When the parent process calls wait(), after the creation of a child, it indicates that, it will wait for the child to complete and it will reap the exit status of the child. The parent process is suspended(waits in a waiting queue) until the child is terminated. It must be understood that during this period, the parent process does nothing just waits.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid==0) { for (i=0; i<20; i++) printf ( ""I am Child

"" ); } else { wait(NULL); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

2. By ignoring the SIGCHLD signal : When a child is terminated, a corresponding SIGCHLD signal is delivered to the parent, if we call the ‘signal(SIGCHLD,SIG_IGN)’, then the SIGCHLD signal is ignored by the system, and the child process entry is deleted from the process table. Thus, no zombie is created. However, in this case, the parent cannot know about the exit status of the child.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid == 0) for (i=0; i<20; i++) printf ( ""I am Child

"" ); else { signal (SIGCHLD,SIG_IGN); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

3. By using a signal handler : The parent process installs a signal handler for the SIGCHLD signal. The signal handler calls wait() system call within it. In this senario, when the child terminated, the SIGCHLD is delivered to the parent. On receipt of SIGCHLD, the corresponding handler is activated, which in turn calls the wait() system call. Hence, the parent collects the exit status almost immediately and the child entry in the process table is cleared. Thus no zombie is created.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> void func( int signum) { wait(NULL); } int main() { int i; int pid = fork(); if (pid == 0) for (i=0; i<20; i++) printf ( ""I am Child

"" ); else { signal (SIGCHLD, func); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

Output:

Here no any [a.out] defunct i.e. no any Zombie process is created.

This article is contributed by Kishlay Verma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready."
96,"Prerequisites: fork() in C, Zombie Process

Zombie state : When a process is created in UNIX using fork() system call, the address space of the Parent process is replicated. If the parent process calls wait() system call, then the execution of parent is suspended until the child is terminated. At the termination of the child, a ‘SIGCHLD’ signal is generated which is delivered to the parent by the kernel. Parent, on receipt of ‘SIGCHLD’ reaps the status of the child from the process table. Even though, the child is terminated, there is an entry in the process table corresponding to the child where the status is stored. When parent collects the status, this entry is deleted. Thus, all the traces of the child process are removed from the system. If the parent decides not to wait for the child’s termination and it executes its subsequent task, then at the termination of the child, the exit status is not read. Hence, there remains an entry in the process table even after the termination of the child. This state of the child process is known as the Zombie state.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid == 0) { for (i=0; i<20; i++) printf ( ""I am Child

"" ); } else { printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

Output :

Now check the process table using the following command in the terminal

$ ps -eaf

Here the entry [a.out] defunct shows the zombie process.

Why do we need to prevent the creation of Zombie process?

There is one process table per system. The size of the process table is finite. If too many zombie processes are generated, then the process table will be full. That is, the system will not be able to generate any new process, then the system will come to a standstill. Hence, we need to prevent the creation of zombie processes.

Different ways in which the creation of Zombie can be Prevented

1. Using wait() system call : When the parent process calls wait(), after the creation of a child, it indicates that, it will wait for the child to complete and it will reap the exit status of the child. The parent process is suspended(waits in a waiting queue) until the child is terminated. It must be understood that during this period, the parent process does nothing just waits.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid==0) { for (i=0; i<20; i++) printf ( ""I am Child

"" ); } else { wait(NULL); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

2. By ignoring the SIGCHLD signal : When a child is terminated, a corresponding SIGCHLD signal is delivered to the parent, if we call the ‘signal(SIGCHLD,SIG_IGN)’, then the SIGCHLD signal is ignored by the system, and the child process entry is deleted from the process table. Thus, no zombie is created. However, in this case, the parent cannot know about the exit status of the child.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> int main() { int i; int pid = fork(); if (pid == 0) for (i=0; i<20; i++) printf ( ""I am Child

"" ); else { signal (SIGCHLD,SIG_IGN); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

3. By using a signal handler : The parent process installs a signal handler for the SIGCHLD signal. The signal handler calls wait() system call within it. In this senario, when the child terminated, the SIGCHLD is delivered to the parent. On receipt of SIGCHLD, the corresponding handler is activated, which in turn calls the wait() system call. Hence, the parent collects the exit status almost immediately and the child entry in the process table is cleared. Thus no zombie is created.

filter_none edit

close play_arrow link

brightness_4

code #include<stdio.h> #include<unistd.h> #include<sys/wait.h> #include<sys/types.h> void func( int signum) { wait(NULL); } int main() { int i; int pid = fork(); if (pid == 0) for (i=0; i<20; i++) printf ( ""I am Child

"" ); else { signal (SIGCHLD, func); printf ( ""I am Parent

"" ); while (1); } }

chevron_right filter_none

Output:

Here no any [a.out] defunct i.e. no any Zombie process is created.

This article is contributed by Kishlay Verma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready."
97,"Remote Procedure Call (RPC) is a powerful technique for constructing distributed, client-server based applications. It is based on extending the conventional local procedure calling so that the called procedure need not exist in the same address space as the calling procedure. The two processes may be on the same system, or they may be on different systems with a network connecting them.

When making a Remote Procedure Call:

1. The calling environment is suspended, procedure parameters are transferred across the network to the environment where the procedure is to execute, and the procedure is executed there.

2. When the procedure finishes and produces its results, its results are transferred back to the calling environment, where execution resumes as if returning from a regular procedure call.

NOTE: RPC is especially well suited for client-server (e.g. query-response) interaction in which the flow of control alternates between the caller and callee. Conceptually, the client and server do not both execute at the same time. Instead, the thread of execution jumps from the caller to the callee and then back again.

Working of RPC

The following steps take place during a RPC:

1. A client invokes a client stub procedure, passing parameters in the usual way. The client stub resides within the client’s own address space.

2. The client stub marshalls(pack) the parameters into a message. Marshalling includes converting the representation of the parameters into a standard format, and copying each parameter into the message.

3. The client stub passes the message to the transport layer, which sends it to the remote server machine.

4. On the server, the transport layer passes the message to a server stub, which demarshalls(unpack) the parameters and calls the desired server routine using the regular procedure call mechanism.

5. When the server procedure completes, it returns to the server stub (e.g., via a normal procedure call return), which marshalls the return values into a message. The server stub then hands the message to the transport layer.

6. The transport layer sends the result message back to the client transport layer, which hands the message back to the client stub.

7. The client stub demarshalls the return parameters and execution returns to the caller.

RPC ISSUES

Issues that must be addressed:

1. RPC Runtime: RPC run-time system is a library of routines and a set of services that handle the network communications that underlie the RPC mechanism. In the course of an RPC call, client-side and server-side run-time systems’ code handle binding, establish communications over an appropriate protocol, pass call data between the client and server, and handle communications errors.

2. Stub: The function of the stub is to provide transparency to the programmer-written application code.

On the client side, the stub handles the interface between the client’s local procedure call and the run-time system, marshaling and unmarshaling data, invoking the RPC run-time protocol, and if requested, carrying out some of the binding steps.

On the server side, the stub provides a similar interface between the run-time system and the local manager procedures that are executed by the server.

3. Binding: How does the client know who to call, and where the service resides?

The most flexible solution is to use dynamic binding and find the server at run time when the RPC is first made. The first time the client stub is invoked, it contacts a name server to determine the transport address at which the server resides.

Binding consists of two parts:

Naming:

Remote procedures are named through interfaces. An interface uniquely identifies a particular service, describing the types and numbers of its arguments. It is similar in purpose to a type definition in programming languauges. Locating: Finding the transport address at which the server actually resides. Once we have the transport address of the service, we can send messages directly to the server.

A Server having a service to offer exports an interface for it. Exporting an interface registers it with the system so that clients can use it.

A Client must import an (exported) interface before communication can begin.

ADVANTAGES

1. RPC provides ABSTRACTION i.e message-passing nature of network communication is hidden from the user.

2. RPC often omits many of the protocol layers to improve performance. Even a small performance improvement is important because a program may invoke RPCs often.

3. RPC enables the usage of the applications in the distributed environment, not only in the local environment.

4. With RPC code re-writing / re-developing effort is minimized.

5. Process-oriented and thread oriented models supported by RPC.

References:

This article is contributed by Yash Singla. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : Akanksha_Rai"
98,"In the Computer System Design, Memory Hierarchy is an enhancement to organize the memory such that it can minimize the access time. The Memory Hierarchy was developed based on a program behavior known as locality of references.The figure below clearly demonstrates the different levels of memory hierarchy :

This Memory Hierarchy Design is divided into 2 main types:

External Memory or Secondary Memory –

Comprising of Magnetic Disk, Optical Disk, Magnetic Tape i.e. peripheral storage devices which are accessible by the processor via I/O Module. Internal Memory or Primary Memory –

Comprising of Main Memory, Cache Memory & CPU registers. This is directly accessible by the processor.

We can infer the following characteristics of Memory Hierarchy Design from above figure:

Capacity:

It is the global volume of information the memory can store. As we move from top to bottom in the Hierarchy, the capacity increases.



Access Time:

It is the time interval between the read/write request and the availability of the data. As we move from top to bottom in the Hierarchy, the access time increases. Performance:

Earlier when the computer system was designed without Memory Hierarchy design, the speed gap increases between the CPU registers and Main Memory due to large difference in access time. This results in lower performance of the system and thus, enhancement was required. This enhancement was made in the form of Memory Hierarchy Design because of which the performance of the system increases. One of the most significant ways to increase system performance is minimizing how far down the memory hierarchy one has to go to manipulate data. Cost per bit:

As we move from bottom to top in the Hierarchy, the cost per bit increases i.e. Internal Memory is costlier than External Memory.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
99,"Memories are made up of registers. Each register in the memory is one storage location. Storage location is also called as memory location. Memory locations are identified using Address. The total number of bit a memory can store is its capacity.

A storage element is called a Cell. Each register is made up of storage element in which one bit of data is stored. The data in a memory are stored and retrieved by the process called writing and reading respectively.

A word is a group of bits where a memory unit stores binary information. A word with group of 8 bits is called a byte.

A memory unit consists of data lines, address selection lines, and control lines that specify the direction of transfer. The block diagram of a memory unit is shown below:

Data lines provide the information to be stored in memory. The control inputs specify the direction transfer. The k-address lines specify the word chosen.

When there are k address lines, 2k memory word can be accessed.

Refer for RAM and ROM, different types of RAM, cache memory, and secondary memory

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
100,"RAM(Random Access Memory) is a part of computer’s Main Memory which is directly accessible by CPU. RAM is used to Read and Write data into it which is accessed by CPU randomly. RAM is volatile in nature, it means if the power goes off, the stored information is lost. RAM is used to store the data that is currently processed by the CPU. Most of the programs and data that are modifiable are stored in RAM.

Integrated RAM chips are available in two form:

SRAM(Static RAM) DRAM(Dynamic RAM)

The block diagram of RAM chip is given below.

SRAM

The SRAM memories consist of circuits capable of retaining the stored information as long as the power is applied. That means this type of memory requires constant power. SRAM memories are used to build Cache Memory.

SRAM Memory Cell: Static memories(SRAM) are memories that consist of circuits capable of retaining their state as long as power is on. Thus this type of memories is called volatile memories. The below figure shows a cell diagram of SRAM. A latch is formed by two inverters connected as shown in the figure. Two transistors T1 and T2 are used for connecting the latch with two bit lines. The purpose of these transistors is to act as switches that can be opened or closed under the control of the word line, which is controlled by the address decoder. When the word line is at 0-level, the transistors are turned off and the latch remains its information. For example, the cell is at state 1 if the logic value at point A is 1 and at point B is 0. This state is retained as long as the word line is not activated.



For Read operation, the word line is activated by the address input to the address decoder. The activated word line closes both the transistors (switches) T1 and T2. Then the bit values at points A and B can transmit to their respective bit lines. The sense/write circuit at the end of the bit lines sends the output to the processor.

For Write operation, the address provided to the decoder activates the word line to close both the switches. Then the bit value that to be written into the cell is provided through the sense/write circuit and the signals in bit lines are then stored in the cell.

DRAM

DRAM stores the binary information in the form of electric charges that applied to capacitors. The stored information on the capacitors tend to lose over a period of time and thus the capacitors must be periodically recharged to retain their usage. The main memory is generally made up of DRAM chips.

DRAM Memory Cell: Though SRAM is very fast, but it is expensive because of its every cell requires several transistors. Relatively less expensive RAM is DRAM, due to the use of one transistor and one capacitor in each cell, as shown in the below figure., where C is the capacitor and T is the transistor. Information is stored in a DRAM cell in the form of a charge on a capacitor and this charge needs to be periodically recharged.

For storing information in this cell, transistor T is turned on and an appropriate voltage is applied to the bit line. This causes a known amount of charge to be stored in the capacitor. After the transistor is turned off, due to the property of the capacitor, it starts to discharge. Hence, the information stored in the cell can be read correctly only if it is read before the charge on the capacitors drops below some threshold value.



Types of DRAM

There are mainly 5 types of DRAM:

Asynchronous DRAM (ADRAM): The DRAM described above is the asynchronous type DRAM. The timing of the memory device is controlled asynchronously. A specialized memory controller circuit generates the necessary control signals to control the timing. The CPU must take into account the delay in the response of the memory. Synchronous DRAM (SDRAM): These RAM chips’ access speed is directly synchronized with the CPU’s clock. For this, the memory chips remain ready for operation when the CPU expects them to be ready. These memories operate at the CPU-memory bus without imposing wait states. SDRAM is commercially available as modules incorporating multiple SDRAM chips and forming the required capacity for the modules. Double-Data-Rate SDRAM (DDR SDRAM): This faster version of SDRAM performs its operations on both edges of the clock signal; whereas a standard SDRAM performs its operations on the rising edge of the clock signal. Since they transfer data on both edges of the clock, the data transfer rate is doubled. To access the data at high rate, the memory cells are organized into two groups. Each group is accessed separately. Rambus DRAM (RDRAM): The RDRAM provides a very high data transfer rate over a narrow CPU-memory bus. It uses various speedup mechanisms, like synchronous memory interface, caching inside the DRAM chips and very fast signal timing. The Rambus data bus width is 8 or 9 bits. Cache DRAM (CDRAM): This memory is a special type DRAM memory with an on-chip cache memory (SRAM) that acts as a high-speed buffer for the main DRAM.

Difference between SRAM and DRAM

Below table lists some of the differences between SRAM and DRAM:



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
101,"Prerequisite – Partition Allocation Methods

Static partition schemes suffer from the limitation of having the fixed number of active processes and the usage of space may also not be optimal. The buddy system is a memory allocation and management algorithm that manages memory in power of two increments. Assume the memory size is 2U, suppose a size of S is required.

If 2 U-1 <S<=2 U : Allocate the whole block

Allocate the whole block Else: Recursively divide the block equally and test the condition at each time, when it satisfies, allocate the block and get out the loop.

System also keep the record of all the unallocated blocks each and can merge these different size blocks to make one big chunk.

Advantage –

Easy to implement a buddy system

Allocates block of correct size

It is easy to merge adjacent holes

Fast to allocate memory and de-allocating memory

Disadvantage –

It requires all allocation unit to be powers of two

It leads to internal fragmentation

Example –

Consider a system having buddy system with physical address space 128 KB.Calculate the size of partition for 18 KB process.

Solution –



So, size of partition for 18 KB process = 32 KB. It divides by 2, till possible to get minimum block to fit 18 KB.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : soumya7, RakshithSathish"
102,"In the operating system, the following are four common memory management techniques.

Single contiguous allocation: Simplest allocation method used by MS-DOS. All memory (except some reserved for OS) is available to a process.

Partitioned allocation: Memory is divided into different blocks or partitions. Each process is allocated according to the requirement.

Paged memory management: Memory is divided into fixed-sized units called page frames, used in a virtual memory environment.

Segmented memory management: Memory is divided into different segments (a segment is a logical grouping of the process’ data or code).In this management, allocated memory doesn’t have to be contiguous.

Most of the operating systems (for example Windows and Linux) use Segmentation with Paging. A process is divided into segments and individual segments have pages.

In Partition Allocation, when there is more than one partition freely available to accommodate a process’s request, a partition must be selected. To choose a particular partition, a partition allocation method is needed. A partition allocation method is considered better if it avoids internal fragmentation.

When it is time to load a process into the main memory and if there is more than one free block of memory of sufficient size then the OS decides which free block to allocate.

There are different Placement Algorithm:

A. First Fit

B. Best Fit

C. Worst Fit

D. Next Fit

1. First Fit: In the first fit, the partition is allocated which is the first sufficient block from the top of Main Memory. It scans memory from the beginning and chooses the first available block that is large enough. Thus it allocates the first hole that is large enough.

2. Best Fit Allocate the process to the partition which is the first smallest sufficient partition among the free available partition. It searches the entire list of holes to find the smallest hole whose size is greater than or equal to the size of the process.

3. Worst Fit Allocate the process to the partition which is the largest sufficient among the freely available partitions available in the main memory. It is opposite to the best-fit algorithm. It searches the entire list of holes to find the largest hole and allocate it to process.

4. Next Fit: Next fit is similar to the first fit but it will search for the first sufficient partition from the last allocation point.

Is Best-Fit really best?

Although best fit minimizes the wastage space, it consumes a lot of processor time for searching the block which is close to the required size. Also, Best-fit may perform poorer than other algorithms in some cases. For example, see the below exercise.

Exercise: Consider the requests from processes in given order 300K, 25K, 125K, and 50K. Let there be two blocks of memory available of size 150K followed by a block size 350K.

Which of the following partition allocation schemes can satisfy the above requests?

A) Best fit but not first fit.

B) First fit but not best fit.

C) Both First fit & Best fit.

D) neither first fit nor best fit.

Solution: Let us try all options.

Best Fit:

300K is allocated from a block of size 350K. 50 is left in the block.

25K is allocated from the remaining 50K block. 25K is left in the block.

125K is allocated from 150 K block. 25K is left in this block also.

50K can’t be allocated even if there is 25K + 25K space available.

First Fit:

300K request is allocated from 350K block, 50K is left out.

25K is be allocated from the 150K block, 125K is left out.

Then 125K and 50K are allocated to the remaining left out partitions.

So, the first fit can handle requests.

So option B is the correct choice.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : VaibhavRai3, harleenk_99, deepakmkoshy"
103,"In operating systems, Memory Management is the function responsible for allocating and managing computer’s main memory. Memory Management function keeps track of the status of each memory location, either allocated or free to ensure effective and efficient use of Primary Memory.

There are two Memory Management Techniques: Contiguous, and Non-Contiguous. In Contiguous Technique, executing process must be loaded entirely in main-memory. Contiguous Technique can be divided into:

Fixed (or static) partitioning Variable (or dynamic) partitioning

Fixed Partitioning:

This is the oldest and simplest technique used to put more than one processes in the main memory. In this partitioning, number of partitions (non-overlapping) in RAM are fixed but size of each partition may or may not be same. As it is contiguous allocation, hence no spanning is allowed. Here partition are made before execution or during system configure.

As illustrated in above figure, first process is only consuming 1MB out of 4MB in the main memory.

Hence, Internal Fragmentation in first block is (4-1) = 3MB.

Sum of Internal Fragmentation in every block = (4-1)+(8-7)+(8-7)+(16-14)= 3+1+1+2 = 7MB.

Suppose process P5 of size 7MB comes. But this process cannot be accommodated inspite of available free space because of contiguous allocation (as spanning is not allowed). Hence, 7MB becomes part of External Fragmentation.

There are some advantages and disadvantages of fixed partitioning.

Advantages of Fixed Partitioning –

Easy to implement:

Algorithms needed to implement Fixed Partitioning are easy to implement. It simply requires putting a process into certain partition without focussing on the emergence of Internal and External Fragmentation. Little OS overhead:

Processing of Fixed Partitioning require lesser excess and indirect computational power.

Disadvantages of Fixed Partitioning –

Internal Fragmentation:

Main memory use is inefficient. Any program, no matter how small, occupies an entire partition. This can cause internal fragmentation. External Fragmentation:

The total unused space (as stated above) of various partitions cannot be used to load the processes even though there is space available but not in the contiguous form (as spanning is not allowed). Limit process size:

Process of size greater than size of partition in Main Memory cannot be accommodated. Partition size cannot be varied according to the size of incoming process’s size. Hence, process size of 32MB in above stated example is invalid. Limitation on Degree of Multiprogramming:

Partition in Main Memory are made before execution or during system configure. Main Memory is divided into fixed number of partition. Suppose if there are partitions in RAM and are the number of processes, then condition must be fulfilled. Number of processes greater than number of partitions in RAM is invalid in Fixed Partitioning.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ayushnigam9424"
104,"In operating systems, Memory Management is the function responsible for allocating and managing computer’s main memory. Memory Management function keeps track of the status of each memory location, either allocated or free to ensure effective and efficient use of Primary Memory.

There are two Memory Management Techniques: Contiguous, and Non-Contiguous. In Contiguous Technique, executing process must be loaded entirely in main-memory. Contiguous Technique can be divided into:

Variable Partitioning –

It is a part of Contiguous allocation technique. It is used to alleviate the problem faced by Fixed Partitioning. In contrast with fixed partitioning, partitions are not made before the execution or during system configure. Various features associated with variable Partitioning-

Initially RAM is empty and partitions are made during the run-time according to process’s need instead of partitioning during system configure. The size of partition will be equal to incoming process. The partition size varies according to the need of the process so that the internal fragmentation can be avoided to ensure efficient utilisation of RAM. Number of partitions in RAM is not fixed and depends on the number of incoming process and Main Memory’s size.

There are some advantages and disadvantages of variable partitioning over fixed partitioning as given below.

Advantages of Variable Partitioning –

No Internal Fragmentation:

In variable Partitioning, space in main memory is allocated strictly according to the need of process, hence there is no case of internal fragmentation. There will be no unused space left in the partition. No restriction on Degree of Multiprogramming:

More number of processes can be accommodated due to absence of internal fragmentation. A process can be loaded until the memory is empty. No Limitation on the size of the process:

In Fixed partitioning, the process with the size greater than the size of the largest partition could not be loaded and process can not be divided as it is invalid in contiguous allocation technique. Here, In variable partitioning, the process size can’t be restricted since the partition size is decided according to the process size.

Disadvantages of Variable Partitioning –

Difficult Implementation:

Implementing variable Partitioning is difficult as compared to Fixed Partitioning as it involves allocation of memory during run-time rather than during system configure. External Fragmentation:

There will be external fragmentation inspite of absence of internal fragmentation. For example, suppose in above example- process P1(2MB) and process P3(1MB) completed their execution. Hence two spaces are left i.e. 2MB and 1MB. Let’s suppose process P5 of size 3MB comes. The empty space in memory cannot be allocated as no spanning is allowed in contiguous allocation. The rule says that process must be contiguously present in main memory to get executed. Hence it results in External Fragmentation. Now P5 of size 3 MB cannot be accommodated in spite of required available space because in contiguous no spanning is allowed.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ayushnigam9424"
105,"Prerequisite – Variable Partitioning, Fixed Partitioning

Paging and Segmentation are the two ways which allow a process’s physical address space to be non-contiguous. It has advantage of reducing memory wastage but it increases the overheads due to address translation. It slows the execution of the memory because time is consumed in address translation.

In non-contiguous allocation, Operating system needs to maintain the table which is called Page Table for each process which contains the base address of the each block which is acquired by the process in memory space. In non-contiguous memory allocation, different parts of a process is allocated different places in Main Memory. Spanning is allowed which is not possible in other techniques like Dynamic or Static Contiguous memory allocation. That’s why paging is needed to ensure effective memory allocation. Paging is done to remove External Fragmentation.

Working:

Here a process can be spanned across different spaces in main memory in non-consecutive manner. Suppose process P of size 4KB. Consider main memory have two empty slots each of size 2KB. Hence total free space is, 2*2= 4 KB. In contiguous memory allocation, process P cannot be accommodated as spanning is not allowed.

In contiguous allocation, space in memory should be allocated to whole process. If not, then that space remains unallocated. But in Non-Contiguous allocation, process can be divided into different parts and hence filling the space in main memory. In this example, process P can be divided into two parts of equal size – 2KB. Hence one part of process P can be allocated to first 2KB space of main memory and other part of processP can be allocated to second 2KB space of main memory. Below diagram will explain in better way:

But, in what manner we divide a process to allocate them into main memory is very important to understand. Process is divided after analysing the number of empty spaces and their size in main memory. Then only we divide our process. It is very time consuming process. Their number as well as their sizes changing every time due to execution of already present processes in main memory.

In order to avoid this time consuming process, we divide our process in secondary memory in advance before reaching the main memory for its execution. Every process is divided into various parts of equal size called Pages. We also divide our main memory into different parts of equal size called Frames. It is important to understand that:

Size of page in process = Size of frame in memory

Although their numbers can be different. Below diagram will make you understand in better way: consider empty main memory having size of each frame is 2 KB, and two processes P1 and P2 are 2 KB each.

Resolvent main memory,

In conclusion we can say that, Paging allows memory address space of a process to be non-contiguous. Paging is more flexible as only pages of a process are moved. It allows more processes to reside in main memory than Contiguous memory allocation.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : PulkitJoshi"
106,"Logical Address is generated by CPU while a program is running. The logical address is virtual address as it does not exist physically, therefore, it is also known as Virtual Address. This address is used as a reference to access the physical memory location by CPU. The term Logical Address Space is used for the set of all logical addresses generated by a program’s perspective.

The hardware device called Memory-Management Unit is used for mapping logical address to its corresponding physical address.

Physical Address identifies a physical location of required data in a memory. The user never directly deals with the physical address but can access by its corresponding logical address. The user program generates the logical address and thinks that the program is running in this logical address but the program needs physical memory for its execution, therefore, the logical address must be mapped to the physical address by MMU before they are used. The term Physical Address Space is used for all physical addresses corresponding to the logical addresses in a Logical address space.





Mapping virtual-address to physical-addresses

Differences Between Logical and Physical Address in Operating System

The basic difference between Logical and physical address is that Logical address is generated by CPU in perspective of a program whereas the physical address is a location that exists in the memory unit. Logical Address Space is the set of all logical addresses generated by CPU for a program whereas the set of all physical address mapped to corresponding logical addresses is called Physical Address Space. The logical address does not exist physically in the memory whereas physical address is a location in the memory that can be accessed physically. Identical logical addresses are generated by Compile-time and Load time address binding methods whereas they differs from each other in run-time address binding method. Please refer this for details. The logical address is generated by the CPU while the program is running whereas the physical address is computed by the Memory Management Unit (MMU).

Comparison Chart:

Paramenter LOGICAL ADDRESS PHYSICAL ADDRESS Basic generated by CPU location in a memory unit Address Space Logical Address Space is set of all logical addresses generated by CPU in reference to a program. Physical Address is set of all physical addresses mapped to the corresponding logical addresses. Visibility User can view the logical address of a program. User can never view physical address of program. Generation generated by the CPU Computed by MMU Access The user can use the logical address to access the physical address. The user can indirectly access physical address but not directly.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
107,"Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space of a process to be non – contiguous.

Logical Address or Virtual Address (represented in bits): An address generated by the CPU

Logical Address Space or Virtual Address Space( represented in words or bytes): The set of all logical addresses generated by a program

Physical Address (represented in bits): An address actually available on memory unit

Physical Address Space (represented in words or bytes): The set of all physical addresses corresponding to the logical addresses

Example:

If Logical Address = 31 bit, then Logical Address Space = 2 31 words = 2 G words (1 G = 2 30 )

words = 2 G words (1 G = 2 ) If Logical Address Space = 128 M words = 2 7 * 2 20 words, then Logical Address = log 2 2 27 = 27 bits

* 2 words, then Logical Address = log 2 = 27 bits If Physical Address = 22 bit, then Physical Address Space = 2 22 words = 4 M words (1 M = 2 20 )

words = 4 M words (1 M = 2 ) If Physical Address Space = 16 M words = 24 * 220 words, then Physical Address = log 2 224 = 24 bits

The mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device and this mapping is known as paging technique.

The Physical Address Space is conceptually divided into a number of fixed-size blocks, called frames .

. The Logical address Space is also splitted into fixed-size blocks, called pages .

. Page Size = Frame Size

Let us consider an example:

Physical Address = 12 bits, then Physical Address Space = 4 K words

Logical Address = 13 bits, then Logical Address Space = 8 K words

Page size = frame size = 1 K words (assumption)

Address generated by CPU is divided into

Page number(p): Number of bits required to represent the pages in Logical Address Space or Page number

Number of bits required to represent the pages in Logical Address Space or Page number Page offset(d): Number of bits required to represent particular word in a page or page size of Logical Address Space or word number of a page or page offset.

Physical Address is divided into

Frame number(f): Number of bits required to represent the frame of Physical Address Space or Frame number.

Number of bits required to represent the frame of Physical Address Space or Frame number. Frame offset(d): Number of bits required to represent particular word in a frame or frame size of Physical Address Space or word number of a frame or frame offset.

The hardware implementation of page table can be done by using dedicated registers. But the usage of register for the page table is satisfactory only if page table is small. If page table contain large number of entries then we can use TLB(translation Look-aside buffer), a special, small, fast look up hardware cache."
108,"Memory management keeps track of the status of each memory location, whether it is allocated or free. It allocates the memory dynamically to the programs at their request and frees it for reuse when it is no longer needed. Memory management meant to satisfy some requirements that we should keep in mind.

These Requirements of memory management are:

Relocation – The available memory is generally shared among a number of processes in a multiprogramming system, so it is not possible to know in advance which other programs will be resident in main memory at the time of execution of his program. Swapping the active processes in and out of the main memory enables the operating system to have a larger pool of ready-to-execute process.



When a program gets swapped out to a disk memory, then it is not always possible that when it is swapped back into main memory then it occupies the previous memory location, since the location may still be occupied by another process. We may need to relocate the process to a different area of memory. Thus there is a possibility that program may be moved in main memory due to swapping. The figure depicts a process image. The process image is occupying a continuous region of main memory. The operating system will need to know many things including the location of process control information, the execution stack, and the code entry. Within a program, there are memory references in various instructions and these are called logical addresses.



After loading of the program into main memory, the processor and the operating system must be able to translate logical addresses into physical addresses. Branch instructions contain the address of the next instruction to be executed. Data reference instructions contain the address of byte or word of data referenced.



Protection – There is always a danger when we have multiple programs at the same time as one program may write to the address space of another program. So every process must be protected against unwanted interference when other process tries to write in a process whether accidental or incidental. Between relocation and protection requirement a trade-off occurs as the satisfaction of relocation requirement increases the difficulty of satisfying the protection requirement.



Prediction of the location of a program in main memory is not possible, that’s why it is impossible to check the absolute address at compile time to assure protection. Most of the programming language allows the dynamic calculation of address at run time. The memory protection requirement must be satisfied by the processor rather than the operating system because the operating system can hardly control a process when it occupies the processor. Thus it is possible to check the validity of memory references. Sharing – A protection mechanism must have to allow several processes to access the same portion of main memory. Allowing each processes access to the same copy of the program rather than have their own separate copy has an advantage.



For example, multiple processes may use the same system file and it is natural to load one copy of the file in main memory and let it shared by those processes. It is the task of Memory management to allow controlled access to the shared areas of memory without compromising the protection. Mechanisms are used to support relocation supported sharing capabilities. Logical organization – Main memory is organized as linear or it can be a one-dimensional address space which consists of a sequence of bytes or words. Most of the programs can be organized into modules, some of those are unmodifiable (read-only, execute only) and some of those contain data that can be modified. To effectively deal with a user program, the operating system and computer hardware must support a basic module to provide the required protection and sharing. It has the following advantages:

Modules are written and compiled independently and all the references from one module to another module are resolved by `the system at run time.

Different modules are provided with different degrees of protection.

There are mechanisms by which modules can be shared among processes. Sharing can be provided on a module level that lets the user specify the sharing that is desired. Physical organization – The structure of computer memory has two levels referred to as main memory and secondary memory. Main memory is relatively very fast and costly as compared to the secondary memory. Main memory is volatile. Thus secondary memory is provided for storage of data on a long-term basis while the main memory holds currently used programs. The major system concern between main memory and secondary memory is the flow of information and it is impractical for programmers to understand this for two reasons:

The programmer may engage in a practice known as overlaying when the main memory available for a program and its data may be insufficient. It allows different modules to be assigned to the same region of memory. One disadvantage is that it is time-consuming for the programmer.

In a multiprogramming environment, the programmer does not know how much space will be available at the time of coding and where that space will be located inside the memory.



Reference: Internals and design Principles,7th edition by William Stallings

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
109,"Memory consists of large array of words or arrays, each of which has address associated with it. Now the work of CPU is to fetch instructions from the memory based program counter. Now further these instruction may cause loading or storing to specific memory address.

Address binding is the process of mapping from one address space to another address space. Logical address is address generated by CPU during execution whereas Physical Address refers to location in memory unit(the one that is loaded into memory).Note that user deals with only logical address(Virtual address). The logical address undergoes translation by the MMU or address translation unit in particular. The output of this process is the appropriate physical address or the location of code/data in RAM.

An address binding can be done in three different ways:

Compile Time – If you know that during compile time where process will reside in memory then absolute address is generated i.e physical address is embedded to the executable of the program during compilation. Loading the executable as a process in memory is very fast. But if the generated address space is preoccupied by other process, then the program crashes and it becomes necessary to recompile the program to change the address space.

Load time – If it is not known at the compile time where process will reside then relocatable address will be generated. Loader translates the relocatable address to absolute address. The base address of the process in main memory is added to all logical addresses by the loader to generate absolute address. In this if the base address of the process changes then we need to reload the process again.

Execution time- The instructions are in memory and are being processed by the CPU. Additional memory may be allocated and/or deallocated at this time. This is used if process can be moved from one memory to another during execution(dynamic linking-Linking that is done during load or run time). e.g – Compaction.

MMU(Memory Management Unit)-

The run time mapping between Virtual address and Physical Address is done by hardware device known as MMU.

In memory management, Operating System will handle the processes and moves the processes between disk and memory for execution . It keeps the track of available and used memory.

Instruction-execution cycle Follows steps:

First instruction is fetched from memory e.g. ADD A,B Then these instructions are decoded i.e., Addition of A and B And further loading or storing at some particular memory location takes place.

Basic Hardware

As main memory and registers are built into processor and CPU can access these only.So every instructions should be written in direct access storage

devices.

If CPU access instruction from register then it can be done in one CPU clock cycle as registers are built into CPU. If instruction resides in main memory then it will be accessed via memory bus that will take lot of time. So remedy to this add fast memory in between CPU and main memory i.e. adding cache for transaction. Now we should insure that process resides in legal address. Legal address consists of base register(holds smallest physical address) and limit register(size of range).

For example:

Base register = 300040 limit register = 120900 then legal address = (300040+120900)= 420940(inclusive). legal address = base register+ limit register

How processes are mapped from disk to memory

Usually process resides in disk in form of binary executable file. So to execute process it should reside in main memory. Process is moved from disk to memory based on memory management in use. The processes waits in disk in form of ready queue to acquire memory.

Procedure of mapping of disk and memory

Normal procedure is that process is selected from input queue and loaded in memory. As process executes it accesses data and instructions from memory and as soon as it completes it will release memory and now memory will be available for other processes.

MMU scheme –

CPU------- MMU------Memory

CPU will generate logical address for eg: 346 MMU will generate relocation register(base register) for eg:14000 In Memory physical address is located eg:(346+14000= 14346)

Reference and Image Source:

https://users.dimi.uniud.it/~antonio.dangelo/OpSys/materials/Operating_System_Concepts.pdf

This article is contributed by Vaishali Bhatia.If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : NEERAJ NEGI"
110,"Prerequisite – Paging

Page table has page table entries where each page table entry stores a frame number and optional status (like protection) bits. Many of status bits used in the virtual memory system. The most important thing in PTE is frame Number.

Page table entry has the following information –"
111,"Virtual Memory is a storage allocation scheme in which secondary memory can be addressed as though it were part of main memory. The addresses a program may use to reference memory are distinguished from the addresses the memory system uses to identify physical storage sites, and program generated addresses are translated automatically to the corresponding machine addresses.

The size of virtual storage is limited by the addressing scheme of the computer system and amount of secondary memory is available not by the actual number of the main storage locations.

It is a technique that is implemented using both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.

All memory references within a process are logical addresses that are dynamically translated into physical addresses at run time. This means that a process can be swapped in and out of main memory such that it occupies different places in main memory at different times during the course of execution. A process may be broken into number of pieces and these pieces need not be continuously located in the main memory during execution. The combination of dynamic run-time address translation and use of page or segment table permits this.

If these characteristics are present then, it is not necessary that all the pages or segments are present in the main memory during execution. This means that the required pages need to be loaded into memory whenever required. Virtual memory is implemented using Demand Paging or Demand Segmentation.

Demand Paging :

The process of loading the page into memory on demand (whenever page fault occurs) is known as demand paging.

The process includes the following steps :



If CPU try to refer a page that is currently not available in the main memory, it generates an interrupt indicating memory access fault. The OS puts the interrupted process in a blocking state. For the execution to proceed the OS must bring the required page into the memory. The OS will search for the required page in the logical address space. The required page will be brought from logical address space to physical address space. The page replacement algorithms are used for the decision making of replacing the page in physical address space. The page table will updated accordingly. The signal will be sent to the CPU to continue the program execution and it will place the process back into ready state.

Hence whenever a page fault occurs these steps are followed by the operating system and the required page is brought into memory.

Advantages :

More processes may be maintained in the main memory: Because we are going to load only some of the pages of any particular process, there is room for more processes. This leads to more efficient utilization of the processor because it is more likely that at least one of the more numerous processes will be in the ready state at any particular time.

A process may be larger than all of main memory: One of the most fundamental restrictions in programming is lifted. A process larger than the main memory can be executed because of demand paging. The OS itself loads pages of a process in main memory as required.

It allows greater multiprogramming levels by using less of the available (primary) memory for each process.

Page Fault Service Time :

The time taken to service the page fault is called as page fault service time. The page fault service time includes the time taken to perform all the above six steps.

Let Main memory access time is: m Page fault service time is: s Page fault rate is : p Then, Effective memory access time = (p*s) + (1-p)*m

Swapping:

Swapping a process out means removing all of its pages from memory, or marking them so that they will be removed by the normal page replacement process. Suspending a process ensures that it is not runnable while it is swapped out. At some later time, the system swaps back the process from the secondary storage to main memory. When a process is busy swapping pages in and out then this situation is called thrashing.

Thrashing :



At any given time, only few pages of any process are in main memory and therefore more processes can be maintained in memory. Furthermore time is saved because unused pages are not swapped in and out of memory. However, the OS must be clever about how it manages this scheme. In the steady state practically, all of main memory will be occupied with process’s pages, so that the processor and OS has direct access to as many processes as possible. Thus when the OS brings one page in, it must throw another out. If it throws out a page just before it is used, then it will just have to get that page again almost immediately. Too much of this leads to a condition called Thrashing. The system spends most of its time swapping pages rather than executing instructions. So a good page replacement algorithm is required.



In the given diagram, initial degree of multi programming upto some extent of point(lamda), the CPU utilization is very high and the system resources are utilized 100%. But if we further increase the degree of multi programming the CPU utilization will drastically fall down and the system will spent more time only in the page replacement and the time taken to complete the execution of the process will increase. This situation in the system is called as thrashing.



Causes of Thrashing :

High degree of multiprogramming : If the number of processes keeps on increasing in the memory than number of frames allocated to each process will be decreased. So, less number of frames will be available to each process. Due to this, page fault will occur more frequently and more CPU time will be wasted in just swapping in and out of pages and the utilization will keep on decreasing. For example:

Let free frames = 400

Case 1: Number of process = 100

Then, each process will get 4 frames. Case 2: Number of process = 400

Each process will get 1 frame.

Case 2 is a condition of thrashing, as the number of processes are increased,frames per process are decreased. Hence CPU time will be consumed in just swapping pages. Lacks of Frames:If a process has less number of frames then less pages of that process will be able to reside in memory and hence more frequent swapping in and out will be required. This may lead to thrashing. Hence sufficient amount of frames must be allocated to each process in order to prevent thrashing.

Recovery of Thrashing :

Do not allow the system to go into thrashing by instructing the long term scheduler not to bring the processes into memory after the threshold.

If the system is already in thrashing then instruct the mid term schedular to suspend some of the processes so that we can recover the system from thrashing.



This article is contributed by Aakansha yadav

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : nidhi_biet"
112,"Prerequisite – Virtual Memory

Abstraction is one the most important aspect of computing. It is widely implemented Practice in the Computational field.

Memory Interleaving is less or More an Abstraction technique. Though its a bit different from Abstraction. It is a Technique which divides memory into a number of modules such that Successive words in the address space are placed in the Different module.

Consecutive Word in a Module:





Figure-1: Consecutive Word in a Module

Let us assume 16 Data’s to be Transferred to the Four Module. Where Module 00 be Module 1, Module 01 be Module 2, Module 10 be Module 3 & Module 11 be Module 4. Also 10, 20, 30….130 are the data to be transferred.

From the figure above in Module 1, 10 [Data] is transferred then 20, 30 & finally, 40 which are the Data. That means the data are added consecutively in the Module till its max capacity.

Most significant bit (MSB) provides the Address of the Module & least significant bit (LSB) provides the address of the data in the module.

For Example, to get 90 (Data) 1000 will be provided by the processor. In this 10 will indicate that the data is in module 10 (module 3) & 00 is the address of 90 in Module 10 (module 3). So,

Module 1 Contains Data : 10, 20, 30, 40 Module 2 Contains Data : 50, 60, 70, 80 Module 3 Contains Data : 90, 100, 110, 120 Module 4 Contains Data : 130, 140, 150, 160

Consecutive Word in Consecutive Module:





Figure-2: Consecutive Word in Consecutive Module

Now again we assume 16 Data’s to be transferred to the Four Module. But Now the consecutive Data are added in Consecutive Module. That is, 10 [Data] is added in Module 1, 20 [Data] in Module 2 and So on.

Least Significant Bit (LSB) provides the Address of the Module & Most significant bit (MSB) provides the address of the data in the module.

For Example, to get 90 (Data) 1000 will be provided by the processor. In this 00 will indicate that the data is in module 00 (module 1) & 10 is the address of 90 in Module 00 (module 1). That is,

Module 1 Contains Data : 10, 50, 90, 130 Module 2 Contains Data : 20, 60, 100, 140 Module 3 Contains Data : 30, 70, 110, 150 Module 4 Contains Data : 40, 80, 120, 160

Why we use Memory Interleaving? [Advantages]:

Whenever, Processor request Data from the main memory. A block (chunk) of Data is Transferred to the cache and then to Processor. So whenever a cache miss occurs the Data is to be fetched from main memory. But main memory is relatively slower than the cache. So to improve the access time of the main memory interleaving is used.

We can access all four Module at the same time thus achieving Parallelism. From Figure 2 the data can be acquired from the Module using the Higher bits. This method Uses memory effectively.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
113,"Advantages

Large virtual memory.

More efficient use of memory.

Unconstrained multiprogramming. There is no limit on degree of multiprogramming.

Disadvantages

Number of tables and amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.

Due to lack of an explicit constraint on a job’s address space size.

A way to control Thrashing

Set the lower and upper bounds of page fault rate for each process. Using the above step, establish ‘acceptable’ page fault rate.

If actual rate is lower than lower bound, decrease the number of frames

If actual rate is larger than upper bound, increase the number of frames.

Q1. Virtual memory is

(a) Large secondary memory

(b) Large main memory

(c) Illusion of large main memory

(d) None of the above



Answer: (c)

Explanation: Virtual memory is illusion of large main memory.



Q2. Thrashing occurs when

(a)When a page fault occurs

(b) Processes on system frequently access pages not memory

(c) Processes on system are in running state

(d) Processes on system are in waiting state



Answer: (b)

Explanation: Thrashing occurs when processes on system require more memory than it has. If processes do not have “enough” pages, the page fault rate is very high. This leads to:

– low CPU utilization

– operating system spends most of its time swapping to disk

The above situation is called thrashing





Q3. A computer system supports 32-bit virtual addresses as well as 32-bit physical addresses. Since the virtual address space is of the same size as the physical address space, the operating system designers decide to get rid of the virtual memory entirely. Which one of the following is true?

(a) Efficient implementation of multi-user support is no longer possible

(b) The processor cache organization can be made more efficient now

(c) Hardware support for memory management is no longer needed

(d) CPU scheduling can be made more efficient now



Answer: (c)

Explanation: For supporting virtual memory, special hardware support is needed from Memory Management Unit. Since operating system designers decide to get rid of the virtual memory entirely, hardware support for memory management is no longer needed.

This article is contributed by Mithlesh Upadhyay

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
114,"Prerequisites – Types of Server Virtualization, Hardware based Virtualization

Operating system based Virtualization refers to an operating system feature in which the kernel enables the existence of various isolated user-space instances. The installation of virtualization software also refers to Operating system-based virtualization. It is installed over a pre-existing operating system and that operating system is called the host operating system.

In this virtualization, a user installs the virtualization software in the operating system of his system like any other program and utilize this application to operate and generate various virtual machines. Here, the virtualization software allows direct access to any of the created virtual machine to the user. As the host OS can provide hardware devices with the mandatory support, operating system virtualization may affect compatibility issues of hardware even when the hardware driver is not allocated to the virtualization software.

Virtualization software is able to convert hardware IT resources which require unique software for operation into virtualized IT resources. As the host OS is a complete operating system in itself, many OS based services are available as organizational management and administration tools can be utilized for the virtualization host management.

Some major operating system-based services are mentioned below:

Backup and Recovery. Security Management. Integration to Directory Services.

Various major operations of Operating System Based Virtualization are described below:

Hardware capabilities which can be employed, such as the network connection and CPU. Connected peripherals with which it can interact with, such as webcam, printer, keyboard, or Scanners. Data which can be read or written, such as files, folders and network shares.

The Operating system may have the capability to allow or deny access to such resources based on which program requests them and the user account in the context of which it runs. OS may also hide these resources, which leads that when computer program computes them, they do not appear in the enumeration results. Nevertheless, from a programming perspective, the computer program has interacted with those resources and the operating system has managed an act of interaction.

With operating-system-virtualization, or containerization, it is probable to run programs within containers, to which only parts of these resources are allocated. A program which is expected to perceive the whole computer, once run inside a container, can only see the allocated resources and believes them to be all that is available. Several containers can be formed on each operating system, to each of which a subset of the computer’s resources is allocated. Each container may include many computer programs. These programs may run parallel or distinctly, even interrelate with each other.

Operating system-based virtualization can raise demands and problems related to performance overhead, such as:

The host operating system employs CPU, memory, and other hardware IT resources. Hardware-related calls from guest operating systems need to navigate numerous layers to and from the hardware, which shrinkage overall performance. Licenses are frequently essential for host operating systems, in addition to individual licenses for each of their guest operating systems.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
115,"Prerequisite – Paging, Page table entries, Segmentation

Most of the Operating Systems implement a separate pagetable for each process, i.e. for ‘n’ number of processes running on a Multiprocessing/ Timesharing operating system, there are ‘n’ number of pagetables stored in the memory. Sometimes when a process is very large in size and it occupies virtual memory then with the size of the process, it’s pagetable size also increases substantially.

Example: A process of size 2 GB with: Page size = 512 Bytes Size of page table entry = 4 Bytes, then Number of pages in the process = 2 GB / 512 B = 222 PageTable Size = 222 * 22 = 224 bytes

Through this example, it can be concluded that for multiple processes running simultaneously in an OS, a considerable part of memory is occupied by page tables only.

Operating Systems also incorporate multilevel paging schemes which further increase the space required for storing the page tables and a large amount of memory is invested in storing them. The amount of memory occupied by the page tables can turn out to be a huge overhead and is always unacceptable as main memory is always a scarce resource. Various efforts are made to utilize the memory efficiently and to maintain a good balance in the level of multiprogramming and efficient CPU utilization.

Inverted Page Table –

An alternate approach is to use the Inverted Page Table structure that consists of one-page table entry for every frame of the main memory. So the number of page table entries in the Inverted Page Table reduces to the number of frames in physical memory and a single page table is used to represent the paging information of all the processes.

Through the inverted page table, the overhead of storing an individual page table for every process gets eliminated and only a fixed portion of memory is required to store the paging information of all the processes together. This technique is called as inverted paging as the indexing is done with respect to the frame number instead of the logical page number. Each entry in the page table contains the following fields.

Page number – It specifies the page number range of the logical address.

It specifies the page number range of the logical address. Process id – An inverted page table contains the address space information of all the processes in execution. Since two different processes can have similar set of virtual addresses, it becomes necessary in Inverted Page Table to store a process Id of each process to identify it’s address space uniquely. This is done by using the combination of PId and Page Number. So this Process Id acts as an address space identifier and ensures that a virtual page for a particular process is mapped correctly to the corresponding physical frame.

An inverted page table contains the address space information of all the processes in execution. Since two different processes can have similar set of virtual addresses, it becomes necessary in Inverted Page Table to store a process Id of each process to identify it’s address space uniquely. This is done by using the combination of PId and Page Number. So this Process Id acts as an address space identifier and ensures that a virtual page for a particular process is mapped correctly to the corresponding physical frame. Control bits – These bits are used to store extra paging-related information. These include the valid bit, dirty bit, reference bits, protection and locking information bits.

These bits are used to store extra paging-related information. These include the valid bit, dirty bit, reference bits, protection and locking information bits. Chained pointer – It may be possible sometime that two or more processes share a part of main memory. In this case, two or more logical pages map to same Page Table Entry then a chaining pointer is used to map the details of these logical pages to the root page table.

Working – The operation of an inverted page table is shown below.

The virtual address generated by the CPU contains the fields and each page table entry contains and the other relevant information required in paging related mechanism. When a memory reference takes place, this virtual address is matched by the memory-mapping unit and the Inverted Page table is searched to match the and the corresponding frame number is obtained. If the match is found at the ith entry then the physical address of the process, , is sent as the real address otherwise if no match is found then Segmentation Fault is generated.

Note: Number of Entries in Inverted page table = Number of frames in Physical address Space(PAS)

Examples – The Inverted Page table and its variations are implemented in various systems like PowerPC, UltraSPARC and the IA-64 architecture. An implementation of the Mach operating system on the RT-PC also uses this technique.

Advantages and Disadvantages:

Reduced memory space –

Inverted Pagetables typically reduces the amount of memory required to store the page tables to a size bound of physical memory. The maximum number of entries could be the number of page frames in the physical memory.

Inverted Pagetables typically reduces the amount of memory required to store the page tables to a size bound of physical memory. The maximum number of entries could be the number of page frames in the physical memory. Longer lookup time –

Inverted Page tables are sorted in order of frame number but the memory look-up takes place with respect to the virtual address, so, it usually takes a longer time to find the appropriate entry but often these page tables are implemented using hash data structures for a faster lookup.

Inverted Page tables are sorted in order of frame number but the memory look-up takes place with respect to the virtual address, so, it usually takes a longer time to find the appropriate entry but often these page tables are implemented using hash data structures for a faster lookup. Difficult shared memory implementation –

As the Inverted Page Table stores a single entry for each frame, it becomes difficult to implement the shared memory in the page tables. Chaining techniques are used to map more than one virtual address to the entry specified in order of frame number.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
116,"A computer has sufficient amount of physical memory but most of times we need more so we swap some memory on disk. Swap space is a space on hard disk which is a substitute of physical memory. It is used as virtual memory which contains process memory image. Whenever our computer run short of physical memory it uses it’s virtual memory and stores information in memory on disk. Swap space helps the computer’s operating system in pretending that it have more RAM than it actually has. It is also called as swap file.This interchange of data between virtual memory and real memory is called as swapping and space on disk as “swap space”.

Virtual memory is a combination of RAM and disk space that running processes can use. Swap space is the portion of virtual memory that is on the hard disk, used when RAM is full.

Swap space can be useful to computer in various ways:

It can be used as a single contiguous memory which reduces i/o operations to read or write a file.

Applications which are not used or are used less can be kept in swap file.

Having sufficient swap file helps the system keep some physical memory free all the time.

The space in physical memory which has been freed due to swap space can be used by OS for some other important tasks.

In operating systems such as Windows, Linux, etc systems provide a certain amount of swap space by default which can be changed by users according to their needs. If you don’t want to use virtual memory you can easily disable it all together but in case if you run out of memory then kernel will kill some of the processes in order to create a sufficient amount of space in physical memory. So it totally depends upon user whether he wants to use swap space or not.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
117,"A page fault occurs when a program attempts to access data or code that is in its address space, but is not currently located in the system RAM. So when page fault occurs then following sequence of events happens :

The computer hardware traps to the kernel and program counter (PC) is saved on the stack. Current instruction state information is saved in CPU registers.

An assembly program is started to save the general registers and other volatile information to keep the OS from destroying it.

Operating system finds that a page fault has occurred and tries to find out which virtual page is needed. Some times hardware register contains this required information. If not, the operating system must retrieve PC, fetch instruction and find out what it was doing when the fault occurred.

Once virtual address caused page fault is known, system checks to see if address is valid and checks if there is no protection access problem.

If the virtual address is valid, the system checks to see if a page frame is free. If no frames are free, the page replacement algorithm is run to remove a page.

If frame selected is dirty, page is scheduled for transfer to disk, context switch takes place, fault process is suspended and another process is made to run until disk transfer is completed.

As soon as page frame is clean, operating system looks up disk address where needed page is, schedules disk operation to bring it in.

When disk interrupt indicates page has arrived, page tables are updated to reflect its position, and frame marked as being in normal state.

Faulting instruction is backed up to state it had when it began and PC is reset. Faulting is scheduled, operating system returns to routine that called it.

Assembly Routine reloads register and other state information, returns to user space to continue execution.

References –

cs.uttyler.edu

professormerwyn.wordpress.com

This article is contributed by Swasthik. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
118,"In operating systems, Memory Management is the function responsible for allocating and managing computer’s main memory. Memory Management function keeps track of the status of each memory location, either allocated or free to ensure effective and efficient use of Primary Memory.

There are two Memory Management Techniques: Contiguous, and Non-Contiguous. In Contiguous Technique, executing process must be loaded entirely in main-memory. Contiguous Technique can be divided into:

Fixed (or static) partitioning Variable (or dynamic) partitioning

Fixed Partitioning:

This is the oldest and simplest technique used to put more than one processes in the main memory. In this partitioning, number of partitions (non-overlapping) in RAM are fixed but size of each partition may or may not be same. As it is contiguous allocation, hence no spanning is allowed. Here partition are made before execution or during system configure.

As illustrated in above figure, first process is only consuming 1MB out of 4MB in the main memory.

Hence, Internal Fragmentation in first block is (4-1) = 3MB.

Sum of Internal Fragmentation in every block = (4-1)+(8-7)+(8-7)+(16-14)= 3+1+1+2 = 7MB.

Suppose process P5 of size 7MB comes. But this process cannot be accommodated inspite of available free space because of contiguous allocation (as spanning is not allowed). Hence, 7MB becomes part of External Fragmentation.

There are some advantages and disadvantages of fixed partitioning.

Advantages of Fixed Partitioning –

Easy to implement:

Algorithms needed to implement Fixed Partitioning are easy to implement. It simply requires putting a process into certain partition without focussing on the emergence of Internal and External Fragmentation. Little OS overhead:

Processing of Fixed Partitioning require lesser excess and indirect computational power.

Disadvantages of Fixed Partitioning –

Internal Fragmentation:

Main memory use is inefficient. Any program, no matter how small, occupies an entire partition. This can cause internal fragmentation. External Fragmentation:

The total unused space (as stated above) of various partitions cannot be used to load the processes even though there is space available but not in the contiguous form (as spanning is not allowed). Limit process size:

Process of size greater than size of partition in Main Memory cannot be accommodated. Partition size cannot be varied according to the size of incoming process’s size. Hence, process size of 32MB in above stated example is invalid. Limitation on Degree of Multiprogramming:

Partition in Main Memory are made before execution or during system configure. Main Memory is divided into fixed number of partition. Suppose if there are partitions in RAM and are the number of processes, then condition must be fulfilled. Number of processes greater than number of partitions in RAM is invalid in Fixed Partitioning.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ayushnigam9424"
119,"A process is divided into Segments. The chunks that a program is divided into which are not necessarily all of the same sizes are called segments. Segmentation gives user’s view of the process which paging does not give. Here the user’s view is mapped to physical memory.

There are types of segmentation:

Virtual memory segmentation –

Each process is divided into a number of segments, not all of which are resident at any one point in time. Simple segmentation –

Each process is divided into a number of segments, all of which are loaded into memory at run time, though not necessarily contiguously.

There is no simple relationship between logical addresses and physical addresses in segmentation. A table stores the information about all such segments and is called Segment Table.

Segment Table – It maps two-dimensional Logical address into one-dimensional Physical address. It’s each table entry has:

Base Address: It contains the starting physical address where the segments reside in memory.

It contains the starting physical address where the segments reside in memory. Limit: It specifies the length of the segment.

Translation of Two dimensional Logical Address to one dimensional Physical Address.

Address generated by the CPU is divided into:

Segment number (s): Number of bits required to represent the segment.

Number of bits required to represent the segment. Segment offset (d): Number of bits required to represent the size of the segment.

Advantages of Segmentation –

No Internal fragmentation.

Segment Table consumes less space in comparison to Page table in paging.

Disadvantage of Segmentation –

As processes are loaded and removed from the memory, the free memory space is broken into little pieces, causing External fragmentation.

This article has been contributed by Vikash Kumar. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : VaibhavRai3"
120,"Prerequisite – Segmentation

Segmentation is the process in which the main memory of the computer is logically divided into different segments and each segment has its own base address. It is basically used to enhance the speed of execution of the computer system, so that the processor is able to fetch and execute the data from the memory easily and fast.

Need for Segmentation –

The Bus Interface Unit (BIU) contains four 16 bit special purpose registers (mentioned below) called as Segment Registers.

Code segment register (CS): is used for addressing memory location in the code segment of the memory, where the executable program is stored.

is used for addressing memory location in the code segment of the memory, where the executable program is stored. Data segment register (DS): points to the data segment of the memory where the data is stored.

points to the data segment of the memory where the data is stored. Extra Segment Register (ES): also refers to a segment in the memory which is another data segment in the memory.

also refers to a segment in the memory which is another data segment in the memory. Stack Segment Register (SS): is used for addressing stack segment of the memory. The stack segment is that segment of memory which is used to store stack data.

The number of address lines in 8086 is 20, 8086 BIU will send 20bit address, so as to access one of the 1MB memory locations. The four segment registers actually contain the upper 16 bits of the starting addresses of the four memory segments of 64 KB each with which the 8086 is working at that instant of time. A segment is a logical unit of memory that may be up to 64 kilobytes long. Each segment is made up of contiguous memory locations. It is an independent, separately addressable unit. Starting address will always be changing. It will not be fixed.

Note that the 8086 does not work the whole 1MB memory at any given time. However, it works only with four 64KB segments within the whole 1MB memory.

Below is the one way of positioning four 64 kilobyte segments within the 1M byte memory space of an 8086.

Types Of Segmentation –

Overlapping Segment – A segment starts at a particular address and its maximum size can go up to 64kilobytes. But if another segment starts along with this 64kilobytes location of the first segment, then the two are said to be Overlapping Segment. Non-Overlapped Segment – A segment starts at a particular address and its maximum size can go up to 64kilobytes. But if another segment starts before this 64kilobytes location of the first segment, then the two segments are said to be Non-Overlapped Segment.

Rules of Segmentation Segmentation process follows some rules as follows:"
121,"Prerequisite: Partition allocation methods

What is Next Fit ?

Next fit is a modified version of ‘first fit’. It begins as the first fit to find a free partition but when called next time it starts searching from where it left off, not from the beginning. This policy makes use of a roving pointer. The pointer moves along the memory chain to search for a next fit. This helps in, to avoid the usage of memory always from the head (beginning) of the free block chain.

What are its advantage over first fit ?

First fit is a straight and fast algorithm, but tends to cut large portion of free parts into small pieces due to which, processes that need a large portion of memory block would not get anything even if the sum of all small pieces is greater than it required which is so-called external fragmentation problem.

Another problem of the first fit is that it tends to allocate memory parts at the beginning of the memory, which may lead to more internal fragments at the beginning. Next fit tries to address this problem by starting the search for the free portion of parts not from the start of the memory, but from where it ends last time.

Next fit is a very fast searching algorithm and is also comparatively faster than First Fit and Best Fit Memory Management Algorithms.

Example: Input : blockSize[] = {5, 10, 20}; processSize[] = {10, 20, 30}; Output: Process No. Process Size Block no. 1 10 2 2 20 3 3 30 Not Allocated

Algorithm:

Input the number of memory blocks and their sizes and initializes all the blocks as free. Input the number of processes and their sizes. Start by picking each process and check if it can be assigned to the current block, if yes, allocate it the required memory and check for next process but from the block where we left not from starting. If the current block size is smaller then keep checking the further blocks.

C++ filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; void NextFit( int blockSize[], int m, int processSize[], int n) { int allocation[n], j = 0; memset (allocation, -1, sizeof (allocation)); for ( int i = 0; i < n; i++) { while (j < m) { if (blockSize[j] >= processSize[i]) { allocation[i] = j; blockSize[j] -= processSize[i]; break ; } j = (j + 1) % m; } } cout << ""

Process No.\tProcess Size\tBlock no.

"" ; for ( int i = 0; i < n; i++) { cout << "" "" << i + 1 << ""\t\t"" << processSize[i] << ""\t\t"" ; if (allocation[i] != -1) cout << allocation[i] + 1; else cout << ""Not Allocated"" ; cout << endl; } } int main() { int blockSize[] = { 5, 10, 20 }; int processSize[] = { 10, 20, 5 }; int m = sizeof (blockSize) / sizeof (blockSize[0]); int n = sizeof (processSize) / sizeof (processSize[0]); NextFit(blockSize, m, processSize, n); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.Arrays; public class GFG { static void NextFit( int blockSize[], int m, int processSize[], int n) { int allocation[] = new int [n], j = 0 ; Arrays.fill(allocation, - 1 ); for ( int i = 0 ; i < n; i++) { while (j < m) { if (blockSize[j] >= processSize[i]) { allocation[i] = j; blockSize[j] -= processSize[i]; break ; } j = (j + 1 ) % m; } } System.out.print( ""

Process No.\tProcess Size\tBlock no.

"" ); for ( int i = 0 ; i < n; i++) { System.out.print( i + 1 + ""\t\t"" + processSize[i] + ""\t\t"" ); if (allocation[i] != - 1 ) { System.out.print(allocation[i] + 1 ); } else { System.out.print( ""Not Allocated"" ); } System.out.println( """" ); } } static public void main(String[] args) { int blockSize[] = { 5 , 10 , 20 }; int processSize[] = { 10 , 20 , 5 }; int m = blockSize.length; int n = processSize.length; NextFit(blockSize, m, processSize, n); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def NextFit(blockSize, m, processSize, n): allocation = [ - 1 ] * n j = 0 for i in range (n): while j < m: if blockSize[j] > = processSize[i]: allocation[i] = j blockSize[j] - = processSize[i] break j = (j + 1 ) % m print ( ""Process No. Process Size Block no."" ) for i in range (n): print (i + 1 , "" "" , processSize[i], end = "" "" ) if allocation[i] ! = - 1 : print (allocation[i] + 1 ) else : print ( ""Not Allocated"" ) if __name__ = = '__main__' : blockSize = [ 5 , 10 , 20 ] processSize = [ 10 , 20 , 5 ] m = len (blockSize) n = len (processSize) NextFit(blockSize, m, processSize, n) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Linq; public class GFG { static void NextFit( int []blockSize, int m, int []processSize, int n) { int []allocation = new int [n]; int j = 0; Enumerable.Repeat(-1, n).ToArray(); for ( int i = 0; i < n; i++) { while (j < m) { if (blockSize[j] >= processSize[i]) { allocation[i] = j; blockSize[j] -= processSize[i]; break ; } j = (j + 1) % m; } } Console.Write( ""

Process No.\tProcess Size\tBlock no.

"" ); for ( int i = 0; i < n; i++) { Console.Write( i + 1 + ""\t\t"" + processSize[i] + ""\t\t"" ); if (allocation[i] != -1) { Console.Write(allocation[i] + 1); } else { Console.Write( ""Not Allocated"" ); } Console.WriteLine( """" ); } } static public void Main() { int []blockSize = {5, 10, 20}; int []processSize = {10, 20, 5}; int m = blockSize.Length; int n = processSize.Length; NextFit(blockSize, m, processSize, n); } } chevron_right filter_none PHP filter_none edit

close play_arrow link

brightness_4

code <?php function NextFit( $blockSize , $m , $processSize , $n ) { $allocation = array_fill (0, $n , -1); $j = 0; for ( $i = 0; $i < $n ; $i ++) { while ( $j < $m ) { if ( $blockSize [ $j ] >= $processSize [ $i ]) { $allocation [ $i ] = $j ; $blockSize [ $j ] -= $processSize [ $i ]; break ; } $j = ( $j + 1) % $m ; } } echo ""

Process No.\tProcess Size\tBlock no.

"" ; for ( $i = 0; $i < $n ; $i ++) { echo "" "" .( $i + 1). ""\t\t"" . $processSize [ $i ]. ""\t\t"" ; if ( $allocation [ $i ] != -1) echo ( $allocation [ $i ] + 1); else echo ""Not Allocated"" ; echo ""

"" ; } } $blockSize = array ( 5, 10, 20 ); $processSize = array ( 10, 20, 5 ); $m = count ( $blockSize ); $n = count ( $processSize ); NextFit( $blockSize , $m , $processSize , $n ); ?> chevron_right filter_none

Output:



Process No. Process Size Block no. 1 10 2 2 20 3 3 5 1

This article is contributed by Akash Gupta. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready."
122,"The main problem in Fixed partitioning is the size of a process has to be limited by the maximum size of the partition, which means a process can never be span over another.In order to solve this problem, earlier people have used some solution which is called as Overlays.

The concept of overlays is that whenever a process is running it will not use the complete program at the same time, it will use only some part of it.Then overlays concept says that whatever part you required, you load it an once the part is done, then you just unload it, means just pull it back and get the new part you required and run it.

Formally,

“The process of transferring a block of program code or other data into internal memory, replacing what is already stored”.

Sometimes it happens that compare to the size of the biggest partition, the size of the program will be even more, then, in that case, you should go with overlays.

So overlay is a technique to run a program that is bigger than the size of the physical memory by keeping only those instructions and data that are needed at any given time.Divide the program into modules in such a way that not all modules need to be in the memory at the same time.

Advantage –

Reduce memory requirement

Reduce time requirement

Disadvantage –

Overlap map must be specified by programmer

Programmer must know memory requirement

Overlaped module must be completely disjoint

Programmming design of overlays structure is complex and not possible in all cases

Example –

The best example of overlays is assembler.Consider the assembler has 2 passes, 2 pass means at any time it will be doing only one thing, either the 1st pass or the 2nd pass.Which means it will finish 1st pass first and then 2nd pass.Let assume that available main memory size is 150KB and total code size is 200KB

Pass 1.......................70KB Pass 2.......................80KB Symbol table.................30KB Common routine...............20KB

As the total code size is 200KB and main memory size is 150KB, it is not possible to use 2 passes together.So, in this case, we should go with the overlays technique.According to the overlays concept at any time only one pass will be used and both the passes always need symbol table and common routine.Now the question is if overlays-driver* is 10KB, then what is the minimum partition size required?For pass 1 total memory needed is = (70KB + 30KB + 20KB + 10KB) = 130KB and for pass 2 total memory needed is = (80KB + 30KB + 20KB + 10KB) = 140KB.So if we have minimum 140KB size partition then we can run this code very easily.

*Overlays driver:-It is the user responsibility to take care of overlaying, the operating system will not provide anything.Which means the user should write even what part is required in the 1st pass and once the 1st pass is over, the user should write the code to pull out the pass 1 and load the pass 2.That is what is the responsibility of the user, that is known as the Overlays driver.Overlays driver will just help us to move out and move in the various part of the code.

Question –

The overlay tree for a program is as shown below:



What will be the size of the partition (in physical memory) required to load (and

run) this program?

(a) 12 KB (b) 14 KB (c) 10 KB (d) 8 KB

Explanation –

Using the overlay concept we need not actually have the entire program inside the main memory.Only we need to have the part which are required at that instance of time, either we need Root-A-D or Root-A-E or Root-B-F or Root-C-G part.

Root+A+D = 2KB + 4KB + 6KB = 12KB Root+A+E = 2KB + 4KB + 8KB = 14KB Root+B+F = 2KB + 6KB + 2KB = 10KB Root+C+G = 2KB + 8KB + 4KB = 14KB

So if we have 14KB size of partition then we can run any of them.

Answer -(b) 14KB

This article is contributed by Samit Mandal. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
123,"In an operating system that uses paging for memory management, a page replacement algorithm is needed to decide which page needs to be replaced when new page comes in.

Page Fault – A page fault happens when a running program accesses a memory page that is mapped into the virtual address space, but not loaded in physical memory.

Since actual physical memory is much smaller than virtual memory, page faults happen. In case of page fault, Operating System might have to replace one of the existing pages with the newly needed page. Different page replacement algorithms suggest different ways to decide which page to replace. The target for all algorithms is to reduce the number of page faults.

Page Replacement Algorithms :

First In First Out (FIFO) –

This is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal.



Example-1 Consider page reference string 1, 3, 0, 3, 5, 6 with 3 page frames.Find number of page faults.



Initially all slots are empty, so when 1, 3, 0 came they are allocated to the empty slots —> 3 Page Faults.

when 3 comes, it is already in memory so —> 0 Page Faults.

Then 5 comes, it is not available in memory so it replaces the oldest page slot i.e 1. —> 1 Page Fault.

6 comes, it is also not available in memory so it replaces the oldest page slot i.e 3 —> 1 Page Fault.

Finally when 3 come it is not avilable so it replaces 0 1 page fault Belady’s anomaly – Belady’s anomaly proves that it is possible to have more page faults when increasing the number of page frames while using the First in First Out (FIFO) page replacement algorithm. For example, if we consider reference string 3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4 and 3 slots, we get 9 total page faults, but if we increase slots to 4, we get 10 page faults.

This is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal. Optimal Page replacement –

In this algorithm, pages are replaced which would not be used for the longest duration of time in the future. Example-2: Consider the page references 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, with 4 page frame. Find number of page fault.



Initially all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults

0 is already there so —> 0 Page fault.

when 3 came it will take the place of 7 because it is not used for the longest duration of time in the future.—> 1 Page fault.

0 is already there so —> 0 Page fault. .

4 will takes place of 1 —> 1 Page Fault.



Now for the further page reference string —> 0 Page fault because they are already available in the memory. Optimal page replacement is perfect, but not possible in practice as the operating system cannot know future requests. The use of Optimal Page replacement is to set up a benchmark so that other replacement algorithms can be analyzed against it.

In this algorithm, pages are replaced which would not be used for the longest duration of time in the future. Least Recently Used –

In this algorithm page will be replaced which is least recently used. Example-3Consider the page reference string 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 with 4 page frames.Find number of page faults.

Initially all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults

0 is already their so —> 0 Page fault.

when 3 came it will take the place of 7 because it is least recently used —>1 Page fault

0 is already in memory so —> 0 Page fault.

4 will takes place of 1 —> 1 Page Fault

Now for the further page reference string —> 0 Page fault because they are already available in the memory.

GATE CS Corner Questions

Practicing the following questions will help you test your knowledge. All questions have been asked in GATE in previous years or in GATE Mock Tests. It is highly recommended that you practice them.

Reference –

Bélády’s anomaly



This article has been improved by RajshreeSrivastava. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
124,"Prerequisite: Page Replacement Algorithms

In operating systems that use paging for memory management, page replacement algorithm are needed to decide which page needed to be replaced when new page comes in. Whenever a new page is referred and not present in memory, page fault occurs and Operating System replaces one of the existing pages with newly needed page. Different page replacement algorithms suggest different ways to decide which page to replace. The target for all algorithms is to reduce number of page faults.

In Least Recently Used (LRU) algorithm is a Greedy algorithm where the page to be replaced is least recently used. The idea is based on locality of reference, the least recently used page is not likely

Let say the page reference string 7 0 1 2 0 3 0 4 2 3 0 3 2 . Initially we have 4 page slots empty.

Initially all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults

0 is already their so —> 0 Page fault.

when 3 came it will take the place of 7 because it is least recently used —>1 Page fault

0 is already in memory so —> 0 Page fault.

4 will takes place of 1 —> 1 Page Fault

Now for the further page reference string —> 0 Page fault because they are already available in the memory.

Given memory capacity (as number of pages it can hold) and a string representing pages to be referred, write a function to find number of page faults.

Let capacity be the number of pages that memory can hold. Let set be the current set of pages in memory. 1- Start traversing the pages. i) If set holds less pages than capacity. a) Insert page into the set one by one until the size of set reaches capacity or all page requests are processed. b) Simultaneously maintain the recent occurred index of each page in a map called indexes. c) Increment page fault ii) Else If current page is present in set, do nothing. Else a) Find the page in the set that was least recently used. We find it using index array. We basically need to replace the page with minimum index. b) Replace the found page with current page. c) Increment page faults. d) Update index of current page. 2. Return page faults.

Below is implementation of above steps.

C++ filter_none edit

close play_arrow link

brightness_4

code #include<bits/stdc++.h> using namespace std; int pageFaults( int pages[], int n, int capacity) { unordered_set< int > s; unordered_map< int , int > indexes; int page_faults = 0; for ( int i=0; i<n; i++) { if (s.size() < capacity) { if (s.find(pages[i])==s.end()) { s.insert(pages[i]); page_faults++; } indexes[pages[i]] = i; } else { if (s.find(pages[i]) == s.end()) { int lru = INT_MAX, val; for ( auto it=s.begin(); it!=s.end(); it++) { if (indexes[*it] < lru) { lru = indexes[*it]; val = *it; } } s.erase(val); s.insert(pages[i]); page_faults++; } indexes[pages[i]] = i; } } return page_faults; } int main() { int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; int n = sizeof (pages)/ sizeof (pages[0]); int capacity = 4; cout << pageFaults(pages, n, capacity); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; class Test { static int pageFaults( int pages[], int n, int capacity) { HashSet<Integer> s = new HashSet<>(capacity); HashMap<Integer, Integer> indexes = new HashMap<>(); int page_faults = 0 ; for ( int i= 0 ; i<n; i++) { if (s.size() < capacity) { if (!s.contains(pages[i])) { s.add(pages[i]); page_faults++; } indexes.put(pages[i], i); } else { if (!s.contains(pages[i])) { int lru = Integer.MAX_VALUE, val=Integer.MIN_VALUE; Iterator<Integer> itr = s.iterator(); while (itr.hasNext()) { int temp = itr.next(); if (indexes.get(temp) < lru) { lru = indexes.get(temp); val = temp; } } s.remove(val); indexes.remove(val); s.add(pages[i]); page_faults++; } indexes.put(pages[i], i); } } return page_faults; } public static void main(String args[]) { int pages[] = { 7 , 0 , 1 , 2 , 0 , 3 , 0 , 4 , 2 , 3 , 0 , 3 , 2 }; int capacity = 4 ; System.out.println(pageFaults(pages, pages.length, capacity)); } } chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Collections.Generic; class GFG { static int pageFaults( int []pages, int n, int capacity) { HashSet< int > s = new HashSet< int >(capacity); Dictionary< int , int > indexes = new Dictionary< int , int >(); int page_faults = 0; for ( int i = 0; i < n; i++) { if (s.Count < capacity) { if (!s.Contains(pages[i])) { s.Add(pages[i]); page_faults++; } if (indexes.ContainsKey(pages[i])) indexes[pages[i]] = i; else indexes.Add(pages[i], i); } else { if (!s.Contains(pages[i])) { int lru = int .MaxValue, val = int .MinValue; foreach ( int itr in s) { int temp = itr; if (indexes[temp] < lru) { lru = indexes[temp]; val = temp; } } s.Remove(val); indexes.Remove(val); s.Add(pages[i]); page_faults++; } if (indexes.ContainsKey(pages[i])) indexes[pages[i]] = i; else indexes.Add(pages[i], i); } } return page_faults; } public static void Main(String []args) { int []pages = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; int capacity = 4; Console.WriteLine(pageFaults(pages, pages.Length, capacity)); } } chevron_right filter_none

6

Another approach: (Without using HashMap)



Java filter_none edit

close play_arrow link

brightness_4

code import java.util.ArrayList; public class LRU { public static void main(String[] args) { int capacity = 4 ; int arr[] = { 7 , 0 , 1 , 2 , 0 , 3 , 0 , 4 , 2 , 3 , 0 , 3 , 2 }; ArrayList<Integer> s= new ArrayList<>(capacity); int count= 0 ; int page_faults= 0 ; for ( int i:arr) { if (!s.contains(i)) { if (s.size()==capacity) { s.remove( 0 ); s.add(capacity- 1 ,i); } else s.add(count,i); page_faults++; ++count; } else { s.remove((Object)i); s.add(s.size(),i); } } System.out.println(page_faults); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code capacity = 4 processList = [ 7 , 0 , 1 , 2 , 0 , 3 , 0 , 4 , 2 , 3 , 0 , 3 , 2 ] s = [] pageFaults = 0 for i in processList: if i not in s: if ( len (s) = = capacity): s.remove(s[ 0 ]) s.append(i) else : s.append(i) pageFaults + = 1 else : s.remove(i) s.append(i) print ( ""{}"" . format (pageFaults)) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Collections.Generic; class LRU { public static void Main(String[] args) { int capacity = 4; int []arr = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; List< int > s = new List< int >(capacity); int count = 0; int page_faults = 0; foreach ( int i in arr) { if (!s.Contains(i)) { if (s.Count == capacity) { s.RemoveAt(0); s.Insert(capacity - 1, i); } else s.Insert(count, i); page_faults++; ++count; } else { s.Remove(i); s.Insert(s.Count, i); } } Console.WriteLine(page_faults); } } chevron_right filter_none

Output:

6

Note : We can also find the number of page hits. Just have to maintain a separate count.

If the current page is already in the memory then that must be count as Page-hit.

We will discuss other Page-replacement Algorithms in further sets.

This article is contributed by Sahil Chhabra. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready."
125,"Prerequisite: Page Replacement Algorithms

In operating systems, whenever a new page is referred and not present in memory, page fault occurs and Operating System replaces one of the existing pages with newly needed page. Different page replacement algorithms suggest different ways to decide which page to replace. The target for all algorithms is to reduce number of page faults.

In this algorithm, OS replaces the page that will not be used for the longest period of time in future.

Examples :

Input : Number of frames, fn = 3 Reference String, pg[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1}; Output : No. of hits = 11 No. of misses = 9 Input : Number of frames, fn = 4 Reference String, pg[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2}; Output : No. of hits = 7 No. of misses = 6

The idea is simple, for every reference we do following :

If referred page is already present, increment hit count. If not present, find if a page that is never referenced in future. If such a page exists, replace this page with new page. If no such page exists, find a page that is referenced farthest in future. Replace this page with new page.

filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; bool search( int key, vector< int >& fr) { for ( int i = 0; i < fr.size(); i++) if (fr[i] == key) return true ; return false ; } int predict( int pg[], vector< int >& fr, int pn, int index) { int res = -1, farthest = index; for ( int i = 0; i < fr.size(); i++) { int j; for (j = index; j < pn; j++) { if (fr[i] == pg[j]) { if (j > farthest) { farthest = j; res = i; } break ; } } if (j == pn) return i; } return (res == -1) ? 0 : res; } void optimalPage( int pg[], int pn, int fn) { vector< int > fr; int hit = 0; for ( int i = 0; i < pn; i++) { if (search(pg[i], fr)) { hit++; continue ; } if (fr.size() < fn) fr.push_back(pg[i]); else { int j = predict(pg, fr, pn, i + 1); fr[j] = pg[i]; } } cout << ""No. of hits = "" << hit << endl; cout << ""No. of misses = "" << pn - hit << endl; } int main() { int pg[] = { 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 }; int pn = sizeof (pg) / sizeof (pg[0]); int fn = 4; optimalPage(pg, pn, fn); return 0; }

chevron_right filter_none

Output:

No. of hits = 7 No. of misses = 6

The above implementation can optimized using hashing. We can use an unordered_set in place of vector so that search operation can be done in O(1) time.

Note that optimal page replacement algorithm is not practical as we cannot predict future. However it is used as a reference for other page replacement algorithms.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
126,"Least Frequently Used (LFU) is a caching algorithm in which the least frequently used cache block is removed whenever the cache is overflowed. In LFU we check the old page as well as the frequency of that page and if the frequency of the page is larger than the old page we cannot remove it and if all the old pages are having same frequency then take last i.e FIFO method for that and remove that page.

Min-heap data structure is a good option to implement this algorithm, as it handles insertion, deletion, and update in logarithmic time complexity. A tie can be resolved by removing the least recently used cache block. The following two containers have been used to solve the problem:

A vector of integer pairs has been used to represent the cache, where each pair consists of the block number and the number of times it has been used. The vector is ordered in the form of a min-heap, which allows us to access the least frequently used block in constant time.

A hashmap has been used to store the indices of the cache blocks which allows searching in constant time.

Below is the implementation of the above approach:

filter_none edit

close play_arrow link

brightness_4

code #include <bits/stdc++.h> using namespace std; void swap(pair< int , int >& a, pair< int , int >& b) { pair< int , int > temp = a; a = b; b = temp; } inline int parent( int i) { return (i - 1) / 2; } inline int left( int i) { return 2 * i + 1; } inline int right( int i) { return 2 * i + 2; } void heapify(vector<pair< int , int > >& v, unordered_map< int , int >& m, int i, int n) { int l = left(i), r = right(i), minim; if (l < n) minim = ((v[i].second < v[l].second) ? i : l); else minim = i; if (r < n) minim = ((v[minim].second < v[r].second) ? minim : r); if (minim != i) { m[v[minim].first] = i; m[v[i].first] = minim; swap(v[minim], v[i]); heapify(v, m, minim, n); } } void increment(vector<pair< int , int > >& v, unordered_map< int , int >& m, int i, int n) { ++v[i].second; heapify(v, m, i, n); } void insert(vector<pair< int , int > >& v, unordered_map< int , int >& m, int value, int & n) { if (n == v.size()) { m.erase(v[0].first); cout << ""Cache block "" << v[0].first << "" removed.

"" ; v[0] = v[--n]; heapify(v, m, 0, n); } v[n++] = make_pair(value, 1); m.insert(make_pair(value, n - 1)); int i = n - 1; while (i && v[parent(i)].second > v[i].second) { m[v[i].first] = parent(i); m[v[parent(i)].first] = i; swap(v[i], v[parent(i)]); i = parent(i); } cout << ""Cache block "" << value << "" inserted.

"" ; } void refer(vector<pair< int , int > >& cache, unordered_map< int , int >& indices, int value, int & cache_size) { if (indices.find(value) == indices.end()) insert(cache, indices, value, cache_size); else increment(cache, indices, indices[value], cache_size); } int main() { int cache_max_size = 4, cache_size = 0; vector<pair< int , int > > cache(cache_max_size); unordered_map< int , int > indices; refer(cache, indices, 1, cache_size); refer(cache, indices, 2, cache_size); refer(cache, indices, 1, cache_size); refer(cache, indices, 3, cache_size); refer(cache, indices, 2, cache_size); refer(cache, indices, 4, cache_size); refer(cache, indices, 5, cache_size); return 0; }

chevron_right filter_none

Output: Cache block 1 inserted. Cache block 2 inserted. Cache block 3 inserted. Cache block 4 inserted. Cache block 3 removed. Cache block 5 inserted.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : vaibhav29498"
127,"Prerequisite – Page Replacement Algorithms

Apart from LRU, OPT and FIFO page replacement policies, we also have the second chance/clock page replacement policy. In the Second Chance page replacement policy, the candidate pages for removal are considered in a round robin matter, and a page that has been accessed between consecutive considerations will not be replaced. The page replaced is the one that, when considered in a round robin matter, has not been accessed since its last consideration.

It can be implemented by adding a “second chance” bit to each memory frame-every time the frame is considered (due to a reference made to the page inside it), this bit is set to 1, which gives the page a second chance, as when we consider the candidate page for replacement, we replace the first one with this bit set to 0 (while zeroing out bits of the other pages we see in the process). Thus, a page with the “second chance” bit set to 1 is never replaced during the first consideration and will only be replaced if all the other pages deserve a second chance too!

Example –

Let’s say the reference string is 0 4 1 4 2 4 3 4 2 4 0 4 1 4 2 4 3 4 and we have 3 frames. Let’s see how the algorithm proceeds by tracking the second chance bit and the pointer.

Initially, all frames are empty so after first 3 passes they will be filled with {0, 4, 1} and the second chance array will be {0, 0, 0} as none has been referenced yet. Also, the pointer will cycle back to 0.

Pass-4: Frame={0, 4, 1}, second_chance = {0, 1, 0} [4 will get a second chance], pointer = 0 (No page needed to be updated so the candidate is still page in frame 0), pf = 3 (No increase in page fault number).

Frame={0, 4, 1}, second_chance = {0, 1, 0} [4 will get a second chance], pointer = 0 (No page needed to be updated so the candidate is still page in frame 0), pf = 3 (No increase in page fault number). Pass-5: Frame={2, 4, 1}, second_chance= {0, 1, 0} [0 replaced; it’s second chance bit was 0, so it didn’t get a second chance], pointer=1 (updated), pf=4

Frame={2, 4, 1}, second_chance= {0, 1, 0} [0 replaced; it’s second chance bit was 0, so it didn’t get a second chance], pointer=1 (updated), pf=4 Pass-6: Frame={2, 4, 1}, second_chance={0, 1, 0}, pointer=1, pf=4 (No change)

Frame={2, 4, 1}, second_chance={0, 1, 0}, pointer=1, pf=4 (No change) Pass-7: Frame={2, 4, 3}, second_chance= {0, 0, 0} [4 survived but it’s second chance bit became 0], pointer=0 (as element at index 2 was finally replaced), pf=5

Frame={2, 4, 3}, second_chance= {0, 0, 0} [4 survived but it’s second chance bit became 0], pointer=0 (as element at index 2 was finally replaced), pf=5 Pass-8: Frame={2, 4, 3}, second_chance= {0, 1, 0} [4 referenced again], pointer=0, pf=5

Frame={2, 4, 3}, second_chance= {0, 1, 0} [4 referenced again], pointer=0, pf=5 Pass-9: Frame={2, 4, 3}, second_chance= {1, 1, 0} [2 referenced again], pointer=0, pf=5

Frame={2, 4, 3}, second_chance= {1, 1, 0} [2 referenced again], pointer=0, pf=5 Pass-10: Frame={2, 4, 3}, second_chance= {1, 1, 0}, pointer=0, pf=5 (no change)

Frame={2, 4, 3}, second_chance= {1, 1, 0}, pointer=0, pf=5 (no change) Pass-11: Frame={2, 4, 0}, second_chance= {0, 0, 0}, pointer=0, pf=6 (2 and 4 got second chances)

Frame={2, 4, 0}, second_chance= {0, 0, 0}, pointer=0, pf=6 (2 and 4 got second chances) Pass-12: Frame={2, 4, 0}, second_chance= {0, 1, 0}, pointer=0, pf=6 (4 will again get a second chance)

Frame={2, 4, 0}, second_chance= {0, 1, 0}, pointer=0, pf=6 (4 will again get a second chance) Pass-13: Frame={1, 4, 0}, second_chance= {0, 1, 0}, pointer=1, pf=7 (pointer updated, pf updated)

Frame={1, 4, 0}, second_chance= {0, 1, 0}, pointer=1, pf=7 (pointer updated, pf updated) Page-14: Frame={1, 4, 0}, second_chance= {0, 1, 0}, pointer=1, pf=7 (No change)

Frame={1, 4, 0}, second_chance= {0, 1, 0}, pointer=1, pf=7 (No change) Page-15: Frame={1, 4, 2}, second_chance= {0, 0, 0}, pointer=0, pf=8 (4 survived again due to 2nd chance!)

Frame={1, 4, 2}, second_chance= {0, 0, 0}, pointer=0, pf=8 (4 survived again due to 2nd chance!) Page-16: Frame={1, 4, 2}, second_chance= {0, 1, 0}, pointer=0, pf=8 (2nd chance updated)

Frame={1, 4, 2}, second_chance= {0, 1, 0}, pointer=0, pf=8 (2nd chance updated) Page-17: Frame={3, 4, 2}, second_chance= {0, 1, 0}, pointer=1, pf=9 (pointer, pf updated)

Frame={3, 4, 2}, second_chance= {0, 1, 0}, pointer=1, pf=9 (pointer, pf updated) Page-18: Frame={3, 4, 2}, second_chance= {0, 1, 0}, pointer=1, pf=9 (No change)

In this example, second chance algorithm does as well as the LRU method, which is much more expensive to implement in hardware.

More Examples –

Input: 2 5 10 1 2 2 6 9 1 2 10 2 6 1 2 1 6 9 5 1 3 Output: 13 Input: 2 5 10 1 2 2 6 9 1 2 10 2 6 1 2 1 6 9 5 1 4 Output: 11

Algorithm –

Create an array frames to track the pages currently in memory and another Boolean array second_chance to track whether that page has been accessed since it’s last replacement (that is if it deserves a second chance or not) and a variable pointer to track the target for replacement.

Start traversing the array arr. If the page already exists, simply set its corresponding element in second_chance to true and return. If the page doesn’t exist, check whether the space pointed to by pointer is empty (indicating cache isn’t full yet) – if so, we will put the element there and return, else we’ll traverse the array arr one by one (cyclically using the value of pointer), marking all corresponding second_chance elements as false, till we find a one that’s already false. That is the most suitable page for replacement, so we do so and return. Finally, we report the page fault count.





C++ filter_none edit

close play_arrow link

brightness_4

code #include<iostream> #include<cstring> #include<sstream> using namespace std; static bool findAndUpdate( int x, int arr[], bool second_chance[], int frames) { int i; for (i = 0; i < frames; i++) { if (arr[i] == x) { second_chance[i] = true ; return true ; } } return false ; } static int replaceAndUpdate( int x, int arr[], bool second_chance[], int frames, int pointer) { while ( true ) { if (!second_chance[pointer]) { arr[pointer] = x; return (pointer + 1) % frames; } second_chance[pointer] = false ; pointer = (pointer + 1) % frames; } } static void printHitsAndFaults(string reference_string, int frames) { int pointer, i, l=0, x, pf; pointer = 0; pf = 0; int arr[frames]; memset (arr, -1, sizeof (arr)); bool second_chance[frames]; string str[100]; string word = """" ; for ( auto x : reference_string) { if (x == ' ' ) { str[l]=word; word = """" ; l++; } else { word = word + x; } } str[l] = word; l++; for (i = 0; i < l; i++) { x = stoi(str[i]); if (!findAndUpdate(x,arr,second_chance,frames)) { pointer = replaceAndUpdate(x,arr, second_chance,frames,pointer); pf++; } } cout << ""Total page faults were "" << pf << ""

"" ; } int main() { string reference_string = """" ; int frames = 0; reference_string = ""0 4 1 4 2 4 3 4 2 4 0 4 1 4 2 4 3 4"" ; frames = 3; printHitsAndFaults(reference_string,frames); reference_string = ""2 5 10 1 2 2 6 9 1 2 10 2 6 1 2 1 6 9 5 1"" ; frames = 4; printHitsAndFaults(reference_string,frames); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.util.*; import java.io.*; class secondChance { public static void main(String args[]) throws IOException { String reference_string = """" ; int frames = 0 ; reference_string = ""0 4 1 4 2 4 3 4 2 4 0 4 1 4 2 4 3 4"" ; frames = 3 ; printHitsAndFaults(reference_string,frames); reference_string = ""2 5 10 1 2 2 6 9 1 2 10 2 6 1 2 1 6 9 5 1"" ; frames = 4 ; printHitsAndFaults(reference_string,frames); } static boolean findAndUpdate( int x, int arr[], boolean second_chance[], int frames) { int i; for (i = 0 ; i < frames; i++) { if (arr[i] == x) { second_chance[i] = true ; return true ; } } return false ; } static int replaceAndUpdate( int x, int arr[], boolean second_chance[], int frames, int pointer) { while ( true ) { if (!second_chance[pointer]) { arr[pointer] = x; return (pointer+ 1 )%frames; } second_chance[pointer] = false ; pointer = (pointer+ 1 )%frames; } } static void printHitsAndFaults(String reference_string, int frames) { int pointer,i,l,x,pf; pointer = 0 ; pf = 0 ; int arr[] = new int [frames]; Arrays.fill(arr,- 1 ); boolean second_chance[] = new boolean [frames]; String str[] = reference_string.split( "" "" ); l = str.length; for (i = 0 ; i<l; i++) { x = Integer.parseInt(str[i]); if (!findAndUpdate(x,arr,second_chance,frames)) { pointer = replaceAndUpdate(x,arr, second_chance,frames,pointer); pf++; } } System.out.println( ""Total page faults were "" +pf); } } chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; public class secondChance { public static void Main() { String reference_string = """" ; int frames = 0; reference_string = ""0 4 1 4 2 4 3 4 2 4 0 4 1 4 2 4 3 4"" ; frames = 3; printHitsAndFaults(reference_string,frames); reference_string = ""2 5 10 1 2 2 6 9 1 2 10 2 6 1 2 1 6 9 5 1"" ; frames = 4; printHitsAndFaults(reference_string,frames); } static bool findAndUpdate( int x, int []arr, bool []second_chance, int frames) { int i; for (i = 0; i < frames; i++) { if (arr[i] == x) { second_chance[i] = true ; return true ; } } return false ; } static int replaceAndUpdate( int x, int []arr, bool []second_chance, int frames, int pointer) { while ( true ) { if (!second_chance[pointer]) { arr[pointer] = x; return (pointer+1)%frames; } second_chance[pointer] = false ; pointer = (pointer + 1) % frames; } } static void printHitsAndFaults(String reference_string, int frames) { int pointer, i, l, x, pf; pointer = 0; pf = 0; int []arr = new int [frames]; for ( int s = 0;s<frames;s++) arr[s]=-1; bool []second_chance = new bool [frames]; String []str = reference_string.Split(); l = str.Length; for (i = 0; i < l; i++) { x = int .Parse(str[i]); if (!findAndUpdate(x,arr,second_chance,frames)) { pointer = replaceAndUpdate(x,arr, second_chance,frames,pointer); pf++; } } Console.WriteLine( ""Total page faults were "" +pf); } } chevron_right filter_none

Total page faults were 9 Total page faults were 11

Note:

The arrays arr and second_chance can be replaced and combined together via a hashmap (with element as key, true/false as value) to speed up search. Time complexity of this method is O(Number_of_frames*reference_string_length) or O(mn) but since number of frames will be a constant in an Operating System (as main memory size is fixed), it is simply O(n) [Same as hashmap approach, but that will have lower constants] Second chance algorithm may suffer from Belady’s Anomaly.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Uni_Omni CSE B Tech 4th Year at IIT Bhubaneswar||Summer Intern 2018 IIT Roorkee||Summer Intern 2019 Goldman Sachs

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : 29AjayKumar, NikhilRathor"
128,"Prerequisite – Virtual Memory

Thrashing is a condition or a situation when the system is spending a major portion of its time in servicing the page faults, but the actual processing done is very negligible.

The basic concept involved is that if a process is allocated too few frames, then there will be too many and too frequent page faults. As a result, no useful work would be done by the CPU and the CPU utilisation would fall drastically. The long-term scheduler would then try to improve the CPU utilisation by loading some more processes into the memory thereby increasing the degree of multiprogramming. This would result in a further decrease in the CPU utilization triggering a chained reaction of higher page faults followed by an increase in the degree of multiprogramming, called Thrashing.

Locality Model –

A locality is a set of pages that are actively used together. The locality model states that as a process executes, it moves from one locality to another. A program is generally composed of several different localities which may overlap.

For example when a function is called, it defines a new locality where memory references are made to the instructions of the function call, it’s local and global variables, etc. Similarly, when the function is exited, the process leaves this locality.

Techniques to handle:

Working Set Model – This model is based on the above-stated concept of the Locality Model.

The basic principle states that if we allocate enough frames to a process to accommodate its current locality, it will only fault whenever it moves to some new locality. But if the allocated frames are lesser than the size of the current locality, the process is bound to thrash. According to this model, based on a parameter A, the working set is defined as the set of pages in the most recent ‘A’ page references. Hence, all the actively used pages would always end up being a part of the working set. The accuracy of the working set is dependant on the value of parameter A. If A is too large, then working sets may overlap. On the other hand, for smaller values of A, the locality might not be covered entirely. If D is the total demand for frames and is the working set size for a process i,



Now, if ‘m’ is the number of frames available in the memory, there are 2 possibilities: (i) D>m i.e. total demand exceeds the number of frames, then thrashing will occur as some processes would not get enough frames.

(ii) D<=m, then there would be no thrashing. If there are enough extra frames, then some more processes can be loaded in the memory. On the other hand, if the summation of working set sizes exceeds the availability of frames, then some of the processes have to be suspended(swapped out of memory).



This technique prevents thrashing along with ensuring the highest degree of multiprogramming possible. Thus, it optimizes CPU utilisation. Page Fault Frequency – A more direct approach to handle thrashing is the one that uses Page-Fault Frequency concept. The problem associated with Thrashing is the high page fault rate and thus, the concept here is to control the page fault rate. If the page fault rate is too high, it indicates that the process has too few frames allocated to it. On the contrary, a low page fault rate indicates that the process has too many frames. Upper and lower limits can be established on the desired page fault rate as shown in the diagram.

If the page fault rate falls below the lower limit, frames can be removed from the process. Similarly, if the page fault rate exceeds the upper limit, more number of frames can be allocated to the process.

In other words, the graphical state of the system should be kept limited to the rectangular region formed in the given diagram. Here too, if the page fault rate is high with no free frames, then some of the processes can be suspended and frames allocated to them can be reallocated to other processes. The suspended processes can then be restarted later.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
129,"Prerequisite – Buddy System

Two strategies for managing free memory that is assigned to kernel processes:

1. Buddy system –

Buddy allocation system is an algorithm in which a larger memory block is divided into small parts to satisfy the request. This algorithm is used to give best fit. The two smaller parts of block are of equal size and called as buddies. In the same manner one of the two buddies will further divide into smaller parts until the request is fulfilled. Benefit of this technique is that the two buddies can combine to form the block of larger size according to the memory request.

Example – If the request of 25Kb is made then block of size 32Kb is allocated.

Four Types of Buddy System –

Binary buddy system Fibonacci buddy system Weighted buddy system Tertiary buddy system

Why buddy system?

If the partition size and procees size are different then poor match occurs and may use space inefficiently.

It is easy to implement and efficient then dynamic allocation.

Binary buddy system –

The buddy system maintains a list of the free blocks of each size (called a free list), so that it is easy to find ablock of the desired size, if one is available. If no block of the requested size is available, Allocate searches for the first nonempty list for blocks of atleast the size requested. In either case, a block is removed from the free list.

Example – Assume the size of memory segment is initially 256kb and the kernel rquests 25kb of memory. The segment is initially divided into two buddies. Let we call A1 and A2 each 128kb in size. One of these buddies is further divided into two 64kb buddies let say B1 and B2. But the next highest power of 25kb is 32kb so, either B1 or B2 is further divided into two 32kb buddies(C1 and C2) and finally one of these buddies is used to satisfy the 25kb request. A split block can only be merged with its unique buddy block, which then reforms the larger block they were split from.

Fibonacci buddy system –

This is the system in which blocks are divided into sizes which are fibonacci numbers. It satisfy the following relation:

Z i = Z (i-1) +Z (i-2)

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 144, 233, 377, 610. The address calculation for the binary and weighted buddy systems is straight forward, but the original procedure for the Fibonacci buddy system was either limited to a small, fixed number of block sizes or a time consuming computation.

Advantages –

In comparison to other simpler techniques such as dynamic allocation, the buddy memory system has little external fragmentation.

The buddy memory allocation system is implemented with the use of a binary tree to represent used or unused split memory blocks.

The buddy system is very fast to allocate or deallocate memory.

In buddy systems, the cost to allocate and free a block of memory is low compared to that of best-fit or first-fit algorithms.

Other advantage is coalescing.

Address calculation is easy.

What is coalescing?

It is defined as how quickly adjacent buddies can be combined to form larger segments this is known as coalescing.

For example, when the kernel releases the C1 unit it was allocated, the system can coalesce C1 and C2 into a 64kb segment. This segment B1 can in turn be coalesced with its buddy B2 to form a 128kb segment. Ultimately we can end up with the original 256kb segment.

Drawback –

The main drawback in buddy system is internal fragmentation as larger block of memory is acquired then required. For example if a 36 kb request is made then it can only be satisfied by 64 kb segment and reamining memory is wasted.

2. Slab Allocation –

A second strategy for allocating kernel memory is known as slab allocation. It eliminates fragmentation caused by allocations and deallocations. This method is used to retain allocated memory that contains a data object of a certain type for reuse upon subsequent allocations of objects of the same type. In slab allocation memory chunks suitable to fit data objects of certain type or size are preallocated. Cache does not free the space immediately after use although it keeps track of data which are required frequently so that whenever request is made the data will reach very fast. Two terms required are:

Slab – A slab is made up of one or more physically contiguous pages. The slab is the actual container of data associated with objects of the specific kind of the containing cache.

A slab is made up of one or more physically contiguous pages. The slab is the actual container of data associated with objects of the specific kind of the containing cache. Cache – Cache represents a small amount of very fast memory. A cache consists of one or more slabs. There is a single cache for each unique kernel data structure.

Example –

A separate cache for a data structure representing processes descriptors

Separate cache for file objects

Separate cache for semaphores etc.

Each cache is populated with objects that are instantiations of the kernel data structure the cache represents. For example the cache representing semaphores stores instances of semaphore objects, the cache representing process descriptors stores instances of process descriptor objects.

Implementation –

The slab allocation algorithm uses caches to store kernel objects. When a cache is created a number of objects which are initially marked as free are allocated to the cache. The number of objects in the cache depends on size of the associated slab.

Example – A 12 kb slab (made up of three contiguous 4 kb pages) could store six 2 kb objects. Initially all objects in the cache are marked as free. When a new object for a kernel data structure is needed, the allocator can assign any free object from the cache to satisfy the request. The object assigned from the cache is marked as used.

In linux, a slab may in one of three possible states:

Full – All objects in the slab are marked as used Empty – All objects in the slab are marked as free Partial – The slab consists of both

The slab allocator first attempts to satisfy the request with a free object in a partial slab. If none exists, a free object is assigned from an empty slab. If no empty slabs are available, a new slab is allocated from contiguous physical pages and assigned to a cache.

Benefits of slab allocator –

No memory is wasted due to fragmentation because each unique kernel data structure has an associated cache.

Memory request can be satisfied quickly.

The slab allocating scheme is particularly effective for managing when objects are frequently allocated or deallocated. The act of allocating and releasing memory can be a time consuming process. However, objects are created in advance and thus can be quickly allocated from the cache. When the kernel has finished with an object and releases it, it is marked as free and return to its cache, thus making it immediately available for subsequent request from the kernel.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
130,"Prerequisite – Buddy System

Question: Write a program to implement the buddy system of memory allocation in Operating Systems.

Explanation –

The buddy system is implemented as follows- A list of free nodes, of all the different possible powers of 2, is maintained at all times (So if total memory size is 1 MB, we’d have 20 free lists to track-one for blocks of size 1 byte, 1 for 2 bytes, next for 4 bytes and so on).

When a request for allocation comes, we look for the smallest block bigger than it. If such a block is found on the free list, the allocation is done (say, the request is of 27 KB and the free list tracking 32 KB blocks has at least one element in it), else we traverse the free list upwards till we find a big enough block. Then we keep splitting it in two blocks-one for adding to the next free list (of smaller size), one to traverse down the tree till we reach the target and return the requested memory block to the user. If no such allocation is possible, we simply return null.

Example:

Let us see how the algorithm proceeds by tracking a memory block of size 128 KB. Initially, the free list is: {}, {}, {}, {}, {}, {}, {}, { (0, 127) }

Request: 32 bytes

No such block found, so we traverse up and split the 0-127 block into 0-63, 64-127; we add 64-127 to list tracking 64 byte blocks and pass 0-63 downwards; again it is split into 0-31 and 32-63; since we have found the required block size, we add 32-63 to list tracking 32 byte blocks and return 0-31 to user.

List is: {}, {}, {}, {}, {}, { (32, 63) }, { (64, 127) }, {}

32 bytes No such block found, so we traverse up and split the 0-127 block into 0-63, 64-127; we add 64-127 to list tracking 64 byte blocks and pass 0-63 downwards; again it is split into 0-31 and 32-63; since we have found the required block size, we add 32-63 to list tracking 32 byte blocks and return 0-31 to user. List is: {}, {}, {}, {}, {}, { (32, 63) }, { (64, 127) }, {} Request: 7 bytes

No such block found-split block 32-63 into two blocks, namely 32-47 and 48-63; then split 32-47 into 32-39 and 40-47; finally, return 32-39 to user (internal fragmentation of 1 byte occurs)

List is: {}, {}, {}, { (40, 47) }, { (48, 63) }, {}, { (64, 127) }, {}

7 bytes No such block found-split block 32-63 into two blocks, namely 32-47 and 48-63; then split 32-47 into 32-39 and 40-47; finally, return 32-39 to user (internal fragmentation of 1 byte occurs) List is: {}, {}, {}, { (40, 47) }, { (48, 63) }, {}, { (64, 127) }, {} Request: 64 bytes

Straight up memory segment 64-127 will be allocated as it already exists.

List is: {}, {}, {}, { (40, 47) }, { (48, 63) }, {}, {}, {}

64 bytes Straight up memory segment 64-127 will be allocated as it already exists. List is: {}, {}, {}, { (40, 47) }, { (48, 63) }, {}, {}, {} Request: 56 bytes

Result: Not allocated

The result will be as follows:



Figure – Buddy Allocation-128 shows the starting address of next possible block (if main memory size ever increases)

Implementation –



C++ filter_none edit

close play_arrow link

brightness_4

code #include<bits/stdc++.h> using namespace std; int size; vector<pair< int , int >> free_list[100000]; map< int , int > mp; void initialize( int sz) { int n = ceil ( log (sz) / log (2)); size = n + 1; for ( int i = 0; i <= n; i++) free_list[i].clear(); free_list[n].push_back(make_pair(0, sz - 1)); } void allocate( int sz) { int n = ceil ( log (sz) / log (2)); if (free_list[n].size() > 0) { pair< int , int > temp = free_list[n][0]; free_list[n].erase(free_list[n].begin()); cout << ""Memory from "" << temp.first << "" to "" << temp.second << "" allocated"" << ""

"" ; mp[temp.first] = temp.second - temp.first + 1; } else { int i; for (i = n + 1; i < size; i++) { if (free_list[i].size() != 0) break ; } if (i == size) { cout << ""Sorry, failed to allocate memory

"" ; } else { pair< int , int > temp; temp = free_list[i][0]; free_list[i].erase(free_list[i].begin()); i--; for (; i >= n; i--) { pair< int , int > pair1, pair2; pair1 = make_pair(temp.first, temp.first + (temp.second - temp.first) / 2); pair2 = make_pair(temp.first + (temp.second - temp.first + 1) / 2, temp.second); free_list[i].push_back(pair1); free_list[i].push_back(pair2); temp = free_list[i][0]; free_list[i].erase(free_list[i].begin()); } cout << ""Memory from "" << temp.first << "" to "" << temp.second << "" allocated"" << ""

"" ; mp[temp.first] = temp.second - temp.first + 1; } } } int main() { initialize(128); allocate(32); allocate(7); allocate(64); allocate(56); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.io.*; import java.util.*; class Buddy { class Pair { int lb, ub; Pair( int a, int b) { lb = a; ub = b; } } int size; ArrayList<Pair> arr[]; @SuppressWarnings ( ""unchecked"" ) Buddy( int s) { size = s; int x = ( int )Math.ceil(Math.log(s) / Math.log( 2 )); arr = new ArrayList[x + 1 ]; for ( int i = 0 ; i <= x; i++) arr[i] = new ArrayList<>(); arr[x].add( new Pair( 0 , size - 1 )); } void allocate( int s) { int x = ( int )Math.ceil(Math.log(s) / Math.log( 2 )); int i; Pair temp = null ; if (arr[x].size() > 0 ) { temp = (Pair)arr[x].remove( 0 ); System.out.println( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); return ; } for (i = x + 1 ; i < arr.length; i++) { if (arr[i].size() == 0 ) continue ; break ; } if (i == arr.length) { System.out.println( ""Sorry, failed to allocate memory"" ); return ; } temp = (Pair)arr[i].remove( 0 ); i--; for (; i >= x; i--) { Pair newPair = new Pair(temp.lb, temp.lb + (temp.ub - temp.lb) / 2 ); Pair newPair2 = new Pair(temp.lb + (temp.ub - temp.lb + 1 ) / 2 , temp.ub); arr[i].add(newPair); arr[i].add(newPair2); temp = (Pair)arr[i].remove( 0 ); } System.out.println( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); } public static void main(String args[]) throws IOException { int initialMemory = 0 , val = 0 ; initialMemory = 128 ; Buddy obj = new Buddy(initialMemory); obj.allocate( 32 ); obj.allocate( 7 ); obj.allocate( 64 ); obj.allocate( 56 ); } } chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Collections.Generic; public class Buddy { class Pair { public int lb, ub; public Pair( int a, int b) { lb = a; ub = b; } } int size; List<Pair> []arr; Buddy( int s) { size = s; int x = ( int )Math.Ceiling(Math.Log(s) / Math.Log(2)); arr = new List<Pair>[x + 1]; for ( int i = 0; i <= x; i++) arr[i] = new List<Pair>(); arr[x].Add( new Pair(0, size - 1)); } void allocate( int s) { int x = ( int )Math.Ceiling(Math.Log(s) / Math.Log(2)); int i; Pair temp = null ; if (arr[x].Count > 0) { temp = (Pair)arr[x][0]; arr[x].RemoveAt(0); Console.WriteLine( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); return ; } for (i = x + 1; i < arr.Length; i++) { if (arr[i].Count == 0) continue ; break ; } if (i == arr.Length) { Console.WriteLine( ""Sorry, failed to"" + "" allocate memory"" ); return ; } temp = (Pair)arr[i][0]; arr[i].RemoveAt(0); i--; for (; i >= x; i--) { Pair newPair = new Pair(temp.lb, temp.lb + (temp.ub - temp.lb) / 2); Pair newPair2 = new Pair(temp.lb + (temp.ub - temp.lb + 1) / 2, temp.ub); arr[i].Add(newPair); arr[i].Add(newPair2); temp = (Pair)arr[i][0]; arr[i].RemoveAt(0); } Console.WriteLine( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); } public static void Main(String []args) { int initialMemory = 0; initialMemory = 128; Buddy obj = new Buddy(initialMemory); obj.allocate(32); obj.allocate(7); obj.allocate(64); obj.allocate(56); } } chevron_right filter_none

Output: Memory from 0 to 31 allocated Memory from 32 to 39 allocated Memory from 64 to 127 allocated Sorry, failed to allocate memory

Time Complexity –

If the main memory size is n, we have log(n) number of different powers of 2 and hence log(n) elements in the array (named arr in the code) tracking free lists. To allocate a block, we only need to traverse the array once upwards and once downwards, hence time complexity is O(2log(n)) or simply O(logn)

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Uni_Omni CSE B Tech 4th Year at IIT Bhubaneswar||Summer Intern 2018 IIT Roorkee||Summer Intern 2019 Goldman Sachs

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : ak21, 29AjayKumar, sarthak_eddy"
131,"Prerequisite – Buddy Allocation | Set 1

Question: Write a program to implement the buddy system of memory allocation and deallocation in Operating Systems.

Explanation –

As we already know from Set 1, the allocation is done via the usage of free lists. Now, for deallocation, we will maintain an extra data structure-a Map (unordered_set in C++, HashMap in Java) with the starting address of segment as key and size of the segment as value and update it whenever an allocation request comes. Now, when deallocation request comes, we will first check the map to see if it is a valid request. If so, we will then add the block to the free list tracking blocks of its sizes. Then, we will search the free list to see if it’s buddy is free-if so, we will merge the blocks and place them on the free list above them (which tracks blocks of double the size), else we will not coalesce and simply return after that.

How to know which block is a given block’s buddy?

Let us define two terms-buddyNumber and buddyAddress. The buddyNumber of a block is calculated by the formula:

(base_address-starting_address_of_main_memory)/block_size

We note that this is always an integer, as both numerator and denominator are powers of 2. Now, a block will be another block’s buddy if both of them were formed by the splitting of the same bigger block. For example, if 4 consecutive allocation requests of 16 bytes come, we will end up with blocks 0-15, 16-31, 32-47, 48-63 where blocks 0-15 and 16-31 are buddies (as they were formed by splitting block 0-32) but 0-15 and 32-47 aren’t. The buddyAddress of a block is the starting index of its buddy block, given by the formula:

block_starting_address+block_size (if buddyNumber is even) block_starting_address-block_size (if buddyNumber is odd)

Thus, all we have to do is find this buddyAddress in the free list (by comparing with all the starting addresses in that particular list), and if present, coalescing can be done.

Examples:

Let us see how the algorithm proceeds by tracking a memory block of size 128 KB. Initially, the free list is: {}, {}, {}, {}, {}, {}, {}, { (0, 127) }

Allocation Request: 16 bytes

No such block found, so we traverse up and split the 0-127 block into 0-63, 64-127; we add 64-127 to list tracking 64 byte blocks and pass 0-63 downwards; again it is split into 0-31 and 32-63; we add 32-63 to list tracking 32 byte blocks, passing 0-31 downwards; one more spli is done and 0-15 is returned to user while 16-31 is added to free list tracking 16 byte blocks.

List is: {}, {}, {}, {}, { (16, 31) }, { (32, 63) }, { (64, 127) }, {}

16 bytes No such block found, so we traverse up and split the 0-127 block into 0-63, 64-127; we add 64-127 to list tracking 64 byte blocks and pass 0-63 downwards; again it is split into 0-31 and 32-63; we add 32-63 to list tracking 32 byte blocks, passing 0-31 downwards; one more spli is done and 0-15 is returned to user while 16-31 is added to free list tracking 16 byte blocks. List is: {}, {}, {}, {}, { (16, 31) }, { (32, 63) }, { (64, 127) }, {} Allocation Request: 16 bytes

Straight up memory segment 16-31 will be allocated as it already exists.

List is: {}, {}, {}, {}, {}, { (32, 63) }, { (64, 127) }, {}

16 bytes Straight up memory segment 16-31 will be allocated as it already exists. List is: {}, {}, {}, {}, {}, { (32, 63) }, { (64, 127) }, {} Allocation Request: 16 bytes

No such block found, so we will traverse up to block 32-63 and split it to blocks 32-47 and 48-63; we will add 48-63 to list tracking 16 byte blocks and return 32-47 to user.

List is: {}, {}, {}, {}, { (48, 63) }, {}, { (64, 127) }, {}

16 bytes No such block found, so we will traverse up to block 32-63 and split it to blocks 32-47 and 48-63; we will add 48-63 to list tracking 16 byte blocks and return 32-47 to user. List is: {}, {}, {}, {}, { (48, 63) }, {}, { (64, 127) }, {} Allocation Request: 16 bytes

Straight up memory segment 48-63 will be allocated as it already exists.

List is: {}, {}, {}, {}, {}, {}, { (64, 127) }, {}

16 bytes Straight up memory segment 48-63 will be allocated as it already exists. List is: {}, {}, {}, {}, {}, {}, { (64, 127) }, {} Deallocation Request: StartIndex = 0

Deallocation will be done but no coalesscing is possible as it’s buddyNumber is 0 and buddyAddress is 16 (via the formula), none of which is in the free list.

List is: {}, {}, {}, {}, { (0, 15) }, {}, { (64, 127) }, {}

StartIndex = 0 Deallocation will be done but no coalesscing is possible as it’s is 0 and is 16 (via the formula), none of which is in the free list. List is: {}, {}, {}, {}, { (0, 15) }, {}, { (64, 127) }, {} Deallocation Request: StartIndex = 9

Result: Invalid request, as this segmeent was never allocated.

List is: {}, {}, {}, {}, { (0, 15) }, {}, { (64, 127) }, {}

StartIndex = 9 Result: Invalid request, as this segmeent was never allocated. List is: {}, {}, {}, {}, { (0, 15) }, {}, { (64, 127) }, {} Deallocation Request: StartIndex = 32

Deallocation will be done but no coalesscing is possible as the buddyNumber of the blocks are 0 and 2 buddyAddress of the blocks are 16 and 48, repectively, none of which is in the free list.

List is: {}, {}, {}, {}, { (0, 15), (32-47) }, {}, { (64, 127) }, {}

StartIndex = 32 Deallocation will be done but no coalesscing is possible as the of the blocks are 0 and 2 of the blocks are 16 and 48, repectively, none of which is in the free list. List is: {}, {}, {}, {}, { (0, 15), (32-47) }, {}, { (64, 127) }, {} Deallocation Request: StartIndex = 16

Deallocation will be done and coealsecing of the blocks 0-15 and 16-31 will also be done as the buddyAddress of block 16-31 is 0, which is present in the free list tracking 16 byte blocks.

List is: {}, {}, {}, {}, { (32-47) }, { (0, 31) }, { (64, 127) }, {}

Figure – Buddy algorithm-allocation and deallocation

Implementation –

Below is the complete program.



C++ filter_none edit

close play_arrow link

brightness_4

code #include<bits/stdc++.h> using namespace std; int size; vector<pair< int , int >> arr[100000]; map< int , int > mp; void Buddy( int s) { int n = ceil ( log (s) / log (2)); size = n + 1; for ( int i = 0; i <= n; i++) arr[i].clear(); arr[n].push_back(make_pair(0, s - 1)); } void allocate( int s) { int x = ceil ( log (s) / log (2)); if (arr[x].size() > 0) { pair< int , int > temp = arr[x][0]; arr[x].erase(arr[x].begin()); cout << ""Memory from "" << temp.first << "" to "" << temp.second << "" allocated"" << ""

"" ; mp[temp.first] = temp.second - temp.first + 1; } else { int i; for (i = x + 1; i < size; i++) { if (arr[i].size() != 0) break ; } if (i == size) { cout << ""Sorry, failed to allocate memory

"" ; } else { pair< int , int > temp; temp = arr[i][0]; arr[i].erase(arr[i].begin()); i--; for (;i >= x; i--) { pair< int , int > pair1, pair2; pair1 = make_pair(temp.first, temp.first + (temp.second - temp.first) / 2); pair2 = make_pair(temp.first + (temp.second - temp.first + 1) / 2, temp.second); arr[i].push_back(pair1); arr[i].push_back(pair2); temp = arr[i][0]; arr[i].erase(arr[i].begin()); } cout << ""Memory from "" << temp.first << "" to "" << temp.second << "" allocate"" << ""

"" ; mp[temp.first] = temp.second - temp.first + 1; } } } void deallocate( int id) { if (mp.find(id) == mp.end()) { cout << ""Sorry, invalid free request

"" ; return ; } int n = ceil ( log (mp[id]) / log (2)); int i, buddyNumber, buddyAddress; arr[n].push_back(make_pair(id, id + pow (2, n) - 1)); cout << ""Memory block from "" << id << "" to "" << id + pow (2, n) - 1 << "" freed

"" ; buddyNumber = id / mp[id]; if (buddyNumber % 2 != 0) buddyAddress = id - pow (2, n); else buddyAddress = id + pow (2, n); for (i = 0; i < arr[n].size(); i++) { if (arr[n][i].first == buddyAddress) { if (buddyNumber % 2 == 0) { arr[n + 1].push_back(make_pair(id, id + 2 * ( pow (2, n) - 1))); cout << ""Coalescing of blocks starting at "" << id << "" and "" << buddyAddress << "" was done"" << ""

"" ; } else { arr[n + 1].push_back(make_pair( buddyAddress, buddyAddress + 2 * ( pow (2, n)))); cout << ""Coalescing of blocks starting at "" << buddyAddress << "" and "" << id << "" was done"" << ""

"" ; } arr[n].erase(arr[n].begin() + i); arr[n].erase(arr[n].begin() + arr[n].size() - 1); break ; } } mp.erase(id); } int main() { Buddy(128); allocate(16); allocate(16); allocate(16); allocate(16); deallocate(0); deallocate(9); deallocate(32); deallocate(16); return 0; } chevron_right filter_none Java filter_none edit

close play_arrow link

brightness_4

code import java.io.*; import java.util.*; class Buddy { class Pair { int lb, ub; Pair( int a, int b) { lb = a; ub = b; } } int size; ArrayList<Pair> arr[]; HashMap<Integer, Integer> hm; @SuppressWarnings ( ""unchecked"" ) Buddy( int s) { size = s; hm = new HashMap<>(); int x = ( int )Math.ceil(Math.log(s) / Math.log( 2 )); arr = new ArrayList[x + 1 ]; for ( int i = 0 ; i <= x; i++) arr[i] = new ArrayList<>(); arr[x].add( new Pair( 0 , size - 1 )); } void allocate( int s) { int x = ( int )Math.ceil(Math.log(s) / Math.log( 2 )); int i; Pair temp = null ; if (arr[x].size() > 0 ) { temp = (Pair)arr[x].remove( 0 ); System.out.println( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); hm.put(temp.lb, temp.ub - temp.lb + 1 ); return ; } for (i = x + 1 ; i < arr.length; i++) { if (arr[i].size() == 0 ) continue ; break ; } if (i == arr.length) { System.out.println( ""Sorry, failed to allocate memory"" ); return ; } temp = (Pair)arr[i].remove( 0 ); i--; for (; i >= x; i--) { Pair newPair = new Pair(temp.lb, temp.lb + (temp.ub - temp.lb) / 2 ); Pair newPair2 = new Pair(temp.lb + (temp.ub - temp.lb + 1 ) / 2 , temp.ub); arr[i].add(newPair); arr[i].add(newPair2); temp = (Pair)arr[i].remove( 0 ); } System.out.println( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); hm.put(temp.lb, temp.ub - temp.lb + 1 ); } void deallocate( int s) { if (!hm.containsKey(s)) { System.out.println( ""Sorry, invalid free request"" ); return ; } int x = ( int )Math.ceil(Math.log(hm.get(s)) / Math.log( 2 )); int i, buddyNumber, buddyAddress; arr[x].add( new Pair(s, s + ( int )Math.pow( 2 , x) - 1 )); System.out.println( ""Memory block from "" + s + "" to "" + (s + ( int )Math.pow( 2 , x) - 1 ) + "" freed"" ); buddyNumber = s / hm.get(s); if (buddyNumber % 2 != 0 ) { buddyAddress = s - ( int )Math.pow( 2 , x); } else { buddyAddress = s + ( int )Math.pow( 2 , x); } for (i = 0 ; i < arr[x].size(); i++) { if (arr[x].get(i).lb == buddyAddress) { if (buddyNumber % 2 == 0 ) { arr[x + 1 ].add( new Pair(s, s + 2 * (( int )Math.pow( 2 , x)) - 1 )); System.out.println( ""Coalescing of blocks starting at "" + s + "" and "" + buddyAddress + "" was done"" ); } else { arr[x + 1 ].add( new Pair(buddyAddress, buddyAddress + 2 * (( int )Math.pow( 2 , x)) - 1 )); System.out.println( ""Coalescing of blocks starting at "" + buddyAddress + "" and "" + s + "" was done"" ); } arr[x].remove(i); arr[x].remove(arr[x].size() - 1 ); break ; } } hm.remove(s); } public static void main(String args[]) throws IOException { int initialMemory = 0 , type = - 1 , val = 0 ; initialMemory = 128 ; Buddy obj = new Buddy(initialMemory); obj.allocate( 16 ); obj.allocate( 16 ); obj.allocate( 16 ); obj.allocate( 16 ); obj.deallocate( 0 ); obj.deallocate( 9 ); obj.deallocate( 32 ); obj.deallocate( 16 ); } } chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; using System.Collections.Generic; public class Buddy { class Pair { public int lb, ub; public Pair( int a, int b) { lb = a; ub = b; } } int size; List<Pair> []arr; Dictionary< int , int > hm; Buddy( int s) { size = s; hm = new Dictionary< int , int >(); int x = ( int )Math.Ceiling(Math.Log(s) / Math.Log(2)); arr = new List<Pair>[x + 1]; for ( int i = 0; i <= x; i++) arr[i] = new List<Pair>(); arr[x].Add( new Pair(0, size - 1)); } void allocate( int s) { int x = ( int )Math.Ceiling(Math.Log(s) / Math.Log(2)); int i; Pair temp = null ; if (arr[x].Count > 0) { temp = (Pair)arr[x][0]; arr[x].RemoveAt(0); Console.WriteLine( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); hm.Add(temp.lb, temp.ub - temp.lb + 1); return ; } for (i = x + 1; i < arr.Length; i++) { if (arr[i].Count == 0) continue ; break ; } if (i == arr.Length) { Console.WriteLine( ""Sorry, failed to"" + "" allocate memory"" ); return ; } temp = (Pair)arr[i][0]; arr[i].RemoveAt(0); i--; for (; i >= x; i--) { Pair newPair = new Pair(temp.lb, temp.lb + (temp.ub - temp.lb) / 2); Pair newPair2 = new Pair(temp.lb + (temp.ub - temp.lb + 1) / 2, temp.ub); arr[i].Add(newPair); arr[i].Add(newPair2); temp = (Pair)arr[i][0]; arr[i].RemoveAt(0); } Console.WriteLine( ""Memory from "" + temp.lb + "" to "" + temp.ub + "" allocated"" ); hm.Add(temp.lb, temp.ub - temp.lb + 1); } void deallocate( int s) { if (!hm.ContainsKey(s)) { Console.WriteLine( ""Sorry, invalid free request"" ); return ; } int x = ( int )Math.Ceiling(Math.Log(hm[s]) / Math.Log(2)); int i, buddyNumber, buddyAddress; arr[x].Add( new Pair(s, s + ( int )Math.Pow(2, x) - 1)); Console.WriteLine( ""Memory block from "" + s + "" to "" + (s + ( int )Math.Pow(2, x) - 1) + "" freed"" ); buddyNumber = s / hm[s]; if (buddyNumber % 2 != 0) { buddyAddress = s - ( int )Math.Pow(2, x); } else { buddyAddress = s + ( int )Math.Pow(2, x); } for (i = 0; i < arr[x].Count; i++) { if (arr[x][i].lb == buddyAddress) { if (buddyNumber % 2 == 0) { arr[x + 1].Add( new Pair(s, s + 2 * (( int )Math.Pow(2, x)) - 1)); Console.WriteLine( ""Coalescing of blocks starting at "" + s + "" and "" + buddyAddress + "" was done"" ); } else { arr[x + 1].Add( new Pair(buddyAddress, buddyAddress + 2 * (( int )Math.Pow(2, x)) - 1)); Console.WriteLine( ""Coalescing of blocks starting at "" + buddyAddress + "" and "" + s + "" was done"" ); } arr[x].RemoveAt(i); arr[x].RemoveAt(arr[x].Count - 1); break ; } } hm.Remove(s); } public static void Main(String []args) { int initialMemory = 0; initialMemory = 128; Buddy obj = new Buddy(initialMemory); obj.allocate(16); obj.allocate(16); obj.allocate(16); obj.allocate(16); obj.deallocate(0); obj.deallocate(9); obj.deallocate(32); obj.deallocate(16); } } chevron_right filter_none

Output: Memory from 0 to 15 allocated Memory from 16 to 31 allocated Memory from 32 to 47 allocated Memory from 48 to 63 allocated Memory block from 0 to 15 freed Sorry, invalid free request Memory block from 32 to 47 freed Memory block from 16 to 31 freed Coalescing of blocks starting at 0 and 16 was done

Time Complexity –

As already discussed in set 1, time complexity of allocation is O(log(n)). For deallocation, in the worst case, all the allocated blocks can be of size 1 unit, which will then require O(n) time to scan the list for coalescing. However, in practice, it is highly unlikely that such an allocation will happen so it is generally much faster than linear time.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

Uni_Omni CSE B Tech 4th Year at IIT Bhubaneswar||Summer Intern 2018 IIT Roorkee||Summer Intern 2019 Goldman Sachs"
132,"When a C program is compiled, the compiler generates object code. After generating the object code, the compiler also invokes linker. One of the main tasks for linker is to make code of library functions (eg printf(), scanf(), sqrt(), ..etc) available to your program. A linker can accomplish this task in two ways, by copying the code of library function to your object code, or by making some arrangements so that the complete code of library functions is not copied, but made available at run-time.

Static Linking and Static Libraries is the result of the linker making copy of all used library functions to the executable file. Static Linking creates larger binary files, and need more space on disk and main memory. Examples of static libraries (libraries which are statically linked) are, .a files in Linux and .lib files in Windows.

Steps to create a static library Let us create and use a Static Library in UNIX or UNIX like OS.

1. Create a C file that contains functions in your library.

filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> void fun( void ) { printf ( ""fun() called from a static library"" ); }

chevron_right filter_none

We have created only one file for simplicity. We can also create multiple files in a library.

2. Create a header file for the library

filter_none edit

close play_arrow link

brightness_4

code void fun( void );

chevron_right filter_none

3. Compile library files.

gcc -c lib_mylib.c -o lib_mylib.o

4. Create static library. This step is to bundle multiple object files in one static library (see ar for details). The output of this step is static library.

ar rcs lib_mylib.a lib_mylib.o

5. Now our static library is ready to use. At this point we could just copy lib_mylib.a somewhere else to use it. For demo purposes, let us keep the library in the current directory.

Let us create a driver program that uses above created static library.

1. Create a C file with main function

filter_none edit

close play_arrow link

brightness_4

code #include ""lib_mylib.h"" void main() { fun(); }

chevron_right filter_none

2. Compile the driver program.

gcc -c driver.c -o driver.o

3. Link the compiled driver program to the static library. Note that -L. is used to tell that the static library is in current folder (See this for details of -L and -l options).

gcc -o driver driver.o -L. -l_mylib

4. Run the driver program

./driver fun() called from a static library

Following are some important points about static libraries.

1. For a static library, the actual code is extracted from the library by the linker and used to build the final executable at the point you compile/build your application.

2. Each process gets its own copy of the code and data. Where as in case of dynamic libraries it is only code shared, data is specific to each process. For static libraries memory footprints are larger. For example, if all the window system tools were statically linked, several tens of megabytes of RAM would be wasted for a typical user, and the user would be slowed down by a lot of paging.

3. Since library code is connected at compile time, the final executable has no dependencies on the library at run time i.e. no additional run-time loading costs, it means that you don’t need to carry along a copy of the library that is being used and you have everything under your control and there is no dependency.

4. In static libraries, once everything is bundled into your application, you don’t have to worry that the client will have the right library (and version) available on their system.

5. One drawback of static libraries is, for any change(up-gradation) in the static libraries, you have to recompile the main program every time.

6. One major advantage of static libraries being preferred even now “is speed”. There will be no dynamic querying of symbols in static libraries. Many production line software use static libraries even today.



Dynamic linking and Dynamic Libraries Dynamic Linking doesn’t require the code to be copied, it is done by just placing name of the library in the binary file. The actual linking happens when the program is run, when both the binary file and the library are in memory. Examples of Dynamic libraries (libraries which are linked at run-time) are, .so in Linux and .dll in Windows.

We will soon be covering more points on Dynamic Libraries and steps to create them.

This article is compiled by Abhijit Saha and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
133,"This article is not for those algo geeks. If you are interested in systems related stuff, just read on…

Shared libraries are useful in sharing code which is common across many applications. For example, it is more economic to pack all the code related to TCP/IP implementation in a shared library. However, data can’t be shared as every application needs its own set of data. Applications like, browser, ftp, telnet, etc… make use of the shared ‘network’ library to elevate specific functionality.

Every operating system has its own representation and tool-set to create shared libraries. More or less the concepts are same. On Windows every object file (*.obj, *.dll, *.ocx, *.sys, *.exe etc…) follow a format called Portalbe Executable. Even shared libraries (called as Dynamic Linked Libraries or DLL in short) are also represented in PE format. The tool-set that is used to create these libraries need to understand the binary format. Linux variants follow a format called Executable and Linkable Format (ELF). The ELF files are position independent (PIC) format. Shared libraries in Linux are referred as shared objects (generally with extension *.so). These are similar to DLLs in Windows platform. Even shared object files follow the ELF binary format.

Remember, the file extensions (*.dll, *.so, *.a, *.lib, etc…) are just for programmer convenience. They don’t have any significance. All these are binary files. You can name them as you wish. Yet ensure you provide absolute paths in building applications.

In general, when we compile an application the steps are simple. Compile, Link and Load. However, it is not simple. These steps are more versatile on modern operating systems.

When you link your application against static library, the code is part of your application. There is no dependency. Even though it causes the application size to increase, it has its own advantages. The primary one is speed as there will be no symbol (a program entity) resolution at runtime. Since every piece of code part of the binary image, such applications are independent of version mismatch issues. However, the cost is on fixing an issue in library code. If there is any bug in library code, entire application need to be recompiled and shipped to the client. In case of dynamic libraries, fixing or upgrading the libraries is easy. You just need to ship the updated shared libraries. The application need not to recompile, it only need to re-run. You can design a mechanism where we don’t need to restart the application.

When we link an application against a shared library, the linker leaves some stubs (unresolved symbols) to be filled at application loading time. These stubs need to be filled by a tool called, dynamic linker at run time or at application loading time. Again loading of a library is of two types, static loading and dynamic loading. Don’t confuse between static loading vs static linking and dynamic loading vs dynamic linking.

For example, you have built an application that depends on libstdc++.so which is a shared object (dynamic libary). How does the application become aware of required shared libraries? (If you are interested, explore the tools tdump from Borland tool set, objdump or nm or readelf tools on Linux).

Static loading:

In static loading, all of those dependent shared libraries are loaded into memory even before the application starts execution. If loading of any shared library fails, the application won’t run.

A dynamic loader examines application’s dependency on shared libraries. If these libraries are already loaded into the memory, the library address space is mapped to application virtual address space (VAS) and the dynamic linker does relocation of unresolved symbols.

If these libraries are not loaded into memory (perhaps your application might be first to invoke the shared library), the loader searches in standard library paths and loads them into memory, then maps and resolves symbols. Again loading is big process, if you are interested write your own loader :).

While resolving the symbols, if the dynamic linker not able to find any symbol (may be due to older version of shared library), the application can’t be started.

Dynamic Loading:

As the name indicates, dynamic loading is about loading of library on demand.

For example, if you want a small functionality from a shared library. Why should it be loaded at the application load time and sit in the memory? You can invoke loading of these shared libraries dynamically when you need their functionality. This is called dynamic loading. In this case, the programmer aware of situation ‘when should the library be loaded’. The tool-set and relevant kernel provides API to support dynamic loading, and querying of symbols in the shared library.

More details in later articles.

Note: If you come across terms like loadable modules or equivalent terms, don’t mix them with shared libraries. They are different from shared libraries The kernels provide framework to support loadable modules.

Working with Shared Libraries | Set 2

Exercise:

1. Assuming you have understood the concepts, How do you design an application (e.g. Banking) which can upgrade to new shared libraries without re-running the application.

— Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
134,"We have covered basic information about shared libraries in the previous post. In the current article we will learn how to create shared libraries on Linux.

Prior to that we need to understand how a program is loaded into memory, various (basic) steps involved in the process.

Let us see a typical “Hello World” program in C. Simple Hello World program screen image is given below.

We were compiling our code using the command “gcc -o sample shared.c” When we compile our code, the compiler won’t resolve implementation of the function printf(). It only verifies the syntactical checking. The tool chain leaves a stub in our application which will be filled by dynamic linker. Since printf is standard function the compiler implicitly invoking its shared library. More details down.

We are using ldd to list dependencies of our program binary image. In the screen image, we can see our sample program depends on three binary files namely, linux-vdso.so.1, libc.so.6 and /lib64/ld-linux-x86-64.so.2.

The file VDSO is fast implementation of system call interface and some other stuff, it is not our focus (on some older systems you may see different file name in liue of *.vsdo.*). Ignore this file. We have interest in the other two files.

The file libc.so.6 is C implementation of various standard functions. It is the file where we see printf definition needed for our Hello World. It is the shared library needed to be loaded into memory to run our Hello World program.

The third file /lib64/ld-linux-x86-64.so.2 is infact an executable that runs when an application is invoked. When we invoke the program on bash terminal, typically the bash forks itself and replaces its address space with image of program to run (so called fork-exec pair). The kernel verifies whether the libc.so.6 resides in the memory. If not, it will load the file into memory and does the relocation of libc.so.6 symbols. It then invokes the dynamic linker (/lib64/ld-linux-x86-64.so.2) to resolve unresolved symbols of application code (printf in the present case). Then the control transfers to our program main. (I have intensionally omitted many details in the process, our focus is to understand basic details).

Creating our own shared library:

Let us work with simple shared library on Linux. Create a file library.c with the following content.

The file library.c defines a function signum which will be used by our application code. Compile the file library.c file using the following command.

gcc -shared -fPIC -o liblibrary.so library.c

The flag -shared instructs the compiler that we are building a shared library. The flag -fPIC is to generate position independent code (ignore for now). The command generates a shared library liblibrary.so in the current working directory. We have our shared object file (shared library name in Linux) ready to use.

Create another file application.c with the following content.

In the file application.c we are invoking the function signum which was defined in a shared library. Compile the application.c file using the following command.

gcc application.c -L /home/geetanjali/coding/ -llibrary -o sample

The flag -llibrary instructs the compiler to look for symbol definitions that are not available in the current code (signum function in our case). The option -L is hint to the compiler to look in the directory followed by the option for any shared libraries (during link time only). The command generates an executable named as “sample“.

If you invoke the executable, the dynamic linker will not be able to find the required shared library. By default it won’t look into current working directory. You have to explicitly instruct the tool chain to provide proper paths. The dynamic linker searches standard paths available in the LD_LIBRARY_PATH and also searches in system cache (for details explore the command ldconfig). We have to add our working directory to the LD_LIBRARY_PATH environment variable. The following command does the same.

export LD_LIBRARY_PATH=/home/geetanjali/coding/:$LD_LIBRARY_PATH

You can now invoke our executable as shown.

./sample

Sample output on my system is shown below.

Note: The path /home/geetanjali/coding/ is working directory path on my machine. You need to use your working directory path where ever it is being used in the above commands.

Stay tuned, we haven’t even explored 1/3rd of shared library concepts. More advanced concepts in the later articles.

Exercise:

It is workbook like article. You won’t gain much unless you practice and do some research.

1. Create similar example and write your won function in the shared library. Invoke the function in another application.

2. Is (Are) there any other tool(s) which can list dependent libraries?

3. What is position independent code (PIC)?

4. What is system cache in the current context? How does the directory /etc/ld.so.conf.d/* related in the current context?

— Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
135,"In computing, a named pipe (also known as a FIFO) is one of the methods for intern-process communication.

It is an extension to the traditional pipe concept on Unix. A traditional pipe is “unnamed” and lasts only as long as the process.

A named pipe, however, can last as long as the system is up, beyond the life of the process. It can be deleted if no longer used.

Usually a named pipe appears as a file and generally processes attach to it for inter-process communication. A FIFO file is a special kind of file on the local storage which allows two or more processes to communicate with each other by reading/writing to/from this file.

A FIFO special file is entered into the filesystem by calling mkfifo() in C. Once we have created a FIFO special file in this way, any process can open it for reading or writing, in the same way as an ordinary file. However, it has to be open at both ends simultaneously before you can proceed to do any input or output operations on it.

Creating a FIFO file: In order to create a FIFO file, a function calls i.e. mkfifo is used.

filter_none edit

close play_arrow link

brightness_4

code int mkfifo( const char *pathname, mode_t mode); chevron_right filter_none

mkfifo() makes a FIFO special file with name pathname. Here mode specifies the FIFO’s permissions. It is modified by the process’s umask in the usual way: the permissions of the created file are (mode & ~umask).

Using FIFO: As named pipe(FIFO) is a kind of file, we can use all the system calls associated with it i.e. open, read, write, close.

Example Programs to illustrate the named pipe: There are two programs that use the same FIFO. Program 1 writes first, then reads. The program 2 reads first, then writes. They both keep doing it until terminated.

Program 1(Writes first) filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <string.h> #include <fcntl.h> #include <sys/stat.h> #include <sys/types.h> #include <unistd.h> int main() { int fd; char * myfifo = ""/tmp/myfifo"" ; mkfifo(myfifo, 0666); char arr1[80], arr2[80]; while (1) { fd = open(myfifo, O_WRONLY); fgets (arr2, 80, stdin); write(fd, arr2, strlen (arr2)+1); close(fd); fd = open(myfifo, O_RDONLY); read(fd, arr1, sizeof (arr1)); printf ( ""User2: %s

"" , arr1); close(fd); } return 0; } chevron_right filter_none Program 2(Reads First) filter_none edit

close play_arrow link

brightness_4

code #include <stdio.h> #include <string.h> #include <fcntl.h> #include <sys/stat.h> #include <sys/types.h> #include <unistd.h> int main() { int fd1; char * myfifo = ""/tmp/myfifo"" ; mkfifo(myfifo, 0666); char str1[80], str2[80]; while (1) { fd1 = open(myfifo,O_RDONLY); read(fd1, str1, 80); printf ( ""User1: %s

"" , str1); close(fd1); fd1 = open(myfifo,O_WRONLY); fgets (str2, 80, stdin); write(fd1, str2, strlen (str2)+1); close(fd1); } return 0; } chevron_right filter_none

Output: Run the two programs simultaneously on two terminals.

This article is contributed by Kishlay Verma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : PaarmitaBhargava"
136,"Often it’s necessary to trace memory usage of the system in order to determine the program that consumes all CPU resources or the program that is responsible to slowing down the activities of the CPU. Tracing memory usage also becomes necessary to determine the load on the server. Parsing the usage data enables the servers to be able to balance the load and serve the user’s request without slowing down the system.

free Displays the amount of memory which is currently available and used by the system(both physical and swapped). free command gathers this data by parsing /proc/meminfo. By default, the amount of memory is display in kilobytes. free command in UNIX watch -n 5 free -m watch command is used to execute a program periodically. According to the image above, there is a total of 2000 MB of RAM and 1196 MB of swap space allotted to Linux system. Out of this 2000 MB of RAM, 834 MB is currently used where as 590 MB is free. Similarly for swap space, out of 1196 MB, 0 MB is use and 1196 MB is free currently in the system.



vmstat vmstat command is used to display virtual memory statistics of the system. This command reports data about the memory, paging, disk and CPU activities, etc. The first use of this command returns the data averages since the last reboot. Further uses returns the data based on sampling periods of length delays. vmstat -d Reports disk statistics vmstat -s Displays the amount of memory used and available top top command displays all the currently running process in the system. This command displays the list of processes and thread currently being handled by the kernel. top command can also be used to monitor the total amount of memory usage. top -H Threads-mode operation Displays individual thread that are currently in the system. Without this command option, a summation of all thread in each process is displayed. /proc/meminfo This file contains all the data about the memory usage. It provides the current memory usage details rather than old stored values. htop htop is an interactive process viewer. This command is similar to top command except that it allows to scroll vertically and horizontally to allows users to view all processes running on the system, along with their full command line as well as viewing them as a process tree, selecting multiple processes and acting on them all at once. working of htop command in UNIX:

Reference:

This article is contributed by Mayank Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
137,"A file is a collection of related information that is recorded on secondary storage. Or file is a collection of logically related entities. From user’s perspective a file is the smallest allotment of logical secondary storage.

Attributes Types Operations Name Doc Create Type Exe Open Size Jpg Read Creation Data Xis Write Author C Append Last Modified Java Truncate protection class Delete Close

File type Usual extension Function Executable exe, com, bin Read to run machine language program Object obj, o Compiled, machine language not linked Source Code C, java, pas, asm, a Source code in various languages Batch bat, sh Commands to the command interpreter Text txt, doc Textual data, documents Word Processor wp, tex, rrf, doc Various word processor formats Archive arc, zip, tar Related files grouped into one compressed file Multimedia mpeg, mov, rm For containing audio/video information

FILE DIRECTORIES:

Collection of files is a file directory. The directory contains information about the files, including attributes, location and ownership. Much of this information, especially that is concerned with storage, is managed by the operating system. The directory is itself a file, accessible by various file management routines.



Information contained in a device directory are:

Name

Type

Address

Current length

Maximum length

Date last accessed

Date last updated

Owner id

Protection information

Operation performed on directory are:

Search for a file

Create a file

Delete a file

List a directory

Rename a file

Traverse the file system

Advantages of maintaining directories are:

Efficiency: A file can be located more quickly.

A file can be located more quickly. Naming: It becomes convenient for users as two users can have same name for different files or may have different name for same file.

It becomes convenient for users as two users can have same name for different files or may have different name for same file. Grouping: Logical grouping of files can be done by properties e.g. all java programs, all games etc.

SINGLE-LEVEL DIRECTORY

In this a single directory is maintained for all the users.

Naming problem: Users cannot have same name for two files.

Users cannot have same name for two files. Grouping problem: Users cannot group files according to their need.





TWO-LEVEL DIRECTORY

In this separate directories for each user is maintained.

Path name:Due to two levels there is a path name for every file to locate that file.

Now,we can have same file name for different user.

Searching is efficient in this method.





TREE-STRUCTURED DIRECTORY :

Directory is maintained in the form of a tree. Searching is efficient and also there is grouping capability. We have absolute or relative path name for a file.





FILE ALLOCATION METHODS

1. Continuous Allocation: A single continuous set of blocks is allocated to a file at the time of file creation. Thus, this is a pre-allocation strategy, using variable size portions. The file allocation table needs just a single entry for each file, showing the starting block and the length of the file. This method is best from the point of view of the individual sequential file. Multiple blocks can be read in at a time to improve I/O performance for sequential processing. It is also easy to retrieve a single block. For example, if a file starts at block b, and the ith block of the file is wanted, its location on secondary storage is simply b+i-1.





Disadvantage

External fragmentation will occur, making it difficult to find contiguous blocks of space of sufficient length. Compaction algorithm will be necessary to free up additional space on disk.

Also, with pre-allocation, it is necessary to declare the size of the file at the time of creation.

2. Linked Allocation(Non-contiguous allocation) : Allocation is on an individual block basis. Each block contains a pointer to the next block in the chain. Again the file table needs just a single entry for each file, showing the starting block and the length of the file. Although pre-allocation is possible, it is more common simply to allocate blocks as needed. Any free block can be added to the chain. The blocks need not be continuous. Increase in file size is always possible if free disk block is available. There is no external fragmentation because only one block at a time is needed but there can be internal fragmentation but it exists only in the last disk block of file.



Disadvantage:

Internal fragmentation exists in last disk block of file.

There is an overhead of maintaining the pointer in every disk block.

If the pointer of any disk block is lost, the file will be truncated.

It supports only the sequencial access of files.

3. Indexed Allocation:

It addresses many of the problems of contiguous and chained allocation. In this case, the file allocation table contains a separate one-level index for each file: The index has one entry for each block allocated to the file. Allocation may be on the basis of fixed-size blocks or variable-sized blocks. Allocation by blocks eliminates external fragmentation, whereas allocation by variable-size blocks improves locality. This allocation technique supports both sequential and direct access to the file and thus is the most popular form of file allocation.





Disk Free Space Management

Just as the space that is allocated to files must be managed ,so the space that is not currently allocated to any file must be managed. To perform any of the file allocation techniques,it is necessary to know what blocks on the disk are available. Thus we need a disk allocation table in addition to a file allocation table.The following are the approaches used for free space management.

Bit Tables : This method uses a vector containing one bit for each block on the disk. Each entry for a 0 corresponds to a free block and each 1 corresponds to a block in use.

For example: 00011010111100110001 In this vector every bit correspond to a particular block and 0 implies that, that particular block is free and 1 implies that the block is already occupied. A bit table has the advantage that it is relatively easy to find one or a contiguous group of free blocks. Thus, a bit table works well with any of the file allocation methods. Another advantage is that it is as small as possible. Free Block List : In this method, each block is assigned a number sequentially and the list of the numbers of all free blocks is maintained in a reserved block of the disk.



This article is contributed by Aakansha yadav

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : raghvanimahesh"
138,"Unix file system is a logical method of organizing and storing large amounts of information in a way that makes it easy to manage. A file is a smallest unit in which the information is stored. Unix file system has several important features. All data in Unix is organized into files. All files are organized into directories. These directories are organized into a tree-like structure called the file system.

Files in Unix System are organized into multi-level hierarchy structure known as a directory tree. At the very top of the file system is a directory called “root” which is represented by a “/”. All other files are “descendants” of root.

Directories or Files and their description –

/ : The slash / character alone denotes the root of the filesystem tree.

The slash / character alone denotes the root of the filesystem tree. /bin : Stands for “binaries” and contains certain fundamental utilities, such as ls or cp, which are generally needed by all users.

Stands for “binaries” and contains certain fundamental utilities, such as ls or cp, which are generally needed by all users. /boot : Contains all the files that are required for successful booting process.

Contains all the files that are required for successful booting process. /dev : Stands for “devices”. Contains file representations of peripheral devices and pseudo-devices.

Stands for “devices”. Contains file representations of peripheral devices and pseudo-devices. /etc : Contains system-wide configuration files and system databases. Originally also contained “dangerous maintenance utilities” such as init,but these have typically been moved to /sbin or elsewhere.

Contains system-wide configuration files and system databases. Originally also contained “dangerous maintenance utilities” such as init,but these have typically been moved to /sbin or elsewhere. /home : Contains the home directories for the users.

Contains the home directories for the users. /lib : Contains system libraries, and some critical files such as kernel modules or device drivers.

Contains system libraries, and some critical files such as kernel modules or device drivers. /media : Default mount point for removable devices, such as USB sticks, media players, etc.

Default mount point for removable devices, such as USB sticks, media players, etc. /mnt : Stands for “mount”. Contains filesystem mount points. These are used, for example, if the system uses multiple hard disks or hard disk partitions. It is also often used for remote (network) filesystems, CD-ROM/DVD drives, and so on.

Stands for “mount”. Contains filesystem mount points. These are used, for example, if the system uses multiple hard disks or hard disk partitions. It is also often used for remote (network) filesystems, CD-ROM/DVD drives, and so on. /proc : procfs virtual filesystem showing information about processes as files.

procfs virtual filesystem showing information about processes as files. /root : The home directory for the superuser “root” – that is, the system administrator. This account’s home directory is usually on the initial filesystem, and hence not in /home (which may be a mount point for another filesystem) in case specific maintenance needs to be performed, during which other filesystems are not available. Such a case could occur, for example, if a hard disk drive suffers physical failures and cannot be properly mounted.

The home directory for the superuser “root” – that is, the system administrator. This account’s home directory is usually on the initial filesystem, and hence not in /home (which may be a mount point for another filesystem) in case specific maintenance needs to be performed, during which other filesystems are not available. Such a case could occur, for example, if a hard disk drive suffers physical failures and cannot be properly mounted. /tmp : A place for temporary files. Many systems clear this directory upon startup; it might have tmpfs mounted atop it, in which case its contents do not survive a reboot, or it might be explicitly cleared by a startup script at boot time.

A place for temporary files. Many systems clear this directory upon startup; it might have tmpfs mounted atop it, in which case its contents do not survive a reboot, or it might be explicitly cleared by a startup script at boot time. /usr : Originally the directory holding user home directories,its use has changed. It now holds executables, libraries, and shared resources that are not system critical, like the X Window System, KDE, Perl, etc. However, on some Unix systems, some user accounts may still have a home directory that is a direct subdirectory of /usr, such as the default as in Minix. (on modern systems, these user accounts are often related to server or system use, and not directly used by a person).

Originally the directory holding user home directories,its use has changed. It now holds executables, libraries, and shared resources that are not system critical, like the X Window System, KDE, Perl, etc. However, on some Unix systems, some user accounts may still have a home directory that is a direct subdirectory of /usr, such as the default as in Minix. (on modern systems, these user accounts are often related to server or system use, and not directly used by a person). /usr/bin : This directory stores all binary programs distributed with the operating system not residing in /bin, /sbin or (rarely) /etc.

This directory stores all binary programs distributed with the operating system not residing in /bin, /sbin or (rarely) /etc. /usr/include : Stores the development headers used throughout the system. Header files are mostly used by the #include directive in C/C++ programming language.

Stores the development headers used throughout the system. Header files are mostly used by the directive in C/C++ programming language. /usr/lib : Stores the required libraries and data files for programs stored within /usr or elsewhere.

Stores the required libraries and data files for programs stored within /usr or elsewhere. /var : A short for “variable.” A place for files that may change often – especially in size, for example e-mail sent to users on the system, or process-ID lock files.

A short for “variable.” A place for files that may change often – especially in size, for example e-mail sent to users on the system, or process-ID lock files. /var/log : Contains system log files.

Contains system log files. /var/mail : The place where all the incoming mails are stored. Users (other than root) can access their own mail only. Often, this directory is a symbolic link to /var/spool/mail.

The place where all the incoming mails are stored. Users (other than root) can access their own mail only. Often, this directory is a symbolic link to /var/spool/mail. /var/spool : Spool directory. Contains print jobs, mail spools and other queued tasks.

Spool directory. Contains print jobs, mail spools and other queued tasks. /var/tmp : A place for temporary files which should be preserved between system reboots.

Types of Unix files – The UNIX files system contains several different types of files :

1. Ordinary files – An ordinary file is a file on the system that contains data, text, or program instructions.

Used to store your information, such as some text you have written or an image you have drawn. This is the type of file that you usually work with.

Always located within/under a directory file.

Do not contain other files.

In long-format output of ls -l, this type of file is specified by the “-” symbol.

2. Directories – Directories store both special and ordinary files. For users familiar with Windows or Mac OS, UNIX directories are equivalent to folders. A directory file contains an entry for every file and subdirectory that it houses. If you have 10 files in a directory, there will be 10 entries in the directory. Each entry has two components.

(1) The Filename

(2) A unique identification number for the file or directory (called the inode number)

Branching points in the hierarchical tree.

Used to organize groups of files.

May contain ordinary files, special files or other directories.

Never contain “real” information which you would work with (such as text). Basically, just used for organizing files.

All files are descendants of the root directory, ( named / ) located at the top of the tree.

In long-format output of ls –l , this type of file is specified by the “d” symbol.

3. Special Files – Used to represent a real physical device such as a printer, tape drive or terminal, used for Input/Output (I/O) operations. Device or special files are used for device Input/Output(I/O) on UNIX and Linux systems. They appear in a file system just like an ordinary file or a directory.

On UNIX systems there are two flavors of special files for each device, character special files and block special files :

When a character special file is used for device Input/Output(I/O), data is transferred one character at a time. This type of access is called raw device access.

When a block special file is used for device Input/Output(I/O), data is transferred in large fixed-size blocks. This type of access is called block device access.

For terminal devices, it’s one character at a time. For disk devices though, raw access means reading or writing in whole chunks of data – blocks, which are native to your disk.

In long-format output of ls -l, character special files are marked by the “c” symbol.

In long-format output of ls -l, block special files are marked by the “b” symbol.

4. Pipes – UNIX allows you to link commands together using a pipe. The pipe acts a temporary file which only exists to hold data from one command until it is read by another.A Unix pipe provides a one-way flow of data.The output or result of the first command sequence is used as the input to the second command sequence. To make a pipe, put a vertical bar (|) on the command line between two commands.For example: who | wc -l

In long-format output of ls –l , named pipes are marked by the “p” symbol.

5. Sockets – A Unix socket (or Inter-process communication socket) is a special file which allows for advanced inter-process communication. A Unix Socket is used in a client-server application framework. In essence, it is a stream of data, very similar to network stream (and network sockets), but all the transactions are local to the filesystem.

In long-format output of ls -l, Unix sockets are marked by “s” symbol.

6. Symbolic Link – Symbolic link is used for referencing some other file of the file system.Symbolic link is also known as Soft link. It contains a text form of the path to the file it references. To an end user, symbolic link will appear to have its own name, but when you try reading or writing data to this file, it will instead reference these operations to the file it points to. If we delete the soft link itself , the data file would still be there.If we delete the source file or move it to a different location, symbolic file will not function properly.

In long-format output of ls –l , Symbolic link are marked by the “l” symbol (that’s a lower case L).

Reference –

UNIX – Concepts and Applications | Sumitabha Das |Tata McGraw Hill |4th Edition

This article is contributed by Saloni Gupta . If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : OmkarManjrekar, Akanksha_Rai"
139,"In any Operating System, it is necessary to have Dual Mode Operation to ensure protection and security of the System from unauthorized or errant users . This Dual Mode separates the User Mode from the System Mode or Kernel Mode.

What are Privileged Instructions?

The Instructions that can run only in Kernel Mode are called Privileged Instructions .

Privileged Instructions possess the following characteristics :

(i) If any attempt is made to execute a Privileged Instruction in User Mode, then it will not be executed and treated as an illegal instruction. The Hardware traps it to the Operating System.

(ii) Before transferring the control to any User Program, it is the responsibility of the Operating System to ensure that the Timer is set to interrupt. Thus, if the timer interrupts then the Operating System regains the control.

Thus, any instruction which can modify the contents of the Timer is a Privileged Instruction.

(iii) Privileged Instructions are used by the Operating System in order to achieve correct operation.

(iv) Various examples of Privileged Instructions include:

I/O instructions and Halt instructions

Turn off all Interrupts

Set the Timer

Context Switching

Clear the Memory or Remove a process from the Memory

Modify entries in Device-status table

What are Non-Privileged Instructions?

The Instructions that can run only in User Mode are called Non-Privileged Instructions .

Various examples of Non-Privileged Instructions include:

Reading the status of Processor

Reading the System Time

Generate any Trap Instruction

Sending the final prinout of Printer

Also, it is important to note that in order to change the mode from Privileged to Non-Privileged, we require a Non-privileged Instruction that does not generate any interrupt.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
140,"Prerequisite – File Systems

Hierarchical Directory Systems –

Directory is maintained in the form of a tree. Each user can have as many directories as are needed so, that files can be grouped together in a natural way.

Advantages of this structure:

Searching is efficient

Groping capability of files increase

When the file system is organized as a directory tree, some way is needed for specifying file names.

Two different methods are commonly used:

Absolute Path name – In this method, each file is given an absolute path name consisting of the path from the root directory to the file. As an example, the path /usr/ast/mailbox means that the root directory contains a subdirectory usr, which in turn contains a subdirectory ast, which contains the file mailbox. Absolute path names always start at the root directory and are unique. In UNIX the components of the path are separated by ‘/’. In Windows, the separator is ‘\’.

Windows \usr\ast\mailbox

UNIX /usr/ast/mailbox Relative Path name – This is used in conjunction with the concept of the working directory (also called the current directory).A user can designate one directory as the current working directory, in which case all path names not beginning at the root directory are taken relative to the working directory. For example, if the current working directory is /usr/ast, then the file whose absolute path is /usr/ast/mailbox can be referenced simply as mailbox.

In other words, the UNIX

command : cp /usr/ast/mailbox /usr/ast/mailbox.bak

and the command : cp mailbox mailbox.bak

do exactly the same thing if the working directory is /usr/ast.

When to use which approach?

Some programs need to access a specific file without regard to what the working directory is. In that case, they should always use absolute path names. For example, a spelling checker might need to read /usr/lib/dictionary to do its work. It should use the full, absolute path name in this case because it does not know what the working directory will be when it is called. The absolute path name will always work, no matter what the working directory is.

Of course, if the spelling checker needs a large number of files from /usr/lib, an alternative approach is for it to issue a system call to change its working directory to /usr/lib, and then use just dictionary as the first parameter to open. By explicitly changing the working directory, it knows for sure where it is in the directory tree, so it can then use relative paths.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : magbene"
141,"A directory is a container that is used to contain folders and file. It organizes files and folders into a hierarchical manner.

There are several logical structures of a directory, these are given below.

Single-level directory –

Single level directory is simplest directory structure.In it all files are contained in same directory which make it easy to support and understand. A single level directory has a significant limitation, however, when the number of files increases or when the system has more than one user. Since all the files are in the same directory, they must have the unique name . if two users call their dataset test, then the unique name rule violated.



Advantages: Since it is a single directory, so its implementation is very easy.

If the files are smaller in size, searching will become faster.

The operations like file creation, searching, deletion, updating are very easy in such a directory structure. Disadvantages: There may chance of name collision because two files can not have the same name.

Searching will become time taking if the directory is large.

In this can not group the same type of files together. Two-level directory –

As we have seen, a single level directory often leads to confusion of files names among different users. the solution to this problem is to create a separate directory for each user. In the two-level directory structure, each user has there own user files directory (UFD). The UFDs has similar structures, but each lists only the files of a single user. system’s master file directory (MFD) is searches whenever a new user id=s logged in. The MFD is indexed by username or account number, and each entry points to the UFD for that user. Advantages: We can give full path like /User-name/directory-name/.

Different users can have same directory as well as file name.

Searching of files become more easy due to path name and user-grouping. Disadvantages:



A user is not allowed to share files with other users.

Still it not very scalable, two files of the same type cannot be grouped together in the same user. Tree-structured directory –

Once we have seen a two-level directory as a tree of height 2, the natural generalization is to extend the directory structure to a tree of arbitrary height.

This generalization allows the user to create there own subdirectories and to organize on their files accordingly. A tree structure is the most common directory structure. The tree has a root directory, and every file in the system have a unique path. Advantages: Very generalize, since full path name can be given.

Very scalable, the probability of name collision is less.

Searching becomes very easy, we can use both absolute path as well as relative. Disadvantages: Every file does not fit into the hierarchical model, files may be saved into multiple directories.

We can not share files.

It is inefficient, because accessing a file may go under multiple directories. Acyclic graph directory –

An acyclic graph is a graph with no cycle and allows to share subdirectories and files. The same file or subdirectories may be in two different directories. It is a natural generalization of the tree-structured directory. It is used in the situation like when two programmers are working on a joint project and they need to access files. The associated files are stored in a subdirectory, separating them from other projects and files of other programmers, since they are working on a joint project so they want the subdirectories to be into their own directories. The common subdirectories should be shared. So here we use Acyclic directories. It is the point to note that shared file is not the same as copy file . If any programmer makes some changes in the subdirectory it will reflect in both subdirectories. Advantages: We can share files.

Searching is easy due to different-different paths. Disadvantages: We share the files via linking, in case of deleting it may create the problem,

If the link is softlink then after deleting the file we left with a dangling pointer.

In case of hardlink, to delete a file we have to delete all the reference associated with it. General graph directory structure –

In general graph directory structure, cycles are allowed within a directory structure where multiple directories can be derived from more than one parent directory.

The main problem with this kind of directory structure is to calculate total size or space that has been taken by the files and directories. Advantages: It allows cycles.

It is more flexible than other directories structure. Disadvantages: It is more costly than others.

It needs garbage collection.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : shubham_singh, nehasharma93517, MiranJunaidi"
142,"The allocation methods define how the files are stored in the disk blocks. There are three main disk space or file allocation methods.

Contiguous Allocation

Linked Allocation

Indexed Allocation

The main idea behind these methods is to provide:

Efficient disk space utilization.

Fast access to the file blocks.

All the three methods have their own advantages and disadvantages as discussed below:

1. Contiguous Allocation

In this scheme, each file occupies a contiguous set of blocks on the disk. For example, if a file requires n blocks and is given a block b as the starting location, then the blocks assigned to the file will be: b, b+1, b+2,……b+n-1. This means that given the starting block address and the length of the file (in terms of blocks required), we can determine the blocks occupied by the file.

The directory entry for a file with contiguous allocation contains

Address of starting block

Length of the allocated portion.

The file ‘mail’ in the following figure starts from the block 19 with length = 6 blocks. Therefore, it occupies 19, 20, 21, 22, 23, 24 blocks.



Advantages:

Both the Sequential and Direct Accesses are supported by this. For direct access, the address of the kth block of the file which starts at block b can easily be obtained as (b+k).

This is extremely fast since the number of seeks are minimal because of contiguous allocation of file blocks.

Disadvantages:

This method suffers from both internal and external fragmentation. This makes it inefficient in terms of memory utilization.

Increasing file size is difficult because it depends on the availability of contiguous memory at a particular instance.

2. Linked List Allocation

In this scheme, each file is a linked list of disk blocks which need not be contiguous. The disk blocks can be scattered anywhere on the disk.

The directory entry contains a pointer to the starting and the ending file block. Each block contains a pointer to the next block occupied by the file.

The file ‘jeep’ in following image shows how the blocks are randomly distributed. The last block (25) contains -1 indicating a null pointer and does not point to any other block.



Advantages:

This is very flexible in terms of file size. File size can be increased easily since the system does not have to look for a contiguous chunk of memory.

This method does not suffer from external fragmentation. This makes it relatively better in terms of memory utilization.

Disadvantages:

Because the file blocks are distributed randomly on the disk, a large number of seeks are needed to access every block individually. This makes linked allocation slower.

It does not support random or direct access. We can not directly access the blocks of a file. A block k of a file can be accessed by traversing k blocks sequentially (sequential access ) from the starting block of the file via block pointers.

Pointers required in the linked allocation incur some extra overhead.

3. Indexed Allocation

In this scheme, a special block known as the Index block contains the pointers to all the blocks occupied by a file. Each file has its own index block. The ith entry in the index block contains the disk address of the ith file block. The directory entry contains the address of the index block as shown in the image:



Advantages:

This supports direct access to the blocks occupied by the file and therefore provides fast access to the file blocks.

It overcomes the problem of external fragmentation.

Disadvantages:

The pointer overhead for indexed allocation is greater than linked allocation.

For very small files, say files that expand only 2-3 blocks, the indexed allocation would keep one entire block (index block) for the pointers which is inefficient in terms of memory utilization. However, in linked allocation we lose the space of only 1 pointer per block.

For files that are very large, single index block may not be able to hold all the pointers.

Following mechanisms can be used to resolve this:

Linked scheme: This scheme links two or more index blocks together for holding the pointers. Every index block would then contain a pointer or the address to the next index block. Multilevel index: In this policy, a first level index block is used to point to the second level index blocks which inturn points to the disk blocks occupied by the file. This can be extended to 3 or more levels depending on the maximum file size. Combined Scheme: In this scheme, a special block called the Inode (information Node) contains all the information about the file such as the name, size, authority, etc and the remaining space of Inode is used to store the Disk Block addresses which contain the actual file as shown in the image below. The first few of these pointers in Inode point to the direct blocks i.e the pointers contain the addresses of the disk blocks that contain data of the file. The next few pointers point to indirect blocks. Indirect blocks may be single indirect, double indirect or triple indirect. Single Indirect block is the disk block that does not contain the file data but the disk address of the blocks that contain the file data. Similarly, double indirect blocks do not contain the file data but the disk address of the blocks that contain the address of the blocks containing the file data.



This article is contributed by Saloni Baweja. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
143,"Prerequisite – File Systems

When a file is used, information is read and accessed into computer memory and there are several ways to access this information of the file. Some systems provide only one access method for files. Other systems, such as those of IBM, support many access methods, and choosing the right one for a particular application is a major design problem.

There are three ways to access a file into a computer system: Sequential-Access, Direct Access, Index sequential Method.

Sequential Access –

It is the simplest access method. Information in the file is processed in order, one record after the other. This mode of access is by far the most common; for example, editor and compiler usually access the file in this fashion. Read and write make up the bulk of the operation on a file. A read operation -read next- read the next position of the file and automatically advance a file pointer, which keeps track I/O location. Similarly, for the writewrite next append to the end of the file and advance to the newly written material. Key points:



Data is accessed one record right after another record in an order.



When we use read command, it move ahead pointer by one



When we use write command, it will allocate memory and move the pointer to the end of the file



Such a method is reasonable for tape.

Direct Access –

Another method is direct access method also known as relative access method. A filed-length logical record that allows the program to read and write record rapidly. in no particular order. The direct access is based on the disk model of a file since disk allows random access to any file block. For direct access, the file is viewed as a numbered sequence of block or record. Thus, we may read block 14 then block 59 and then we can write block 17. There is no restriction on the order of reading and writing for a direct access file. A block number provided by the user to the operating system is normally a relative block number, the first relative block of the file is 0 and then 1 and so on. Index sequential method –

It is the other method of accessing a file which is built on the top of the sequential access method. These methods construct an index for the file. The index, like an index in the back of a book, contains the pointer to the various blocks. To find a record in the file, we first search the index and then by the help of pointer we access the file directly. Key points: It is built on top of Sequential access.



It control the pointer by using index.



Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : Gokohan, DevanshGandhi, 189y1a05c8"
144,"Primary memory has limited storage capacity and is volatile. Secondary memory overcome this limitation by providing permanent storage of data and in bulk quantity. Secondary memory is also termed as external memory and refers to the various storage media on which a computer can store data and programs. The Secondary storage media can be fixed or removable. Fixed Storage media is an internal storage medium like hard disk that is fixed inside the computer. Storage medium that are portable and can be taken outside the computer are termed as removable storage media.

Difference between Primary Memory and Secondary Memory:

Primary Memory Secondary Memory Primary memory is directly accessed by the Central Processing Unit(CPU). Secondary memory is not accessed directly by the Central Processing Unit(CPU). Instead, data accessed from a secondary memory is first loaded into Random Access Memory(RAM) and is then sent to the Processing Unit. RAM provides much faster accessing speed to data than secondary memory. By loading software programs and required files into primary memory(RAM), computer can process data much more quickly. Secondary Memory is slower in data accessing. Typically primary memory is six times faster than the secondary memory. Primary memory, i.e. Random Access Memory(RAM) is volatile and gets completely erased when a computer is shut down. Secondary memory provides a feature of being non-volatile, which means it can hold on to its data with or without electrical power supply.

Uses of Secondary Media:

Permanent Storage: Primary Memory (RAM) is volatile, i.e. it loses all information when the electricity is turned off, so in order to secure the data permanently in the device, Secondary storage devices are needed.

Primary Memory (RAM) is volatile, i.e. it loses all information when the electricity is turned off, so in order to secure the data permanently in the device, Secondary storage devices are needed. Portability: Storage medium, like the CDs, flash drives can be used to transfer the data from one devive to another.

Fixed and Removable Storage

Fixed Storage-

A Fixed storage is an internal media device that is used by a computer system to store data, and usually these are referred to as the Fixed Disks drives or the Hard Drives.

Fixed storage devices are literally not fixed, obviously these can be removed from the system for repairing work, maintenance purpose, and also for upgrade etc. But in general, this can’t be done without a proper toolkit to open up the computer system to provide physical access, and that needs to be done by an engineer.

Technically, almost all of the data i.e. being processed on a computer system is stored on some type of a built-in fixed storage device.

Types of fixed storage:

Internal flash memory (rare)

SSD (solid-state disk) units

Hard disk drives (HDD)

Removable Storage-

A Removable storage is an external media device that is used by a computer system to store data, and usually these are referred to as the Removable Disks drives or the External Drives.

Removable storage is any type of storage device that can be removed/ejected from a computer system while the system is running. Examples of external devices include CDs, DVDs and Blu-Ray disk drives, as well as diskettes and USB drives. Removable storage makes it easier for a user to transfer data from one computer system to another.

In a storage factors, the main benefit of removable disks is that they can provide the fast data transfer rates associated with storage area networks (SANs)

Types of Removable Storage:

Optical discs (CDs, DVDs, Blu-ray discs)

Memory cards

Floppy disks

Magnetic tapes

Disk packs

Paper storage (punched tapes , punched cards)

Secondary Storage Media

There are the following main types of storage media:

1. Magnetic storage media:

Magnetic media is coated with a magnetic layer which is magnetized in clockwise or anticlockwise directions. When the disk moves, the head interprets the data stored at a specific location in binary 1s and 0s at reading.

Examples: hard disks, floppy disks and magnetic tapes.



Floppy Disk: A floppy disk is a flexible disk with a magnetic coating on it. It is packaged inside a protective plastic envelope. These are one of the oldest type of portable storage devices that could store up to 1.44 MB of data but now they are not used due to very less memory storage.

A floppy disk is a flexible disk with a magnetic coating on it. It is packaged inside a protective plastic envelope. These are one of the oldest type of portable storage devices that could store up to 1.44 MB of data but now they are not used due to very less memory storage. Hard disk: A hard disk consists of one or more circular disks called platters which are mounted on a common spindle. Each surface of a platter is coated with a magnetic material. Both surfaces of each disk are capable of storing data except the top and bottom disk where only the inner surface is used. The information is recorded on the surface of the rotating disk by magnetic read/write heads. These heads are joined to a common arm known as access arm. Hard disk drive components:

Most of the basic types of hard drives contains a number of disk platters that are placed around a spindle which is placed inside a sealed chamber. The chamber also includes read/write head and motors. Data is stored on each of these disks in the arrangement of concentric circles called tracks which are divided further into sectors. Though internal Hard drives are not very portable and used internally in a computer system, external hard disks can be used as a substitute for portable storage. Hard disks can store data upto several terabytes.

2. Optical storage media

In optical storage media information is stored and read using a laser beam. The data is stored as a spiral pattern of pits and ridges denoting binary 0 and binary 1.

Examples: CDs and DVDs



Compact Disk: A Compact Disc drive(CDD) is a device that a computer uses to read data that is encoded digitally on a compact disc(CD). A CD drive can be installed inside a computer’s compartment, provided with an opening for easier disc tray access or it can be used by a peripheral device connected to one of the ports provided in the computer system.A compact disk or CD can store approximately 650 to 700 megabytes of data. A computer should possess a CD Drive to read the CDs. There are three types of CDs:

A Compact Disc drive(CDD) is a device that a computer uses to read data that is encoded digitally on a compact disc(CD). A CD drive can be installed inside a computer’s compartment, provided with an opening for easier disc tray access or it can be used by a peripheral device connected to one of the ports provided in the computer system.A compact disk or CD can store approximately 650 to 700 megabytes of data. A computer should possess a CD Drive to read the CDs. There are three types of CDs: CD- ROM CD-R CD-RW It stands for Compact Disk – Read Only Memory It stands for Compact Disk- Recordable. It stands for Compact Disk-Rewritable. Data is written on these disks at the time of manufacture. This data cannot be changed, once is it written by the manufacturer, but can only be read. CD- ROMs are used for text, audio and video distribution like games, encyclopedias and application software. Data can be recorded on these disks but only once. Once the data is written in a CD-R, it cannot be erased/modified. It can be read or written multiple times but a CD-RW drive needs to be installed on your computer before editing a CD-RW. DVD:

It stands for Digital Versatile Disk or Digital Video Disk. It looks just like a CD and use a similar technology as that of the CDs but allows tracks to be spaced closely enough to store data that is more than six times the CD’s capacity. It is a significant advancement in portable storage technology. A DVD holds 4.7 GB to 17 GB of data.

It stands for Digital Versatile Disk or Digital Video Disk. It looks just like a CD and use a similar technology as that of the CDs but allows tracks to be spaced closely enough to store data that is more than six times the CD’s capacity. It is a significant advancement in portable storage technology. A DVD holds 4.7 GB to 17 GB of data. Blue Ray Disk:

This is the latest optical storage media to store high definition audio and video. It is similar to a CD or DVD but can store up to 27 GB of data on a single layer disk and up to 54 GB of data on a dual layer disk. While CDs or DVDs use red laser beam, the blue ray disk uses a blue laser to read/write data on a disk.

3. Solid State Memories

Solid-state storage devices are based on electronic circuits with no moving parts like the reels of tape, spinning discs etc. Solid-state storage devices use special memories called flash memory to store data. Solid state drive (or flash memory) is used mainly in digital cameras, pen drives or USB flash drives.

Pen Drives:

Pen Drives or Thumb drives or Flash drives are the recently emerged portable storage media. It is an EEPROM based flash memory which can be repeatedly erased and written using electric signals. This memory is accompanied with a USB connector which enables the pendrive to connect to the computer. They have a capacity smaller than a hard disk but greater than a CD. Pendrive has following advantages:

Transfer Files:

A pen drive being plugged into a USB port of the system can be used as a device to transfer files, documents and photos to a PC and also vice versa. Similarly, selected files can be transferred between a pen drive and any type of workstation.

A pen drive being plugged into a USB port of the system can be used as a device to transfer files, documents and photos to a PC and also vice versa. Similarly, selected files can be transferred between a pen drive and any type of workstation. Portability:

The lightweight nature and smaller size of a pen drive make it possible to carry it from place to place which makes data transportation an easier task.

The lightweight nature and smaller size of a pen drive make it possible to carry it from place to place which makes data transportation an easier task. Backup Storage:

Most of the pen drives now come with a feature of having password encryption, important information related to family, medical records and photos can be stored on them as a backup.

Most of the pen drives now come with a feature of having password encryption, important information related to family, medical records and photos can be stored on them as a backup. Transport Data:

Professionals/Students can now easily transport large data files and video/audio lectures on a pen drive and gain access to them from anywhere. Independent PC technicians can store work-related utility tools, various programs and files on a high-speed 64 GB pen drive and move from one site to another.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
145,"A hard disk is a memory storage device which looks like this:

The disk is divided into tracks. Each track is further divided into sectors. The point to be noted here is that outer tracks are bigger in size than the inner tracks but they contain the same number of sectors and have equal storage capacity. This is because the storage density is high in sectors of the inner tracks where as the bits are sparsely arranged in sectors of the outer tracks. Some space of every sector is used for formatting. So, the actual capacity of a sector is less than the given capacity.

Read-Write(R-W) head moves over the rotating hard disk. It is this Read-Write head that performs all the read and write operations on the disk and hence, position of the R-W head is a major concern. To perform a read or write operation on a memory location, we need to place the R-W head over that position. Some important terms must be noted here:

Seek time – The time taken by the R-W head to reach the desired track from it’s current position. Rotational latency – Time taken by the sector to come under the R-W head. Data transfer time – Time taken to transfer the required amount of data. It depends upon the rotational speed. Controller time – The processing time taken by the controller. Average Access time – seek time + Average Rotational latency + data transfer time + controller time.

Note:Average Rotational latency is mostly 1/2*(Rotetional latency).

In questions, if the seek time and controller time is not mentioned, take them to be zero.

If the amount of data to be transferred is not given, assume that no data is being transferred. Otherwise, calculate the time taken to transfer the given amount of data.

The average of rotational latency is taken when the current position of R-W head is not given. Because, the R-W may be already present at the desired position or it might take a whole rotation to get the desired sector under the R-W head. But, if the current position of the R-W head is given then the rotational latency must be calculated.

Example –

Consider a hard disk with:

4 surfaces

64 tracks/surface

128 sectors/track

256 bytes/sector

What is the capacity of the hard disk?

Disk capacity = surfaces * tracks/surface * sectors/track * bytes/sector

Disk capacity = 4 * 64 * 128 * 256

Disk capacity = 8 MB The disk is rotating at 3600 RPM, what is the data transfer rate?

60 sec -> 3600 rotations

1 sec -> 60 rotations

Data transfer rate = number of rotations per second * track capacity * number of surfaces (since 1 R-W head is used for each surface)

Data transfer rate = 60 * 128 * 256 * 4

Data transfer rate = 7.5 MB/sec The disk is rotating at 3600 RPM, what is the average access time?

Since, seek time, controller time and the amount of data to be transferred is not given, we consider all the three terms as 0.

Therefore, Average Access time = Average rotational delay

Rotational latency => 60 sec -> 3600 rotations

1 sec -> 60 rotations

Rotational latency = (1/60) sec = 16.67 msec.

Average Rotational latency = (16.67)/2

= 8.33 msec.

Average Access time = 8.33 msec. Another example: GATE IT 2007 | Question 44

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : VaibhavRai3"
146,"Disk scheduling is done by operating systems to schedule I/O requests arriving for the disk. Disk scheduling is also known as I/O scheduling.

Disk scheduling is important because:

Multiple I/O requests may arrive by different processes and only one I/O request can be served at a time by the disk controller. Thus other I/O requests need to wait in the waiting queue and need to be scheduled.

Two or more request may be far from each other so can result in greater disk arm movement.

Hard drives are one of the slowest parts of the computer system and thus need to be accessed in an efficient manner.

There are many Disk Scheduling Algorithms but before discussing them let’s have a quick look at some of the important terms:

Seek Time : Seek time is the time taken to locate the disk arm to a specified track where the data is to be read or write. So the disk scheduling algorithm that gives minimum average seek time is better.

Seek time is the time taken to locate the disk arm to a specified track where the data is to be read or write. So the disk scheduling algorithm that gives minimum average seek time is better. Rotational Latency: Rotational Latency is the time taken by the desired sector of disk to rotate into a position so that it can access the read/write heads. So the disk scheduling algorithm that gives minimum rotational latency is better.

Rotational Latency is the time taken by the desired sector of disk to rotate into a position so that it can access the read/write heads. So the disk scheduling algorithm that gives minimum rotational latency is better. Transfer Time: Transfer time is the time to transfer the data. It depends on the rotating speed of the disk and number of bytes to be transferred.

Transfer time is the time to transfer the data. It depends on the rotating speed of the disk and number of bytes to be transferred. Disk Access Time: Disk Access Time is:

Disk Access Time = Seek Time + Rotational Latency + Transfer Time

Disk Response Time: Response Time is the average of time spent by a request waiting to perform its I/O operation. Average Response time is the response time of the all requests. Variance Response Time is measure of how individual request are serviced with respect to average response time. So the disk scheduling algorithm that gives minimum variance response time is better.

Disk Scheduling Algorithms

FCFS: FCFS is the simplest of all the Disk Scheduling Algorithms. In FCFS, the requests are addressed in the order they arrive in the disk queue.Let us understand this with the help of an example.

Example: Suppose the order of request is- (82,170,43,140,24,16,190)

And current position of Read/Write head is : 50



So, total seek time:

=(82-50)+(170-82)+(170-43)+(140-43)+(140-24)+(24-16)+(190-16)

=642

Advantages:

Every request gets a fair chance

No indefinite postponement

Disadvantages:

Does not try to optimize seek time

May not provide the best possible service

SSTF: In SSTF (Shortest Seek Time First), requests having shortest seek time are executed first. So, the seek time of every request is calculated in advance in the queue and then they are scheduled according to their calculated seek time. As a result, the request near the disk arm will get executed first. SSTF is certainly an improvement over FCFS as it decreases the average response time and increases the throughput of system.Let us understand this with the help of an example.

Example: Suppose the order of request is- (82,170,43,140,24,16,190)

And current position of Read/Write head is : 50

So, total seek time: =(50-43)+(43-24)+(24-16)+(82-16)+(140-82)+(170-40)+(190-170)

=208

Advantages:

Average Response Time decreases

Throughput increases

Disadvantages:

Overhead to calculate seek time in advance

Can cause Starvation for a request if it has higher seek time as compared to incoming requests

High variance of response time as SSTF favours only some requests

SCAN: In SCAN algorithm the disk arm moves into a particular direction and services the requests coming in its path and after reaching the end of disk, it reverses its direction and again services the request arriving in its path. So, this algorithm works as an elevator and hence also known as elevator algorithm. As a result, the requests at the midrange are serviced more and those arriving behind the disk arm will have to wait.

Example: Suppose the requests to be addressed are-82,170,43,140,24,16,190. And the Read/Write arm is at 50, and it is also given that the disk arm should move “towards the larger value”.

Therefore, the seek time is calculated as:



=(199-50)+(199-16)

=332

Advantages:

High throughput

Low variance of response time

Average response time

Disadvantages:

Long waiting time for requests for locations just visited by disk arm

CSCAN : In SCAN algorithm, the disk arm again scans the path that has been scanned, after reversing its direction. So, it may be possible that too many requests are waiting at the other end or there may be zero or few requests pending at the scanned area.

These situations are avoided in CSCAN algorithm in which the disk arm instead of reversing its direction goes to the other end of the disk and starts servicing the requests from there. So, the disk arm moves in a circular fashion and this algorithm is also similar to SCAN algorithm and hence it is known as C-SCAN (Circular SCAN).

Example:

Suppose the requests to be addressed are-82,170,43,140,24,16,190. And the Read/Write arm is at 50, and it is also given that the disk arm should move “towards the larger value”.



Seek time is calculated as:

=(199-50)+(199-0)+(43-0)

=391

Advantages:

Provides more uniform wait time compared to SCAN

LOOK: It is similar to the SCAN disk scheduling algorithm except for the difference that the disk arm in spite of going to the end of the disk goes only to the last request to be serviced in front of the head and then reverses its direction from there only. Thus it prevents the extra delay which occurred due to unnecessary traversal to the end of the disk.

Example: Suppose the requests to be addressed are-82,170,43,140,24,16,190. And the Read/Write arm is at 50, and it is also given that the disk arm should move “towards the larger value”.

So, the seek time is calculated as: =(190-50)+(190-16)

=314

CLOOK: As LOOK is similar to SCAN algorithm, in similar way, CLOOK is similar to CSCAN disk scheduling algorithm. In CLOOK, the disk arm in spite of going to the end goes only to the last request to be serviced in front of the head and then from there goes to the other end’s last request. Thus, it also prevents the extra delay which occurred due to unnecessary traversal to the end of the disk.

Example: Suppose the requests to be addressed are-82,170,43,140,24,16,190. And the Read/Write arm is at 50, and it is also given that the disk arm should move “towards the larger value”





So, the seek time is calculated as: =(190-50)+(190-16)+(43-16)

=341 RSS– It stands for random scheduling and just like its name it is nature. It is used in situations where scheduling involves random attributes such as random processing time, random due dates, random weights, and stochastic machine breakdowns this algorithm sits perfect. Which is why it is usually used for and analysis and simulation. LIFO– In LIFO (Last In, First Out) algorithm, newest jobs are serviced before the existing ones i.e. in order of requests that get serviced the job that is newest or last entered is serviced first and then the rest in the same order. Advantages Maximizes locality and resource utilization Disadvantages Can seem a little unfair to other requests and if new requests keep coming in, it cause starvation to the old and existing ones. Example

Suppose the order of request is- (82,170,43,142,24,16,190)

And current position of Read/Write head is : 50 N-STEP SCAN – It is also known as N-STEP LOOK algorithm. In this a buffer is created for N requests. All requests belonging to a buffer will be serviced in one go. Also once the buffer is full no new requests are kept in this buffer and are sent to another one. Now, when these N requests are serviced, the time comes for another top N requests and this way all get requests get a guaranteed service Advantages It eliminates starvation of requests completely FSCAN– This algorithm uses two sub-queues. During the scan all requests in the first queue are serviced and the new incoming requests are added to the second queue. All new requests are kept on halt until the existing requests in the first queue are serviced.

Advantages FSCAN along with N-Step-SCAN prevents “arm stickiness” (phenomena in I/O scheduling where the scheduling algorithm continues to service requests at or near the current sector and thus prevents any seeking)

Each algorithm is unique in its own way. Overall Performance depends on the number and type of requests.

Note:Average Rotational latency is generally taken as 1/2(Rotational latency).

Exercise

1) Suppose a disk has 201 cylinders, numbered from 0 to 200. At some time the disk arm is at cylinder 100, and there is a queue of disk access requests for cylinders 30, 85, 90, 100, 105, 110, 135 and 145. If Shortest-Seek Time First (SSTF) is being used for scheduling the disk access, the request for cylinder 90 is serviced after servicing ____________ number of requests. (GATE CS 2014

(A) 1

(B) 2

(C) 3

(D) 4

See this for solution.

2) Consider an operating system capable of loading and executing a single sequential user process at a time. The disk head scheduling algorithm used is First Come First Served (FCFS). If FCFS is replaced by Shortest Seek Time First (SSTF), claimed by the vendor to give 50% better benchmark results, what is the expected improvement in the I/O performance of user programs? (GATE CS 2004)

(A) 50%

(B) 40%

(C) 25%

(D) 0%

See this for solution.

3) Suppose the following disk request sequence (track numbers) for a disk with 100 tracks is given: 45, 20, 90, 10, 50, 60, 80, 25, 70. Assume that the initial position of the R/W head is on track 50. The additional distance that will be traversed by the R/W head when the Shortest Seek Time First (SSTF) algorithm is used compared to the SCAN (Elevator) algorithm (assuming that SCAN algorithm moves towards 100 when it starts execution) is _________ tracks

(A) 8

(B) 9

(C) 10

(D) 11

See this for solution.

4) Consider a typical disk that rotates at 15000 rotations per minute (RPM) and has a transfer rate of 50 × 10^6 bytes/sec. If the average seek time of the disk is twice the average rotational delay and the controller’s transfer time is 10 times the disk transfer time, the average time (in milliseconds) to read or write a 512 byte sector of the disk is _____________

See this for solution.

This article is contributed by Ankit Mittal. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : VaibhavRai3, Majorssn, singhkomal1702, vanshikagoyal43"
147,"Prerequisite – Disk scheduling algorithms

Given an array of disk track numbers and initial head position, our task is to find the total number of seek operations done to access all the requested tracks if Shortest Seek Time First (SSTF) is a disk scheduling algorithm is used.

Shortest Seek Time First (SSTF) –

Basic idea is the tracks which are closer to current disk head position should be serviced first in order to minimise the seek operations.

Advantages of Shortest Seek Time First (SSTF) –

Better performance than FCFS scheduling algorithm. It provides better throughput. This algorithm is used in Batch Processing system where throughput is more important. It has less average response and waiting time.

Disadvantages of Shortest Seek Time First (SSTF) –

Starvation is possible for some requests as it favours easy to reach request and ignores the far away processes. Their is lack of predictability because of high variance of response time. Switching direction slows things down.

Algorithm –

Let Request array represents an array storing indexes of tracks that have been requested. ‘head’ is the position of disk head. Find the positive distance of all tracks in the request array from head. Find a track from requested array which has not been accessed/serviced yet and has minimum distance from head. Increment the total seek count with this distance. Currently serviced track position now becomes the new head position. Go to step 2 until all tracks in request array have not been serviced.

Example –

Request sequence = {176, 79, 34, 60, 92, 11, 41, 114}

Initial head position = 50

The following chart shows the sequence in which requested tracks are serviced using SSTF.

Therefore, total seek count is calculates as:

= (50-41)+(41-34)+(34-11)+(60-11)+(79-60)+(92-79)+(114-92)+(176-114) = 204

Implementation –

Implementation of SSTF is given below. Note that we have made a node class having 2 members. ‘distance’ is used to store the distance between head and the track position. ‘accessed’ is a boolean variable which tells whether the track has been accessed/serviced before by disk head or not.



Java filter_none edit

close play_arrow link

brightness_4

code class node { int distance = 0 ; boolean accessed = false ; } public class SSTF { public static void calculateDifference( int queue[], int head, node diff[]) { for ( int i = 0 ; i < diff.length; i++) diff[i].distance = Math.abs(queue[i] - head); } public static int findMin(node diff[]) { int index = - 1 , minimum = Integer.MAX_VALUE; for ( int i = 0 ; i < diff.length; i++) { if (!diff[i].accessed && minimum > diff[i].distance) { minimum = diff[i].distance; index = i; } } return index; } public static void shortestSeekTimeFirst( int request[], int head) { if (request.length == 0 ) return ; node diff[] = new node[request.length]; for ( int i = 0 ; i < diff.length; i++) diff[i] = new node(); int seek_count = 0 ; int [] seek_sequence = new int [request.length + 1 ]; for ( int i = 0 ; i < request.length; i++) { seek_sequence[i] = head; calculateDifference(request, head, diff); int index = findMin(diff); diff[index].accessed = true ; seek_count += diff[index].distance; head = request[index]; } seek_sequence[seek_sequence.length - 1 ] = head; System.out.println( ""Total number of seek operations = "" + seek_count); System.out.println( ""Seek Sequence is"" ); for ( int i = 0 ; i < seek_sequence.length; i++) System.out.println(seek_sequence[i]); } public static void main(String[] args) { int arr[] = { 176 , 79 , 34 , 60 , 92 , 11 , 41 , 114 }; shortestSeekTimeFirst(arr, 50 ); } } chevron_right filter_none Python3 filter_none edit

close play_arrow link

brightness_4

code def calculateDifference(queue, head, diff): for i in range ( len (diff)): diff[i][ 0 ] = abs (queue[i] - head) def findMin(diff): index = - 1 minimum = 999999999 for i in range ( len (diff)): if ( not diff[i][ 1 ] and minimum > diff[i][ 0 ]): minimum = diff[i][ 0 ] index = i return index def shortestSeekTimeFirst(request, head): if ( len (request) = = 0 ): return l = len (request) diff = [ 0 ] * l for i in range (l): diff[i] = [ 0 , 0 ] seek_count = 0 seek_sequence = [ 0 ] * (l + 1 ) for i in range (l): seek_sequence[i] = head calculateDifference(request, head, diff) index = findMin(diff) diff[index][ 1 ] = True seek_count + = diff[index][ 0 ] head = request[index] seek_sequence[ len (seek_sequence) - 1 ] = head print ( ""Total number of seek operations ="" , seek_count) print ( ""Seek Sequence is"" ) for i in range (l + 1 ): print (seek_sequence[i]) if __name__ = = ""__main__"" : proc = [ 176 , 79 , 34 , 60 , 92 , 11 , 41 , 114 ] shortestSeekTimeFirst(proc, 50 ) chevron_right filter_none C# filter_none edit

close play_arrow link

brightness_4

code using System; public class node { public int distance = 0; public Boolean accessed = false ; } public class SSTF { public static void calculateDifference( int []queue, int head, node []diff) { for ( int i = 0; i < diff.Length; i++) diff[i].distance = Math.Abs(queue[i] - head); } public static int findMin(node []diff) { int index = -1, minimum = int .MaxValue; for ( int i = 0; i < diff.Length; i++) { if (!diff[i].accessed && minimum > diff[i].distance) { minimum = diff[i].distance; index = i; } } return index; } public static void shortestSeekTimeFirst( int []request, int head) { if (request.Length == 0) return ; node []diff = new node[request.Length]; for ( int i = 0; i < diff.Length; i++) diff[i] = new node(); int seek_count = 0; int [] seek_sequence = new int [request.Length + 1]; for ( int i = 0; i < request.Length; i++) { seek_sequence[i] = head; calculateDifference(request, head, diff); int index = findMin(diff); diff[index].accessed = true ; seek_count += diff[index].distance; head = request[index]; } seek_sequence[seek_sequence.Length - 1] = head; Console.WriteLine( ""Total number of seek operations = "" + seek_count); Console.WriteLine( ""Seek Sequence is"" ); for ( int i = 0; i < seek_sequence.Length; i++) Console.WriteLine(seek_sequence[i]); } public static void Main(String[] args) { int []arr = { 176, 79, 34, 60, 92, 11, 41, 114 }; shortestSeekTimeFirst(arr, 50); } } chevron_right filter_none

Output:

Total number of seek operations = 204 Seek Sequence is 50 41 34 11 60 79 92 114 176

Attention reader! Don’t stop learning now. Get hold of all the important DSA concepts with the DSA Self Paced Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : sonuyadavaffriya, SHUBHAMSINGH10, Rajput-Ji, itskawal2000"
148,"SPOOL is an acronym for simultaneous peripheral operations on-line. It is a kind of buffering mechanism or a process in which data is temporarily held to be used and executed by a device, program or the system. Data is sent to and stored in memory or other volatile storage until the program or computer requests it for execution.

In a computer system peripheral equipments, such as printers and punch card readers etc (batch processing), are very slow relative to the performance of the rest of the system. Getting input and output from the system was quickly seen to be a bottleneck. Here comes the need for spool.

Spooling works like a typical request queue where data, instructions and processes from multiple sources are accumulated for execution later on. Generally, it is maintained on computer’s physical memory, buffers or the I/O device-specific interrupts. The spool is processed in FIFO manner i.e. whatever first instruction is there in the queue will be popped and executed.

Applications/Implementations of Spool:

1) The most common can be found in I/O devices like keyboard printers and mouse. For example, In printer, the documents/files that are sent to the printer are first stored in the memory or the printer spooler. Once the printer is ready, it fetches the data from the spool and prints it.

Even experienced a situation when suddenly for some seconds your mouse or keyboard stops working? Meanwhile, we usually click again and again here and there on the screen to check if its working or not. When it actually starts working, what and wherever we pressed during its hang state gets executed very fast because all the instructions got stored in the respective device’s spool.

2) A batch processing system uses spooling to maintain a queue of ready-to-run jobs which can be started as soon as the system has the resources to process them.

3) Spooling is capable of overlapping I/O operation for one job with processor operations for another job. i.e. multiple processes can write documents to a print queue without waiting and resume with their work.

4) E-mail: an email is delivered by a MTA (Mail Transfer Agent) to a temporary storage area where it waits to be picked up by the MA (Mail User Agent)

5) Can also be used for generating Banner pages (these are the pages used in computerized printing in order to separate documents from each other and to identify e.g. the originator of the print request by username, an account number or a bin for pickup. Such pages are used in office environments where many people share the small number of available resources).

About the Author:

Ekta is a very active contributor on Geeksforgeeks. Currently studying at Delhi Technological University.She has also made a Chrome extention for www.geeksquiz.com to practice MCQs randomly.She can be reached at github.com/Ekta1994

If you also wish to showcase your blog here, please see GBlog for guest blog writing on GeeksforGeeks.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
149,"There are two ways by which Input/output subsystems can improve the performance and efficiency of the computer by using a memory space in the main memory or on the disk and these two are spooling and buffering.

Spooling –

Spooling stands for Simultaneous peripheral operation online. A spool is similar to buffer as it holds the jobs for a device until the device is ready to accept the job. It considers disk as a huge buffer that can store as many jobs for the device till the output devices are ready to accept them.

Buffering –

The main memory has an area called buffer that is used to store or hold the data temporarily that is being transmitted either between two devices or between a device or an application. Buffering is an act of storing data temporarily in the buffer. It helps in matching the speed of the data stream between the sender and the receiver. If the speed of the sender’s transmission is slower than the receiver, then a buffer is created in the main memory of the receiver, and it accumulates the bytes received from the sender and vice versa.

The basic difference between Spooling and Buffering is that Spooling overlaps the input/output of one job with the execution of another job while the buffering overlaps the input/output of one job with the execution of the same job.

Differences between Spooling and Buffering –

The key difference between spooling and buffering is that Spooling can handle the input/output of one job along with the computation of another job at the same time while buffering handles input/output of one job along with its computation.

Spooling stands for Simultaneous Peripheral Operation online. Whereas buffering is not an acronym.

Spooling is more efficient than buffering, as spooling can overlap processing two jobs at a time.

Buffering uses limited area in main memory while Spooling uses the disk as a huge buffer.

Comparison chart –

SPOOLING BUFFERING Basic Difference It overlap the input/output of one job with the execution of another job. It overlaps the input/output of one job with the execution of the same job. Full form (stands for) Simultaneous peripheral operation online No full form Efficiency Spooling is more efficient than buffering. Buffering is less efficient than spooling. Consider Size It considers disk as a huge spool or buffer. Buffer is a limited area in main memory.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : AmanSachan"
150,"Advantages –

Simple to understand.

Finding the first free block is efficient. It requires scanning the words (a group of 8 bits) in a bitmap for a non-zero word. (A 0-valued word has all bits 0). The first free block is then found by scanning for the first 1 bit in the non-zero word.

The block number can be calculated as:

(number of bits per word) *(number of 0-values words) + offset of bit first bit 1 in the non-zero word .

For the Figure-1, we scan the bitmap sequentially for the first non-zero word.

The first group of 8 bits (00001110) constitute a non-zero word since all bits are not 0. After the non-0 word is found, we look for the first 1 bit. This is the 5th bit of the non-zero word. So, offset = 5.

Therefore, the first free block number = 8*0+5 = 5."
151,"Unix is an Operating System which is truly the base of all Operating Systems like Ubuntu, Solaris, POSIX, etc. It was developed in the 1970s by Ken Thompson, Dennis Ritchie, and others in the AT&T Laboratories. It was originally meant for programmers developing software rather than non-programmers.

Unix and the C were found by AT&T and distributed to government and academic institutions, which led to both being ported to a wider variety of machine families than any other operating system. The main focus that was brought by the developers in this operating system was the Kernel. Unix was considered to be the heart of the operating System. System Structure of Unix OS are as follows:

Figure – system structure

Layer-1: Hardware –

It consists of all hardware related information.





It consists of all hardware related information. Layer-2: Kernel –

It interacts with hardware and most of the tasks like memory management, task scheduling, and management are done by the kernel.

It interacts with hardware and most of the tasks like memory management, task scheduling, and management are done by the kernel. Layer-3: Shell commands –

Shell is the utility that processes your requests. When you type in a command at the terminal, the shell interprets the command and calls the program that you want. There are various commands like cp, mv, cat, grep, id, wc, nroff, a.out and more.

Shell is the utility that processes your requests. When you type in a command at the terminal, the shell interprets the command and calls the program that you want. Layer-4: Application Layer –

It is the outermost layer that executes the given external applications.



Figure – kernel and its block diagram

This diagram shows three levels: user, kernel, and hardware.

The system call and library interface represent the border between user programs and the kernel. System calls look like ordinary function calls in C programs. Assembly language programs may invoke system calls directly without a system call library. The libraries are linked with the programs at compile time.

The set of system calls into those that interact with the file subsystem and some system calls interact with the process control subsystem. The file subsystem manages files, allocating file space, administering free space, controlling access to files, and retrieving data for users.

Processes interact with the file subsystem via a specific set of system calls, such as open (to open a file for reading or writing), close, read, write, stat (query the attributes of a file), chown (change the record of who owns the file), and chmod (change the access permissions of a file).

The file subsystem accesses file data using a buffering mechanism that regulates data flow between the kernel and secondary storage devices. The buffering mechanism interacts with block I/O device drivers to initiate data transfer to and from the kernel.

Device drivers are the kernel modules that control the operator of peripheral devices. The file subsystem also interacts directly with “raw” I/O device drivers without the intervention of the buffering mechanism. Finally, the hardware control is responsible for handling interrupts and for communicating with the machine. Devices such as disks or terminals may interrupt the CPU while a process is executing. If so, the kernel may resume execution of the interrupted process after servicing the interrupt.

Interrupts are not serviced by special processes but by special functions in the kernel, called in the context of the currently running process.

Difference between Unix and Linux –

Linux is essentially a clone of Unix. But, basic differences are shown below:

Linux Unix The source code of Linux is freely available to its users The source code of Unix is not freely available general public It has graphical user interface along with command line interface It only has command line interface Linux OS is portable, flexible, and can be executed in different hard drives Unix OS is not portable Different version of Linux are Ubuntu, Linux Mint, RedHot, Solaries, etc. Different version of Unix are AIS, HP-UX, BSD, Iris, etc. The file systems supported by Linux are as follows: xfs, ramfs, vfat, cramfsm, ext3, ext4, ext2, ext1, ufs, autofs, devpts, ntfs The file systems supported by Unix are as follows: zfs, js, hfx, gps, xfs, vxfs

My Personal Notes arrow_drop_up Save

If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. Please Improve this article if you find anything incorrect by clicking on the ""Improve Article"" button below.





Improved By : erusnika1"
152,"Linux provides some important tricks. Here are a few and important one’s:

leave — remind you when you have to leave

Syntax: leave +hhmm leave waits until the specified time (within the next 12 hours), then reminds you that you have to leave by writing to the TTY that you executed leave on. You are reminded 5 minutes and 1 minute before the actual time, at the time, and every minute thereafter.

Options: hhmm The time of day is in the form hhmm where hh is a time in hours (on a 12 or 24 hour clock), and mm are minutes. diff – compare files line by line

Syntax: diff file1 file2 Compare FILES line by line.



diff -q file1 file2 report only when files differ cal, ncal — displays a calendar and the date of Easter

Syntax: cal The cal utility displays a simple calendar in traditional format and ncal offers an alternative layout, more options and the date of Easter. The new format is a little cramped but it makes a year fit on a 25×80 terminal. If arguments are not specified, the current month is displayed.

locate – find files by name

Syntax: locate file_name locate reads one or more databases prepared by updatedb(8) and writes file names matching at least one of the PATTERNs to standard output, one per line. passwd – change user password

Syntax: passwd The passwd command changes passwords for user accounts. A normal user may only change the password for his/her own account, while the superuser may change the password for any account. passwd also changes the account or associated password validity period. ln – make links between files

Syntax: ln existing_file_name file2_name create a link to TARGET with the name specified



This article is contributed by Mayank Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save



Improved By : manav014"
153,"Process

A process is an instance of a program in execution. A set of processes combined together make a complete program.

There are two categories of processes in Unix, namely

User processes : They are operated in user mode.

: They are operated in user mode. Kernel processes: They are operated in kernel mode.

Process States

The states that a Process enters in working from start till end are known as Process states. These are listed below as:

Created -Process is newly created by system call, is not ready to run

-Process is newly created by system call, is not ready to run User running -Process is running in user mode which means it is a user process.

-Process is running in user mode which means it is a user process. Kernel Running -Indicates process is a kernel process running in kernel mode.

-Indicates process is a kernel process running in kernel mode. Zombie- Process does not exist/ is terminated.

Process does not exist/ is terminated. Preempted- When process runs from kernel to user mode, it is said to be preempted.

When process runs from kernel to user mode, it is said to be preempted. Ready to run in memory- It indicated that process has reached a state where it is ready to run in memory and is waiting for kernel to schedule it.

It indicated that process has reached a state where it is ready to run in memory and is waiting for kernel to schedule it. Ready to run, swapped – Process is ready to run but no empty main memory is present

– Process is ready to run but no empty main memory is present Sleep, swapped- Process has been swapped to secondary storage and is at a blocked state.

Process has been swapped to secondary storage and is at a blocked state. Asleep in memory- Process is in memory(not swapped to secondary storage) but is in blocked state.

Process Transitions

The working of Process is explained in following steps:

User-running: Process is in user-running. Kernel-running: Process is allocated to kernel and hence, is in kernel mode. Ready to run in memory: Further, after processing in main memory process is rescheduled to the Kernel.i.e.The process is not executing but is ready to run as soon as the kernel schedules it. Asleep in memory: Process is sleeping but resides in main memory. It is waiting for the task to begin. Ready to run, swapped: Process is ready to run and be swapped by the processor into main memory, thereby allowing kernel to schedule it for execution. Sleep, Swapped: Process is in sleep state in secondary memory, making space for execution of other processes in main memory. It may resume once the task is fulfilled. Pre-empted: Kernel preempts an on-going process for allocation of another process, while the first process is moving from kernel to user mode. Created: Process is newly created but not running. This is the start state for all processes. Zombie: Process has been executed thoroughly and exit call has been enabled.

The process, thereby, no longer exists. But, it stores a statistical record for the process.

This is the final state of all processes.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready.

My Personal Notes arrow_drop_up Save"
154,"What is Shell

A shell is special user program which provide an interface to user to use operating system services. Shell accept human readable commands from user and convert them into something which kernel can understand. It is a command language interpreter that execute commands read from input devices such as keyboards or from files. The shell gets started when the user logs in or start the terminal.



Command Line Shell

Graphical shell

Command Line Shell

Shell can be accessed by user using a command line interface. A special program called Terminal in linux/macOS or Command Prompt in Windows OS is provided to type in the human readable commands such as “cat”, “ls” etc. and then it is being execute. The result is then displayed on the terminal to the user. A terminal in Ubuntu 16.4 system looks like this –



It will list all the files in current working directory in long listing format.

Working with command line shell is bit difficult for the beginners because it’s hard to memorize so many commands. It is very powerful, it allows user to store commands in a file and execute them together. This way any repetitive task can be easily automated. These files are usually called batch files in Windows and Shell Scripts in Linux/macOS systems.

Graphical Shells

Graphical shells provide means for manipulating programs based on graphical user interface (GUI), by allowing for operations such as opening, closing, moving and resizing windows, as well as switching focus between windows. Window OS or Ubuntu OS can be considered as good example which provide GUI to user for interacting with program. User do not need to type in command for every actions.A typical GUI in Ubuntu system –



There are several shells are available for Linux systems like –

BASH (Bourne Again SHell) – It is most widely used shell in Linux systems. It is used as default login shell in Linux systems and in macOS. It can also be installed on Windows OS.

CSH (C SHell) – The C shell’s syntax and usage are very similar to the C programming language.

KSH (Korn SHell) – The Korn Shell also was the base for the POSIX Shell standard specifications etc.

Each shell does the same job but understand different commands and provide different built in functions.

Shell Scripting

Usually shells are interactive that mean, they accept command as input from users and execute them. However some time we want to execute a bunch of commands routinely, so we have type in all commands each time in terminal.

As shell can also take commands as input from file we can write these commands in a file and can execute them in shell to avoid this repetitive work. These files are called Shell Scripts or Shell Programs. Shell scripts are similar to the batch file in MS-DOS. Each shell script is saved with .sh file extension eg. myscript.sh

A shell script have syntax just like any other programming language. If you have any prior experience with any programming language like Python, C/C++ etc. it would be very easy to get started with it.

A shell script comprises following elements –

Shell Keywords – if, else, break etc.

Shell commands – cd, ls, echo, pwd, touch etc.

Functions

Control flow – if..then..else, case and shell loops etc.

Why do we need shell scripts

There are many reasons to write shell scripts –

To avoid repetitive work and automation

System admins use shell scripting for routine backups

System monitoring

Adding new functionality to the shell etc.

Advantages of shell scripts

The command and syntax are exactly the same as those directly entered in command line, so programmer do not need to switch to entirely different syntax

Writing shell scripts are much quicker

Quick start

Interactive debugging etc.

Disadvantages of shell scripts

Prone to costly errors, a single mistake can change the command which might be harmful

Slow execution speed

Design flaws within the language syntax or implementation

Not well suited for large and complex task

Provide minimal data structure unlike other scripting languages. etc

Simple demo of shell scripting using Bash Shell

If you work on terminal, something you traverse deep down in directories. Then for coming few directories up in path we have to execute command like this as shown below to get to the “python” directory –



It is quite frustrating, so why not we can have a utility where we just have to type the name of directory and we can directly jump to that without executing “cd ../” command again and again. Save the script as “jump.sh”

filter_none edit

close play_arrow link

brightness_4

code function jump() { OLDIFS=$IFS IFS=/ path_arr=($PWD) IFS=$OLDIFS local pos=-1 for dir in ""${path_arr[@]}"" do pos=$[$pos+1] if [ ""$1"" = ""$dir"" ]; then dir_in_path=${ cwd=$PWD limit=$[$dir_in_path-$pos-1] for ((i=0; i<limit; i++)) do cwd=$cwd/.. done cd $cwd break fi done }

chevron_right filter_none

For now we cannot execute our shell script because it do not have permissions. We have to make it executable by typing following command –"
155,"The crontab is a list of commands that you want to run on a regular schedule, and also the name of the command used to manage that list. Crontab stands for “cron table, ” because it uses the job scheduler cron to execute tasks; cron itself is named after “chronos, ” the Greek word for time.cron is the system process which will automatically perform tasks for you according to a set schedule. The schedule is called the crontab, which is also the name of the program used to edit that schedule.

Linux Crontab Format

MIN HOUR DOM MON DOW CMD

Crontab Fields and Allowed Ranges (Linux Crontab Syntax)

Field Description Allowed Value MIN Minute field 0 to 59 HOUR Hour field 0 to 23 DOM Day of Month 1-31 MON Month field 1-12 DOW Day Of Week 0-6 CMD Command Any command to be executed.

Examples of Cron jobs

1. Scheduling a Job For a Specific Time

The basic usage of cron is to execute a job in a specific time as shown below. This will execute the Full backup shell script (full-backup) on 10th June 08:30 AM.

The time field uses 24 hours format. So, for 8 AM use 8, and for 8 PM use 20.

30 08 10 06 * /home/maverick/full-backup

30 – 30th Minute

08 – 08 AM

10 – 10th Day

06 – 6th Month (June)

* – Every day of the week

2.To view the Crontab entries

View Current Logged-In User’s Crontab entries : To view your crontab entries type crontab -l from your unix account.



View Root Crontab entries : Login as root user (su – root) and do crontab -l.

To view crontab entries of other Linux users : Login to root and use -u {username} -l.



3.To edit Crontab Entries

Edit Current Logged-In User’s Crontab entries.To edit a crontab entries, use crontab -e. By default this will edit the current logged-in users crontab.



4.To schedule a job for every minute using Cron.

Ideally you may not have a requirement to schedule a job every minute. But understanding this example will will help you understand the other examples.

* * * * * CMD

The * means all the possible unit — i.e every minute of every hour through out the year. More than using this * directly, you will find it very useful in the following cases.

When you specify */5 in minute field means every 5 minutes.

When you specify 0-10/2 in minute field mean every 2 minutes in the first 10 minute.

Thus the above convention can be used for all the other 4 fields.

5.To schedule a job for more than one time (e.g. Twice a Day)

The following script take a incremental backup twice a day every day.

This example executes the specified incremental backup shell script (incremental-backup) at 11:00 and 16:00 on every day. The comma separated value in a field specifies that the command needs to be executed in all the mentioned time.

00 11, 16 * * * /home/maverick/bin/incremental-backup

00 – 0th Minute (Top of the hour)

11, 16 – 11 AM and 4 PM

* – Every day

* – Every month

* – Every day of the week

6.To schedule a job for certain range of time (e.g. Only on Weekdays)

If you wanted a job to be scheduled for every hour with in a specific range of time then use the following.

Cron Job everyday during working hours :

This example checks the status of the database everyday (including weekends) during the working hours 9 a.m – 6 p.m 00 09-18 * * * /home/maverick/bin/check-db-status 00 – 0th Minute (Top of the hour)

09-18 – 9 am, 10 am, 11 am, 12 am, 1 pm, 2 pm, 3 pm, 4 pm, 5 pm, 6 pm

* – Every day

* – Every month

* – Every day of the week

This example checks the status of the database everyday (including weekends) during the working hours 9 a.m – 6 p.m Cron Job every weekday during working hours :

This example checks the status of the database every weekday (i.e excluding Sat and Sun) during the working hours 9 a.m – 6 p.m. 00 09-18 * * 1-5 /home/maverick/bin/check-db-status 00 – 0th Minute (Top of the hour)

09-18 – 9 am, 10 am, 11 am, 12 am, 1 pm, 2 pm, 3 pm, 4 pm, 5 pm, 6 pm

* – Every day

* – Every month

1-5 -Mon, Tue, Wed, Thu and Fri (Every Weekday)

7.To schedule a background Cron job for every 10 minutes.

Use the following, if you want to check the disk space every 10 minutes.

*/10 * * * * /home/maverick/check-disk-space

It executes the specified command check-disk-space every 10 minutes through out the year. But you may have a requirement of executing the command only during certain hours or vice versa. The above examples shows how to do those things.Instead of specifying values in the 5 fields, we can specify it using a single keyword as mentioned below.

There are special cases in which instead of the above 5 fields you can use @ followed by a keyword — such as reboot, midnight, yearly, hourly.

Cron special keywords and its meaning

Keyword Equivalent @yearly 0 0 1 1 * @daily 0 0 * * * @hourly 0 * * * * @reboot Run at startup.

8.To schedule a job for first minute of every year using @yearly

If you want a job to be executed on the first minute of every year, then you can use the @yearly cron keyword as shown below.This will execute the system annual maintenance using annual-maintenance shell script at 00:00 on Jan 1st for every year.

@yearly /home/maverick/bin/annual-maintenance

9.To schedule a Cron job beginning of every month using @monthly

It is as similar as the @yearly as above. But executes the command monthly once using @monthly cron keyword.This will execute the shell script tape-backup at 00:00 on 1st of every month.

@monthly /home/maverick/bin/tape-backup

10.To schedule a background job every day using @daily

Using the @daily cron keyword, this will do a daily log file cleanup using cleanup-logs shell script at 00:00 on every day.

@daily /home/maverick/bin/cleanup-logs ""day started""

11.To execute a linux command after every reboot using @reboot

Using the @reboot cron keyword, this will execute the specified command once after the machine got booted every time.

@reboot CMD

Reference : Linux man page for cron

This article is contributed by Kishlay Verma. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.

Attention reader! Don’t stop learning now. Get hold of all the important CS Theory concepts for SDE interviews with the CS Theory Course at a student-friendly price and become industry ready."
156,"How to limit search a specified directory in Linux?

There is a command in Linux to search for files in a directory hierarchy known as ‘find’. It searches the directory tree rooted at each given starting-point by evaluating the given expression from left to right, according to the rules of precedence, until the outcome is known (the left-hand side is false for and operations, true for or), at which point find moves on to the next file name. If no starting-point is specified, `.’ is assumed.

The find command by default travels down the entire directory tree recursively, which is time and resource consuming. However the depth of directory traversal can be specified(which are mindepth and maxdepth).

What are mindepth and maxdepth levels?

maxdepth levels : Descend at most levels (a non-negative integer) levels of directories below the starting-points. -maxdepth 0 means only apply the tests and actions to the starting-points themselves.

: Descend at most levels (a non-negative integer) levels of directories below the starting-points. -maxdepth 0 means only apply the tests and actions to the starting-points themselves. mindepth levels : Do not apply any tests or actions at levels less than levels (a non-negative integer). -mindepth 1 means process all files except the starting-points.

Given below some examples to illustrate how depth of the directory traversal can be specified using mindepth and maxdepth

Find the passwd file under all sub-directories starting from the root directory. find / -name passwd

Find the passwd file under root and one level down. (i.e root — level 1, and one sub-directory — level 2) find / -maxdepth 2 -name passwd

Find the passwd file under root and two levels down. (i.e root — level 1, and two sub-directories — level 2 and 3 ) find / -maxdepth 3 -name passwd

Find the password file between sub-directory level 2 and 4. find / -mindepth 3 -maxdepth 5 -name passwd

There are two other ways to limit search a directory in linux :"
157,"Corporate Trainer

Prof. Arnab Chakraborty is a Calcutta University alumnus with B.Sc. in Physics Hons Gold medalist, B. Tech and M. Tech in Computer Science and Engineering has twenty-six+ years of academic teaching experience in different universities, colleges and thirteen+ years of corporate training experiences for 170+ companies and trained 50,000+ professionals. He has also completed MBA from Vidyasagar University with dual specialization in Human Resource Management and Marketing Management. He is NLP and PMP trained, ""Global DMAIC Six Sigma Master Black Belt"" certified by IQF (USA). He is certified by ISA (USA) on ""Control and Automation System"". He is ""Global ITIL V3 Foundation"" certified as awarded by APMG (UK). Qualified for ""Accredited Management Teacher"" by AIMA (India). ""Star Python"" Global Certified from Star Certification (USA). ""Certified Scrum Master (CSM)"" Global Certification from Scrum Alliance (USA). He is also empaneled trainer for multiple corporates, e.g. HP, Accenture, IBM etc"
158,"Operating System Tutorial

An operating system (OS) is a collection of software that manages computer hardware resources and provides common services for computer programs. The operating system is a vital component of the system software in a computer system. This tutorial will take you through step by step approach while learning Operating System concepts.

Why to Learn Operating System?

An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc.

Following are some of important functions of an operating System.

Memory Management

Processor Management

Device Management

File Management

Security

Control over system performance

Job accounting

Error detecting aids

Coordination between other software and users

Applications of Operating System

Following are some of the important activities that an Operating System performs −

Security − By means of password and similar other techniques, it prevents unauthorized access to programs and data.

Control over system performance − Recording delays between request for a service and response from the system.

Job accounting − Keeping track of time and resources used by various jobs and users.

Error detecting aids − Production of dumps, traces, error messages, and other debugging and error detecting aids.

Coordination between other softwares and users − Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems.

Audience

This tutorial has been prepared for the computer science graduates to help them understand the basic to advanced concepts related to Operating System.

Prerequisites

Before you start proceeding with this tutorial, we are making an assumption that you are already aware of basic computer concepts like what is keyboard, mouse, monitor, input, output, primary memory and secondary memory etc. If you are not well aware of these concepts, then we will suggest to go through our short tutorial on Computer Fundamentals."
159,"Operating System - Overview

Advertisements

An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc.

Definition

An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs.

Following are some of important functions of an operating System.

Memory Management

Processor Management

Device Management

File Management

Security

Control over system performance

Job accounting

Error detecting aids

Coordination between other software and users

Memory Management

Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address.

Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management −

Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use.

In multiprogramming, the OS decides which process will get memory when and how much.

Allocates the memory when a process requests it to do so.

De-allocates the memory when a process no longer needs it or has been terminated.

Processor Management

In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called process scheduling. An Operating System does the following activities for processor management −

Keeps tracks of processor and status of process. The program responsible for this task is known as traffic controller .

Allocates the processor (CPU) to a process.

De-allocates processor when a process is no longer required.

Device Management

An Operating System manages device communication via their respective drivers. It does the following activities for device management −

Keeps tracks of all devices. Program responsible for this task is known as the I/O controller .

Decides which process gets the device when and for how much time.

Allocates the device in the efficient way.

De-allocates devices.

File Management

A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions.

An Operating System does the following activities for file management −

Keeps track of information, location, uses, status etc. The collective facilities are often known as file system .

Decides who gets the resources.

Allocates the resources.

De-allocates the resources.

Other Important Activities

Following are some of the important activities that an Operating System performs −

Security − By means of password and similar other techniques, it prevents unauthorized access to programs and data.

Control over system performance − Recording delays between request for a service and response from the system.

Job accounting − Keeping track of time and resources used by various jobs and users.

Error detecting aids − Production of dumps, traces, error messages, and other debugging and error detecting aids.

Coordination between other softwares and users − Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems."
160,"Types of Operating System

Advertisements

Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used.

Batch operating system

The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches.

The problems with Batch Systems are as follows −

Lack of interaction between the user and the job.

CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU.

Difficult to provide the desired priority.

Time-sharing operating systems

Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing.

The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time.

Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if n users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most.

The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems.

Advantages of Timesharing operating systems are as follows −

Provides the advantage of quick response.

Avoids duplication of software.

Reduces CPU idle time.

Disadvantages of Time-sharing operating systems are as follows −

Problem of reliability.

Question of security and integrity of user programs and data.

Problem of data communication.

Distributed operating System

Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.

The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on.

The advantages of distributed systems are as follows −

With resource sharing facility, a user at one site may be able to use the resources available at another.

Speedup the exchange of data with one another via electronic mail.

If one site fails in a distributed system, the remaining sites can potentially continue operating.

Better service to the customers.

Reduction of the load on the host computer.

Reduction of delays in data processing.

Network operating System

A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks.

Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD.

The advantages of network operating systems are as follows −

Centralized servers are highly stable.

Security is server managed.

Upgrades to new technologies and hardware can be easily integrated into the system.

Remote access to servers is possible from different locations and types of systems.

The disadvantages of network operating systems are as follows −

High cost of buying and running a server.

Dependency on a central location for most operations.

Regular maintenance and updates are required.

Real Time operating System

A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing.

Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.

There are two types of real-time operating systems.

Hard real-time systems

Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found.

Soft real-time systems

Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc."
161,"Operating System - Services

Advertisements

An Operating System provides services to both the users and to the programs.

It provides programs an environment to execute.

It provides users the services to execute the programs in a convenient manner.

Following are a few common services provided by an operating system −

Program execution

I/O operations

File System manipulation

Communication

Error Detection

Resource Allocation

Protection

Program execution

Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process.

A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management −

Loads a program into memory.

Executes the program.

Handles program's execution.

Provides a mechanism for process synchronization.

Provides a mechanism for process communication.

Provides a mechanism for deadlock handling.

I/O Operation

An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users.

An Operating System manages the communication between user and device drivers.

I/O operation means read or write operation with any file or any specific I/O device.

Operating system provides the access to the required I/O device when required.

File system manipulation

A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods.

A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management −

Program needs to read a file or write a file.

The operating system gives the permission to the program for operation on file.

Permission varies from read-only, read-write, denied and so on.

Operating System provides an interface to the user to create/delete files.

Operating System provides an interface to the user to create/delete directories.

Operating System provides an interface to create the backup of file system.

Communication

In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network.

The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication −

Two processes often require data to be transferred between them

Both the processes can be on one computer or on different computers, but are connected through a computer network.

Communication may be implemented by two methods, either by Shared Memory or by Message Passing.

Error handling

Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling −

The OS constantly checks for possible errors.

The OS takes an appropriate action to ensure correct and consistent computing.

Resource Management

In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management −

The OS manages all kinds of resources using schedulers.

CPU scheduling algorithms are used for better utilization of CPU.

Protection

Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities.

Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection −

The OS ensures that all access to system resources is controlled.

The OS ensures that external I/O devices are protected from invalid access attempts.

The OS provides authentication features for each user by means of passwords."
162,"Operating System - Properties

Advertisements

Batch processing

Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing −

The OS defines a job which has predefined sequence of commands, programs and data as a single unit.

The OS keeps a number a jobs in memory and executes them without any manual information.

Jobs are processed in the order of submission, i.e., first come first served fashion.

When a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing.

Advantages

Batch processing takes much of the work of the operator to the computer.

Increased performance as a new job get started as soon as the previous job is finished, without any manual intervention.

Disadvantages

Difficult to debug program.

A job could enter an infinite loop.

Due to lack of protection scheme, one batch job can affect pending jobs.

Multitasking

Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking −

The user gives instructions to the operating system or to a program directly, and receives an immediate response.

The OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time.

Multitasking Operating Systems are also known as Time-sharing systems.

These Operating Systems were developed to provide interactive use of a computer system at a reasonable cost.

A time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU.

Each user has at least one separate program in memory.

A program that is loaded into memory and is executing is commonly referred to as a process .

When a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O.

Since interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process.

The operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user.

As the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users.

Multiprogramming

Sharing the processor, when two or more programs reside in memory at the same time, is referred as multiprogramming. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute.

The following figure shows the memory layout for a multiprogramming system.

An OS does the following activities related to multiprogramming.

The operating system keeps several jobs in memory at a time.

This set of jobs is a subset of the jobs kept in the job pool.

The operating system picks and begins to execute one of the jobs in the memory.

Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.

Advantages

High and efficient CPU utilization.

User feels that many programs are allotted CPU almost simultaneously.

Disadvantages

CPU scheduling is required.

To accommodate many jobs in memory, memory management is required.

Interactivity

Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity −

Provides the user an interface to interact with the system.

Manages input devices to take inputs from the user. For example, keyboard.

Manages output devices to show outputs to the user. For example, Monitor.

The response time of the OS needs to be short, since the user submits and waits for the result.

Real Time System

Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity.

In such systems, Operating Systems typically read from and react to sensor data.

The Operating system must guarantee response to events within fixed periods of time to ensure correct performance.

Distributed Environment

A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment −

The OS distributes computation logics among several physical processors.

The processors do not share memory or a clock. Instead, each processor has its own local memory.

The OS manages the communications between the processors. They communicate with each other through various communication lines.

Spooling

Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices.

An operating system does the following activities related to distributed environment −

Handles I/O device data spooling as devices have different data access rates.

Maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up.

Maintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task.

Advantages

The spooling operation uses a disk as a very large buffer.

Spooling is capable of overlapping I/O operation for one job with processor operations for another job."
163,"Operating System - Processes

Advertisements

Process

A process is basically a program in execution. The execution of a process must progress in a sequential fashion.

A process is defined as an entity which represents the basic unit of work to be implemented in the system.

To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.

When a program is loaded into the memory and it becomes a process, it can be divided into four sections ─ stack, heap, text and data. The following image shows a simplified layout of a process inside main memory −

S.N. Component & Description 1 Stack The process Stack contains the temporary data such as method/function parameters, return address and local variables. 2 Heap This is dynamically allocated memory to a process during its run time. 3 Text This includes the current activity represented by the value of Program Counter and the contents of the processor's registers. 4 Data This section contains the global and static variables.

Program

A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language −

#include <stdio.h> int main() { printf(""Hello, World!

""); return 0; }

A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program.

A part of a computer program that performs a well-defined task is known as an algorithm. A collection of computer programs, libraries and related data are referred to as a software.

Process Life Cycle

When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized.

In general, a process can have one of the following five states at a time.

S.N. State & Description 1 Start This is the initial state when a process is first started/created. 2 Ready The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after Start state or while running it by but interrupted by the scheduler to assign CPU to some other process. 3 Running Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions. 4 Waiting Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available. 5 Terminated or Exit Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.

Process Control Block (PCB)

A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table −

S.N. Information & Description 1 Process State The current state of the process i.e., whether it is ready, running, waiting, or whatever. 2 Process privileges This is required to allow/disallow access to system resources. 3 Process ID Unique identification for each of the process in the operating system. 4 Pointer A pointer to parent process. 5 Program Counter Program Counter is a pointer to the address of the next instruction to be executed for this process. 6 CPU registers Various CPU registers where process need to be stored for execution for running state. 7 CPU Scheduling Information Process priority and other scheduling information which is required to schedule the process. 8 Memory management information This includes the information of page table, memory limits, Segment table depending on memory used by the operating system. 9 Accounting information This includes the amount of CPU used for process execution, time limits, execution ID etc. 10 IO status information This includes a list of I/O devices allocated to the process.

The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB −

The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates."
164,"Operating System - Process Scheduling

Advertisements

Definition

The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.

Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.

Process Scheduling Queues

The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue.

The Operating System maintains the following important process scheduling queues −

Job queue − This queue keeps all the processes in the system.

Ready queue − This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.

Device queues − The processes which are blocked due to unavailability of an I/O device constitute this queue.

The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU.

Two-State Process Model

Two-state process model refers to running and non-running states which are described below −

S.N. State & Description 1 Running When a new process is created, it enters into the system as in the running state. 2 Not Running Processes that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute.

Schedulers

Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types −

Long-Term Scheduler

Short-Term Scheduler

Medium-Term Scheduler

Long Term Scheduler

It is also called a job scheduler. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling.

The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system.

On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler.

Short Term Scheduler

It is also called as CPU scheduler. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them.

Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers.

Medium Term Scheduler

Medium-term scheduling is a part of swapping. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes.

A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called swapping, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix.

Comparison among Scheduler

S.N. Long-Term Scheduler Short-Term Scheduler Medium-Term Scheduler 1 It is a job scheduler It is a CPU scheduler It is a process swapping scheduler. 2 Speed is lesser than short term scheduler Speed is fastest among other two Speed is in between both short and long term scheduler. 3 It controls the degree of multiprogramming It provides lesser control over degree of multiprogramming It reduces the degree of multiprogramming. 4 It is almost absent or minimal in time sharing system It is also minimal in time sharing system It is a part of Time sharing systems. 5 It selects processes from pool and loads them into memory for execution It selects those processes which are ready to execute It can re-introduce the process into memory and execution can be continued.

Context Switch

A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.

When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing.

Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use.

Program Counter

Scheduling information

Base and limit register value

Currently used register

Changed State

I/O State information

Accounting information"
165,"Operating System Scheduling algorithms

Advertisements

A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter −

First-Come, First-Served (FCFS) Scheduling

Shortest-Job-Next (SJN) Scheduling

Priority Scheduling

Shortest Remaining Time

Round Robin(RR) Scheduling

Multiple-Level Queues Scheduling

These algorithms are either non-preemptive or preemptive. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.

First Come First Serve (FCFS)

Jobs are executed on first come, first serve basis.

It is a non-preemptive, pre-emptive scheduling algorithm.

Easy to understand and implement.

Its implementation is based on FIFO queue.

Poor in performance as average wait time is high.

Wait time of each process is as follows −

Process Wait Time : Service Time - Arrival Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 8 - 2 = 6 P3 16 - 3 = 13

Average Wait Time: (0+4+6+13) / 4 = 5.75

Shortest Job Next (SJN)

This is also known as shortest job first , or SJF

This is a non-preemptive, pre-emptive scheduling algorithm.

Best approach to minimize waiting time.

Easy to implement in Batch systems where required CPU time is known in advance.

Impossible to implement in interactive systems where required CPU time is not known.

The processer should know in advance how much time process will take.

Given: Table of processes, and their Arrival time, Execution time

Process Arrival Time Execution Time Service Time P0 0 5 0 P1 1 3 5 P2 2 8 14 P3 3 6 8

Waiting time of each process is as follows −

Process Waiting Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 14 - 2 = 12 P3 8 - 3 = 5

Average Wait Time: (0 + 4 + 12 + 5)/4 = 21 / 4 = 5.25

Priority Based Scheduling

Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems.

Each process is assigned a priority. Process with highest priority is to be executed first and so on.

Processes with same priority are executed on first come first served basis.

Priority can be decided based on memory requirements, time requirements or any other resource requirement.

Given: Table of processes, and their Arrival time, Execution time, and priority. Here we are considering 1 is the lowest priority.

Process Arrival Time Execution Time Priority Service Time P0 0 5 1 0 P1 1 3 2 11 P2 2 8 1 14 P3 3 6 3 5

Waiting time of each process is as follows −

Process Waiting Time P0 0 - 0 = 0 P1 11 - 1 = 10 P2 14 - 2 = 12 P3 5 - 3 = 2

Average Wait Time: (0 + 10 + 12 + 2)/4 = 24 / 4 = 6

Shortest Remaining Time

Shortest remaining time (SRT) is the preemptive version of the SJN algorithm.

The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.

Impossible to implement in interactive systems where required CPU time is not known.

It is often used in batch environments where short jobs need to give preference.

Round Robin Scheduling

Round Robin is the preemptive process scheduling algorithm.

Each process is provided a fix time to execute, it is called a quantum .

Once a process is executed for a given time period, it is preempted and other process executes for a given time period.

Context switching is used to save states of preempted processes.

Wait time of each process is as follows −

Process Wait Time : Service Time - Arrival Time P0 (0 - 0) + (12 - 3) = 9 P1 (3 - 1) = 2 P2 (6 - 2) + (14 - 9) + (20 - 17) = 12 P3 (9 - 3) + (17 - 12) = 11

Average Wait Time: (9+2+12+11) / 4 = 8.5

Multiple-Level Queues Scheduling

Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics.

Multiple queues are maintained for processes with common characteristics.

Each queue can have its own scheduling algorithms.

Priorities are assigned to each queue.

For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue."
166,"Operating System - Multi-Threading

Advertisements

What is Thread?

A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history.

A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that.

A thread is also called a lightweight process. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process.

Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process.

Difference between Process and Thread

S.N. Process Thread 1 Process is heavy weight or resource intensive. Thread is light weight, taking lesser resources than a process. 2 Process switching needs interaction with operating system. Thread switching does not need to interact with operating system. 3 In multiple processing environments, each process executes the same code but has its own memory and file resources. All threads can share same set of open files, child processes. 4 If one process is blocked, then no other process can execute until the first process is unblocked. While one thread is blocked and waiting, a second thread in the same task can run. 5 Multiple processes without using threads use more resources. Multiple threaded processes use fewer resources. 6 In multiple processes each process operates independently of the others. One thread can read, write or change another thread's data.

Advantages of Thread

Threads minimize the context switching time.

Use of threads provides concurrency within a process.

Efficient communication.

It is more economical to create and context switch threads.

Threads allow utilization of multiprocessor architectures to a greater scale and efficiency.

Types of Thread

Threads are implemented in following two ways −

User Level Threads − User managed threads.

Kernel Level Threads − Operating System managed threads acting on kernel, an operating system core.

User Level Threads

In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread.

Advantages

Thread switching does not require Kernel mode privileges.

User level thread can run on any operating system.

Scheduling can be application specific in the user level thread.

User level threads are fast to create and manage.

Disadvantages

In a typical operating system, most system calls are blocking.

Multithreaded application cannot take advantage of multiprocessing.

Kernel Level Threads

In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process.

The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads.

Advantages

Kernel can simultaneously schedule multiple threads from the same process on multiple processes.

If one thread in a process is blocked, the Kernel can schedule another thread of the same process.

Kernel routines themselves can be multithreaded.

Disadvantages

Kernel threads are generally slower to create and manage than the user threads.

Transfer of control from one thread to another within the same process requires a mode switch to the Kernel.

Multithreading Models

Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types

Many to many relationship.

Many to one relationship.

One to one relationship.

Many to Many Model

The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads.

The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution.

Many to One Model

Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors.

If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes.

One to One Model

There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors.

Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model.

Difference between User-Level & Kernel-Level Thread

S.N. User-Level Threads Kernel-Level Thread 1 User-level threads are faster to create and manage. Kernel-level threads are slower to create and manage. 2 Implementation is by a thread library at the user level. Operating system supports creation of Kernel threads. 3 User-level thread is generic and can run on any operating system. Kernel-level thread is specific to the operating system. 4 Multi-threaded applications cannot take advantage of multiprocessing. Kernel routines themselves can be multithreaded."
167,"Operating System - Memory Management

Advertisements

Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status.

This tutorial will teach you basic concepts related to Memory Management.

Process Address Space

The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.

The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated −

S.N. Memory Addresses & Description 1 Symbolic addresses The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space. 2 Relative addresses At the time of compilation, a compiler converts symbolic addresses into relative addresses. 3 Physical addresses The loader generates these addresses at the time when a program is loaded into main memory.

Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme.

The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these logical addresses is referred to as a physical address space.

The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address.

The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.

The user program deals with virtual addresses; it never sees the real physical addresses.

Static vs Dynamic Loading

The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses.

If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution.

At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.

If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.

Static vs Dynamic Linking

As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.

When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.

Swapping

Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory.

Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason Swapping is also known as a technique for memory compaction.

The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory.

Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take

2048KB / 1024KB per second = 2 seconds = 2000 milliseconds

Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory.

Memory Allocation

Main memory usually has two partitions −

Low Memory − Operating system resides in this memory.

High Memory − User processes are held in high memory.

Operating system uses the following memory allocation mechanism.

S.N. Memory Allocation & Description 1 Single-partition allocation In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register. 2 Multiple-partition allocation In this type of allocation, main memory is divided into a number of fixed-sized partitions where each partition should contain only one process. When a partition is free, a process is selected from the input queue and is loaded into the free partition. When the process terminates, the partition becomes available for another process.

Fragmentation

As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation.

Fragmentation is of two types −

S.N. Fragmentation & Description 1 External fragmentation Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used. 2 Internal fragmentation Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.

The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory −

External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic.

The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.

Paging

A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory.

Paging is a memory management technique in which process address space is broken into blocks of the same size called pages (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages.

Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called frames and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation.

Address Translation

Page address is called logical address and represented by page number and the offset.

Logical Address = Page number + page offset

Frame address is called physical address and represented by a frame number and the offset.

Physical Address = Frame number + page offset

A data structure called page map table is used to keep track of the relation between a page of a process to a frame in physical memory.

When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program.

When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.

This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program.

Advantages and Disadvantages of Paging

Here is a list of advantages and disadvantages of paging −

Paging reduces external fragmentation, but still suffer from internal fragmentation.

Paging is simple to implement and assumed as an efficient memory management technique.

Due to equal size of the pages and frames, swapping becomes very easy.

Page table requires extra memory space, so may not be good for a system having small RAM.

Segmentation

Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.

When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory.

Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size.

A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a segment map table for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset."
168,"Operating System - Virtual Memory

Advertisements

A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that's set up to emulate the computer's RAM.

The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address.

Following are the situations, when entire program is not required to be loaded fully in main memory.

User written error handling routines are used only when an error occurred in the data or computation.

Certain options and features of a program may be used rarely.

Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.

The ability to execute a program that is only partially in memory would counter many benefits.

Less number of I/O would be needed to load or swap each user program into memory.

A program would no longer be constrained by the amount of physical memory that is available.

Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.

Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below −

Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory.

Demand Paging

A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old program’s pages out to the disk or any of the new program’s pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that program’s pages as they are referenced.

While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system to demand the page back into the memory.

Advantages

Following are the advantages of Demand Paging −

Large virtual memory.

More efficient use of memory.

There is no limit on degree of multiprogramming.

Disadvantages

Number of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.

Page Replacement Algorithm

Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages.

When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm.

A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults,

Reference String

The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things.

For a given page size, we need to consider only the page number, not the entire address.

If we have a reference to a page p , then any immediately following references to page p will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.

For example, consider the following sequence of addresses − 123,215,600,1234,76,96

If page size is 100, then the reference string is 1,2,6,12,0,0

First In First Out (FIFO) algorithm

Oldest page in main memory is the one which will be selected for replacement.

Easy to implement, keep a list, replace pages from the tail and add new pages at the head.

Optimal Page algorithm

An optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN.

Replace the page that will not be used for the longest period of time. Use the time when a page is to be used.

Least Recently Used (LRU) algorithm

Page which has not been used for the longest time in main memory is the one which will be selected for replacement.

Easy to implement, keep a list, replace pages by looking back into time.

Page Buffering algorithm

To get a process start quickly, keep a pool of free frames.

On page fault, select a page to be replaced.

Write the new page in the frame of free pool, mark the page table and restart the process.

Now write the dirty page out of disk and place the frame holding replaced page in free pool.

Least frequently Used(LFU) algorithm

The page with the smallest count is the one which will be selected for replacement.

This algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again.

Most frequently Used(MFU) algorithm

This algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used."
169,"Operating System - I/O Hardware

Advertisements

One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc.

An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories −

Block devices − A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc.

Character devices − A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc

Device Controllers

Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices.

The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller.

There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary.

Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication.

Synchronous vs asynchronous I/O

Synchronous I/O − In this scheme CPU execution waits while I/O proceeds

Asynchronous I/O − I/O proceeds concurrently with CPU execution

Communication to I/O Devices

The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device.

Special Instruction I/O

Memory-mapped I/O

Direct memory access (DMA)

Special Instruction I/O

This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device.

Memory-mapped I/O

When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU.

While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished.

The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces.

Direct Memory Access (DMA)

Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead.

Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.

Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles.

The operating system uses the DMA hardware as follows −

Step Description 1 Device driver is instructed to transfer disk data to a buffer address X. 2 Device driver then instruct disk controller to transfer data to buffer. 3 Disk controller starts DMA transfer. 4 Disk controller sends each byte to DMA controller. 5 DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero. 6 When C becomes zero, DMA interrupts CPU to signal transfer completion.

Polling vs Interrupts I/O

A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as polling and interrupts. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running.

Polling I/O

Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information.

Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls.

Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance.

Interrupts I/O

An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention.

A device controller puts an interrupt signal on the bus when it needs CPU’s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted."
170,"Operating System - I/O Softwares

Advertisements

I/O software is often organized in the following layers −

User Level Libraries − This provides simple interface to the user program to perform input and output. For example, stdio is a library provided by C and C++ programming languages.

Kernel Level Modules − This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers.

Hardware − This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive.

A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device.

Device Drivers

Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM.

A device driver performs the following jobs −

To accept request from the device independent software above to it.

Interact with the device controller to take and give I/O and perform required error handling

Making sure that the request is executed successfully

How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests.

Interrupt handlers

An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt.

When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen.

The interrupt mechanism accepts an address ─ a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers.

Device-Independent I/O Software

The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software −

Uniform interfacing for device drivers

Device naming - Mnemonic names mapped to Major and Minor device numbers

Device protection

Providing a device-independent block size

Buffering because data coming off a device cannot be stored in final destination.

Storage allocation on block devices

Allocation and releasing dedicated devices

Error Reporting

User-Space I/O Software

These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system.

I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming.

Kernel I/O Subsystem

Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided.

Scheduling − Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications.

Buffering − Kernel I/O Subsystem maintains a memory area known as buffer that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes.

Caching − Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original.

Spooling and Device Reservation − A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread.

Error Handling − An operating system that uses protected memory can guard against many kinds of hardware and application errors."
171,"Operating System - File System

Advertisements

File

A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user.

File Structure

A File Structure should be according to a required format that the operating system can understand.

A file has a certain defined structure according to its type.

A text file is a sequence of characters organized into lines.

A source file is a sequence of procedures and functions.

An object file is a sequence of bytes organized into blocks that are understandable by the machine.

When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure.

File Type

File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files −

Ordinary files

These are the files that contain user information.

These may have text, databases or executable program.

The user can apply various operations on such files like add, modify, delete or even remove the entire file.

Directory files

These files contain list of file names and other information related to these files.

Special files

These files are also known as device files.

These files represent physical device like disks, terminals, printers, networks, tape drive etc.

These files are of two types −

Character special files − data is handled character by character as in case of terminals or printers.

Block special files − data is handled in blocks as in the case of disks and tapes.

File Access Mechanisms

File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files −

Sequential access

Direct/Random access

Indexed sequential access

Sequential access

A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion.

Direct/Random access

Random access file organization provides, accessing the records directly.

Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing.

The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.

Indexed sequential access

This mechanism is built up on base of sequential access.

An index is created for each file which contains pointers to various blocks.

Index is searched sequentially and its pointer is used to access the file directly.

Space Allocation

Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files.

Contiguous Allocation

Linked Allocation

Indexed Allocation

Contiguous Allocation

Each file occupies a contiguous address space on disk.

Assigned disk address is in linear order.

Easy to implement.

External fragmentation is a major issue with this type of allocation technique.

Linked Allocation

Each file carries a list of links to disk blocks.

Directory contains link / pointer to first block of a file.

No external fragmentation

Effectively used in sequential access file.

Inefficient in case of direct access file.

Indexed Allocation

Provides solutions to problems of contiguous and linked allocation.

A index block is created having all pointers to files.

Each file has its own index block which stores the addresses of disk space occupied by the file.

Directory contains the addresses of index blocks of files."
172,"Operating System - Security

Advertisements

Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter.

Authentication

One Time passwords

Program Threats

System Threats

Computer Security Classifications

Authentication

Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways −

Username / Password − User need to enter a registered username and password with Operating system to login into the system.

User card/key − User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system.

User attribute - fingerprint/ eye retina pattern/ signature − User need to pass his/her attribute via designated input device used by operating system to login into the system.

One Time passwords

One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways.

Random numbers − Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen.

Secret key − User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login.

Network password − Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login.

Program Threats

Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as Program Threats. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats.

Trojan Horse − Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources.

Trap Door − If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door.

Logic Bomb − Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect.

Virus − Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user

System Threats

System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats.

Worm − Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network.

Port Scanning − Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system.

Denial of Service − Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings.

Computer Security Classifications

As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification.

S.N. Classification Type & Description 1 Type A Highest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security. 2 Type B Provides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types. B1 − Maintains the security label of each object in the system. Label is used for making decisions to access control.

B2 − Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events.

B3 − Allows creating lists or user groups for access-control to grant access or revoke access to a given named object. 3 Type C Provides protection and user accountability using audit capabilities. It is of two types. C1 − Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class.

C2 − Adds an individual-level access control to the capabilities of a Cl level system. 4 Type D Lowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category."
173,"Operating System - Linux

Advertisements

Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX.

Components of Linux System

Linux Operating System has primarily three components

Kernel − Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.

System Library − System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights.

System Utility − System Utility programs are responsible to do specialized, individual level tasks.

Kernel Mode vs User Mode

Kernel component code executes in a special privileged mode called kernel mode with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes.

Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in User Mode which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks.

Basic Features

Following are some of the important features of Linux Operating System.

Portable − Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform.

Open Source − Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving.

Multi-User − Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time.

Multiprogramming − Linux is a multiprogramming system means multiple applications can run at same time.

Hierarchical File System − Linux provides a standard file structure in which system files/ user files are arranged.

Shell − Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc.

Security − Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data.

Architecture

The following illustration shows the architecture of a Linux system −

The architecture of a Linux System consists of the following layers −

Hardware layer − Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc).

Kernel − It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components.

Shell − An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions.

Utilities − Utility programs that provide the user most of the functionalities of an operating systems."
174,"OS Exams Questions with Answers

Advertisements

These selected questions and answers are prepared from Operating Systems Exam point of view and will also help in quick revision to get good marks in Operating Systems Examination. These questions has been prepared for the computer science graduates (B.C.A, M.C.A, B.Tech, B.E. and so...), to help them understand and revise the basic to advanced concepts related to Operating System.

Following is the selected list of questions and their answers and will help in quick revision to get good marks in Operating Systems Examination.

Operating Systems Overview

Operating Systems Process

Operating Systems Types

Operating Systems Process Scheduling

Operating Systems Memory Allocation

Operating Systems Semaphores"
175,"Operating System - Quick Guide

Advertisements

Operating System - Overview

An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc.

Definition

An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs.

Following are some of important functions of an operating System.

Memory Management

Processor Management

Device Management

File Management

Security

Control over system performance

Job accounting

Error detecting aids

Coordination between other software and users

Memory Management

Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address.

Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management −

Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use.

In multiprogramming, the OS decides which process will get memory when and how much.

Allocates the memory when a process requests it to do so.

De-allocates the memory when a process no longer needs it or has been terminated.

Processor Management

In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called process scheduling. An Operating System does the following activities for processor management −

Keeps tracks of processor and status of process. The program responsible for this task is known as traffic controller .

Allocates the processor (CPU) to a process.

De-allocates processor when a process is no longer required.

Device Management

An Operating System manages device communication via their respective drivers. It does the following activities for device management −

Keeps tracks of all devices. Program responsible for this task is known as the I/O controller .

Decides which process gets the device when and for how much time.

Allocates the device in the efficient way.

De-allocates devices.

File Management

A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions.

An Operating System does the following activities for file management −

Keeps track of information, location, uses, status etc. The collective facilities are often known as file system .

Decides who gets the resources.

Allocates the resources.

De-allocates the resources.

Other Important Activities

Following are some of the important activities that an Operating System performs −

Security − By means of password and similar other techniques, it prevents unauthorized access to programs and data.

Control over system performance − Recording delays between request for a service and response from the system.

Job accounting − Keeping track of time and resources used by various jobs and users.

Error detecting aids − Production of dumps, traces, error messages, and other debugging and error detecting aids.

Coordination between other softwares and users − Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems.

Types of Operating System

Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used.

Batch operating system

The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches.

The problems with Batch Systems are as follows −

Lack of interaction between the user and the job.

CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU.

Difficult to provide the desired priority.

Time-sharing operating systems

Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing.

The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time.

Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if n users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most.

The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems.

Advantages of Timesharing operating systems are as follows −

Provides the advantage of quick response.

Avoids duplication of software.

Reduces CPU idle time.

Disadvantages of Time-sharing operating systems are as follows −

Problem of reliability.

Question of security and integrity of user programs and data.

Problem of data communication.

Distributed operating System

Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.

The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on.

The advantages of distributed systems are as follows −

With resource sharing facility, a user at one site may be able to use the resources available at another.

Speedup the exchange of data with one another via electronic mail.

If one site fails in a distributed system, the remaining sites can potentially continue operating.

Better service to the customers.

Reduction of the load on the host computer.

Reduction of delays in data processing.

Network operating System

A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks.

Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD.

The advantages of network operating systems are as follows −

Centralized servers are highly stable.

Security is server managed.

Upgrades to new technologies and hardware can be easily integrated into the system.

Remote access to servers is possible from different locations and types of systems.

The disadvantages of network operating systems are as follows −

High cost of buying and running a server.

Dependency on a central location for most operations.

Regular maintenance and updates are required.

Real Time operating System

A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing.

Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.

There are two types of real-time operating systems.

Hard real-time systems

Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found.

Soft real-time systems

Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc.

Operating System - Services

An Operating System provides services to both the users and to the programs.

It provides programs an environment to execute.

It provides users the services to execute the programs in a convenient manner.

Following are a few common services provided by an operating system −

Program execution

I/O operations

File System manipulation

Communication

Error Detection

Resource Allocation

Protection

Program execution

Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process.

A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management −

Loads a program into memory.

Executes the program.

Handles program's execution.

Provides a mechanism for process synchronization.

Provides a mechanism for process communication.

Provides a mechanism for deadlock handling.

I/O Operation

An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users.

An Operating System manages the communication between user and device drivers.

I/O operation means read or write operation with any file or any specific I/O device.

Operating system provides the access to the required I/O device when required.

File system manipulation

A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods.

A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management −

Program needs to read a file or write a file.

The operating system gives the permission to the program for operation on file.

Permission varies from read-only, read-write, denied and so on.

Operating System provides an interface to the user to create/delete files.

Operating System provides an interface to the user to create/delete directories.

Operating System provides an interface to create the backup of file system.

Communication

In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network.

The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication −

Two processes often require data to be transferred between them

Both the processes can be on one computer or on different computers, but are connected through a computer network.

Communication may be implemented by two methods, either by Shared Memory or by Message Passing.

Error handling

Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling −

The OS constantly checks for possible errors.

The OS takes an appropriate action to ensure correct and consistent computing.

Resource Management

In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management −

The OS manages all kinds of resources using schedulers.

CPU scheduling algorithms are used for better utilization of CPU.

Protection

Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities.

Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection −

The OS ensures that all access to system resources is controlled.

The OS ensures that external I/O devices are protected from invalid access attempts.

The OS provides authentication features for each user by means of passwords.

Operating System - Properties

Batch processing

Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing −

The OS defines a job which has predefined sequence of commands, programs and data as a single unit.

The OS keeps a number a jobs in memory and executes them without any manual information.

Jobs are processed in the order of submission, i.e., first come first served fashion.

When a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing.

Advantages

Batch processing takes much of the work of the operator to the computer.

Increased performance as a new job get started as soon as the previous job is finished, without any manual intervention.

Disadvantages

Difficult to debug program.

A job could enter an infinite loop.

Due to lack of protection scheme, one batch job can affect pending jobs.

Multitasking

Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking −

The user gives instructions to the operating system or to a program directly, and receives an immediate response.

The OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time.

Multitasking Operating Systems are also known as Time-sharing systems.

These Operating Systems were developed to provide interactive use of a computer system at a reasonable cost.

A time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU.

Each user has at least one separate program in memory.

A program that is loaded into memory and is executing is commonly referred to as a process .

When a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O.

Since interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process.

The operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user.

As the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users.

Multiprogramming

Sharing the processor, when two or more programs reside in memory at the same time, is referred as multiprogramming. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute.

The following figure shows the memory layout for a multiprogramming system.

An OS does the following activities related to multiprogramming.

The operating system keeps several jobs in memory at a time.

This set of jobs is a subset of the jobs kept in the job pool.

The operating system picks and begins to execute one of the jobs in the memory.

Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process.

Advantages

High and efficient CPU utilization.

User feels that many programs are allotted CPU almost simultaneously.

Disadvantages

CPU scheduling is required.

To accommodate many jobs in memory, memory management is required.

Interactivity

Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity −

Provides the user an interface to interact with the system.

Manages input devices to take inputs from the user. For example, keyboard.

Manages output devices to show outputs to the user. For example, Monitor.

The response time of the OS needs to be short, since the user submits and waits for the result.

Real Time System

Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity.

In such systems, Operating Systems typically read from and react to sensor data.

The Operating system must guarantee response to events within fixed periods of time to ensure correct performance.

Distributed Environment

A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment −

The OS distributes computation logics among several physical processors.

The processors do not share memory or a clock. Instead, each processor has its own local memory.

The OS manages the communications between the processors. They communicate with each other through various communication lines.

Spooling

Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices.

An operating system does the following activities related to distributed environment −

Handles I/O device data spooling as devices have different data access rates.

Maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up.

Maintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task.

Advantages

The spooling operation uses a disk as a very large buffer.

Spooling is capable of overlapping I/O operation for one job with processor operations for another job.

Operating System - Processes

Process

A process is basically a program in execution. The execution of a process must progress in a sequential fashion.

A process is defined as an entity which represents the basic unit of work to be implemented in the system.

To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program.

When a program is loaded into the memory and it becomes a process, it can be divided into four sections ─ stack, heap, text and data. The following image shows a simplified layout of a process inside main memory −

S.N. Component & Description 1 Stack The process Stack contains the temporary data such as method/function parameters, return address and local variables. 2 Heap This is dynamically allocated memory to a process during its run time. 3 Text This includes the current activity represented by the value of Program Counter and the contents of the processor's registers. 4 Data This section contains the global and static variables.

Program

A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language −

#include <stdio.h> int main() { printf(""Hello, World!

""); return 0; }

A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program.

A part of a computer program that performs a well-defined task is known as an algorithm. A collection of computer programs, libraries and related data are referred to as a software.

Process Life Cycle

When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized.

In general, a process can have one of the following five states at a time.

S.N. State & Description 1 Start This is the initial state when a process is first started/created. 2 Ready The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after Start state or while running it by but interrupted by the scheduler to assign CPU to some other process. 3 Running Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions. 4 Waiting Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available. 5 Terminated or Exit Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.

Process Control Block (PCB)

A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table −

S.N. Information & Description 1 Process State The current state of the process i.e., whether it is ready, running, waiting, or whatever. 2 Process privileges This is required to allow/disallow access to system resources. 3 Process ID Unique identification for each of the process in the operating system. 4 Pointer A pointer to parent process. 5 Program Counter Program Counter is a pointer to the address of the next instruction to be executed for this process. 6 CPU registers Various CPU registers where process need to be stored for execution for running state. 7 CPU Scheduling Information Process priority and other scheduling information which is required to schedule the process. 8 Memory management information This includes the information of page table, memory limits, Segment table depending on memory used by the operating system. 9 Accounting information This includes the amount of CPU used for process execution, time limits, execution ID etc. 10 IO status information This includes a list of I/O devices allocated to the process.

The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB −

The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates.

Operating System - Process Scheduling

Definition

The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.

Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.

Process Scheduling Queues

The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue.

The Operating System maintains the following important process scheduling queues −

Job queue − This queue keeps all the processes in the system.

Ready queue − This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue.

Device queues − The processes which are blocked due to unavailability of an I/O device constitute this queue.

The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU.

Two-State Process Model

Two-state process model refers to running and non-running states which are described below −

S.N. State & Description 1 Running When a new process is created, it enters into the system as in the running state. 2 Not Running Processes that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute.

Schedulers

Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types −

Long-Term Scheduler

Short-Term Scheduler

Medium-Term Scheduler

Long Term Scheduler

It is also called a job scheduler. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling.

The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system.

On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler.

Short Term Scheduler

It is also called as CPU scheduler. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them.

Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers.

Medium Term Scheduler

Medium-term scheduling is a part of swapping. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes.

A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called swapping, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix.

Comparison among Scheduler

S.N. Long-Term Scheduler Short-Term Scheduler Medium-Term Scheduler 1 It is a job scheduler It is a CPU scheduler It is a process swapping scheduler. 2 Speed is lesser than short term scheduler Speed is fastest among other two Speed is in between both short and long term scheduler. 3 It controls the degree of multiprogramming It provides lesser control over degree of multiprogramming It reduces the degree of multiprogramming. 4 It is almost absent or minimal in time sharing system It is also minimal in time sharing system It is a part of Time sharing systems. 5 It selects processes from pool and loads them into memory for execution It selects those processes which are ready to execute It can re-introduce the process into memory and execution can be continued.

Context Switch

A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.

When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing.

Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use.

Program Counter

Scheduling information

Base and limit register value

Currently used register

Changed State

I/O State information

Accounting information

Operating System Scheduling algorithms

A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter −

First-Come, First-Served (FCFS) Scheduling

Shortest-Job-Next (SJN) Scheduling

Priority Scheduling

Shortest Remaining Time

Round Robin(RR) Scheduling

Multiple-Level Queues Scheduling

These algorithms are either non-preemptive or preemptive. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.

First Come First Serve (FCFS)

Jobs are executed on first come, first serve basis.

It is a non-preemptive, pre-emptive scheduling algorithm.

Easy to understand and implement.

Its implementation is based on FIFO queue.

Poor in performance as average wait time is high.

Wait time of each process is as follows −

Process Wait Time : Service Time - Arrival Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 8 - 2 = 6 P3 16 - 3 = 13

Average Wait Time: (0+4+6+13) / 4 = 5.75

Shortest Job Next (SJN)

This is also known as shortest job first , or SJF

This is a non-preemptive, pre-emptive scheduling algorithm.

Best approach to minimize waiting time.

Easy to implement in Batch systems where required CPU time is known in advance.

Impossible to implement in interactive systems where required CPU time is not known.

The processer should know in advance how much time process will take.

Given: Table of processes, and their Arrival time, Execution time

Process Arrival Time Execution Time Service Time P0 0 5 0 P1 1 3 5 P2 2 8 14 P3 3 6 8

Waiting time of each process is as follows −

Process Waiting Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 14 - 2 = 12 P3 8 - 3 = 5

Average Wait Time: (0 + 4 + 12 + 5)/4 = 21 / 4 = 5.25

Priority Based Scheduling

Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems.

Each process is assigned a priority. Process with highest priority is to be executed first and so on.

Processes with same priority are executed on first come first served basis.

Priority can be decided based on memory requirements, time requirements or any other resource requirement.

Given: Table of processes, and their Arrival time, Execution time, and priority. Here we are considering 1 is the lowest priority.

Process Arrival Time Execution Time Priority Service Time P0 0 5 1 0 P1 1 3 2 11 P2 2 8 1 14 P3 3 6 3 5

Waiting time of each process is as follows −

Process Waiting Time P0 0 - 0 = 0 P1 11 - 1 = 10 P2 14 - 2 = 12 P3 5 - 3 = 2

Average Wait Time: (0 + 10 + 12 + 2)/4 = 24 / 4 = 6

Shortest Remaining Time

Shortest remaining time (SRT) is the preemptive version of the SJN algorithm.

The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.

Impossible to implement in interactive systems where required CPU time is not known.

It is often used in batch environments where short jobs need to give preference.

Round Robin Scheduling

Round Robin is the preemptive process scheduling algorithm.

Each process is provided a fix time to execute, it is called a quantum .

Once a process is executed for a given time period, it is preempted and other process executes for a given time period.

Context switching is used to save states of preempted processes.

Wait time of each process is as follows −

Process Wait Time : Service Time - Arrival Time P0 (0 - 0) + (12 - 3) = 9 P1 (3 - 1) = 2 P2 (6 - 2) + (14 - 9) + (20 - 17) = 12 P3 (9 - 3) + (17 - 12) = 11

Average Wait Time: (9+2+12+11) / 4 = 8.5

Multiple-Level Queues Scheduling

Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics.

Multiple queues are maintained for processes with common characteristics.

Each queue can have its own scheduling algorithms.

Priorities are assigned to each queue.

For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue.

Operating System - Multi-Threading

What is Thread?

A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history.

A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that.

A thread is also called a lightweight process. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process.

Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process.

Difference between Process and Thread

S.N. Process Thread 1 Process is heavy weight or resource intensive. Thread is light weight, taking lesser resources than a process. 2 Process switching needs interaction with operating system. Thread switching does not need to interact with operating system. 3 In multiple processing environments, each process executes the same code but has its own memory and file resources. All threads can share same set of open files, child processes. 4 If one process is blocked, then no other process can execute until the first process is unblocked. While one thread is blocked and waiting, a second thread in the same task can run. 5 Multiple processes without using threads use more resources. Multiple threaded processes use fewer resources. 6 In multiple processes each process operates independently of the others. One thread can read, write or change another thread's data.

Advantages of Thread

Threads minimize the context switching time.

Use of threads provides concurrency within a process.

Efficient communication.

It is more economical to create and context switch threads.

Threads allow utilization of multiprocessor architectures to a greater scale and efficiency.

Types of Thread

Threads are implemented in following two ways −

User Level Threads − User managed threads.

Kernel Level Threads − Operating System managed threads acting on kernel, an operating system core.

User Level Threads

In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread.

Advantages

Thread switching does not require Kernel mode privileges.

User level thread can run on any operating system.

Scheduling can be application specific in the user level thread.

User level threads are fast to create and manage.

Disadvantages

In a typical operating system, most system calls are blocking.

Multithreaded application cannot take advantage of multiprocessing.

Kernel Level Threads

In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process.

The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads.

Advantages

Kernel can simultaneously schedule multiple threads from the same process on multiple processes.

If one thread in a process is blocked, the Kernel can schedule another thread of the same process.

Kernel routines themselves can be multithreaded.

Disadvantages

Kernel threads are generally slower to create and manage than the user threads.

Transfer of control from one thread to another within the same process requires a mode switch to the Kernel.

Multithreading Models

Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types

Many to many relationship.

Many to one relationship.

One to one relationship.

Many to Many Model

The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads.

The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution.

Many to One Model

Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors.

If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes.

One to One Model

There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors.

Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model.

Difference between User-Level & Kernel-Level Thread

S.N. User-Level Threads Kernel-Level Thread 1 User-level threads are faster to create and manage. Kernel-level threads are slower to create and manage. 2 Implementation is by a thread library at the user level. Operating system supports creation of Kernel threads. 3 User-level thread is generic and can run on any operating system. Kernel-level thread is specific to the operating system. 4 Multi-threaded applications cannot take advantage of multiprocessing. Kernel routines themselves can be multithreaded.

Operating System - Memory Management

Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status.

This tutorial will teach you basic concepts related to Memory Management.

Process Address Space

The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.

The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated −

S.N. Memory Addresses & Description 1 Symbolic addresses The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space. 2 Relative addresses At the time of compilation, a compiler converts symbolic addresses into relative addresses. 3 Physical addresses The loader generates these addresses at the time when a program is loaded into main memory.

Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme.

The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these logical addresses is referred to as a physical address space.

The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address.

The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.

The user program deals with virtual addresses; it never sees the real physical addresses.

Static vs Dynamic Loading

The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses.

If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution.

At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.

If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.

Static vs Dynamic Linking

As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.

When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.

Swapping

Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory.

Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason Swapping is also known as a technique for memory compaction.

The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory.

Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take

2048KB / 1024KB per second = 2 seconds = 2000 milliseconds

Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory.

Memory Allocation

Main memory usually has two partitions −

Low Memory − Operating system resides in this memory.

High Memory − User processes are held in high memory.

Operating system uses the following memory allocation mechanism.

S.N. Memory Allocation & Description 1 Single-partition allocation In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register. 2 Multiple-partition allocation In this type of allocation, main memory is divided into a number of fixed-sized partitions where each partition should contain only one process. When a partition is free, a process is selected from the input queue and is loaded into the free partition. When the process terminates, the partition becomes available for another process.

Fragmentation

As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation.

Fragmentation is of two types −

S.N. Fragmentation & Description 1 External fragmentation Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used. 2 Internal fragmentation Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.

The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory −

External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic.

The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.

Paging

A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory.

Paging is a memory management technique in which process address space is broken into blocks of the same size called pages (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages.

Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called frames and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation.

Address Translation

Page address is called logical address and represented by page number and the offset.

Logical Address = Page number + page offset

Frame address is called physical address and represented by a frame number and the offset.

Physical Address = Frame number + page offset

A data structure called page map table is used to keep track of the relation between a page of a process to a frame in physical memory.

When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program.

When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.

This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program.

Advantages and Disadvantages of Paging

Here is a list of advantages and disadvantages of paging −

Paging reduces external fragmentation, but still suffer from internal fragmentation.

Paging is simple to implement and assumed as an efficient memory management technique.

Due to equal size of the pages and frames, swapping becomes very easy.

Page table requires extra memory space, so may not be good for a system having small RAM.

Segmentation

Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.

When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory.

Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size.

A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a segment map table for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset.

Operating System - Virtual Memory

A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that's set up to emulate the computer's RAM.

The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address.

Following are the situations, when entire program is not required to be loaded fully in main memory.

User written error handling routines are used only when an error occurred in the data or computation.

Certain options and features of a program may be used rarely.

Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.

The ability to execute a program that is only partially in memory would counter many benefits.

Less number of I/O would be needed to load or swap each user program into memory.

A program would no longer be constrained by the amount of physical memory that is available.

Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.

Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below −

Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory.

Demand Paging

A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old program’s pages out to the disk or any of the new program’s pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that program’s pages as they are referenced.

While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system to demand the page back into the memory.

Advantages

Following are the advantages of Demand Paging −

Large virtual memory.

More efficient use of memory.

There is no limit on degree of multiprogramming.

Disadvantages

Number of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques.

Page Replacement Algorithm

Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages.

When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm.

A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults,

Reference String

The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things.

For a given page size, we need to consider only the page number, not the entire address.

If we have a reference to a page p , then any immediately following references to page p will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault.

For example, consider the following sequence of addresses − 123,215,600,1234,76,96

If page size is 100, then the reference string is 1,2,6,12,0,0

First In First Out (FIFO) algorithm

Oldest page in main memory is the one which will be selected for replacement.

Easy to implement, keep a list, replace pages from the tail and add new pages at the head.

Optimal Page algorithm

An optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN.

Replace the page that will not be used for the longest period of time. Use the time when a page is to be used.

Least Recently Used (LRU) algorithm

Page which has not been used for the longest time in main memory is the one which will be selected for replacement.

Easy to implement, keep a list, replace pages by looking back into time.

Page Buffering algorithm

To get a process start quickly, keep a pool of free frames.

On page fault, select a page to be replaced.

Write the new page in the frame of free pool, mark the page table and restart the process.

Now write the dirty page out of disk and place the frame holding replaced page in free pool.

Least frequently Used(LFU) algorithm

The page with the smallest count is the one which will be selected for replacement.

This algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again.

Most frequently Used(MFU) algorithm

This algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used.

Operating System - I/O Hardware

One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc.

An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories −

Block devices − A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc.

Character devices − A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc

Device Controllers

Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices.

The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller.

There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary.

Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication.

Synchronous vs asynchronous I/O

Synchronous I/O − In this scheme CPU execution waits while I/O proceeds

Asynchronous I/O − I/O proceeds concurrently with CPU execution

Communication to I/O Devices

The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device.

Special Instruction I/O

Memory-mapped I/O

Direct memory access (DMA)

Special Instruction I/O

This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device.

Memory-mapped I/O

When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU.

While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished.

The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces.

Direct Memory Access (DMA)

Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead.

Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.

Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles.

The operating system uses the DMA hardware as follows −

Step Description 1 Device driver is instructed to transfer disk data to a buffer address X. 2 Device driver then instruct disk controller to transfer data to buffer. 3 Disk controller starts DMA transfer. 4 Disk controller sends each byte to DMA controller. 5 DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero. 6 When C becomes zero, DMA interrupts CPU to signal transfer completion.

Polling vs Interrupts I/O

A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as polling and interrupts. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running.

Polling I/O

Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information.

Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls.

Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance.

Interrupts I/O

An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention.

A device controller puts an interrupt signal on the bus when it needs CPU’s attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted.

Operating System - I/O Softwares

I/O software is often organized in the following layers −

User Level Libraries − This provides simple interface to the user program to perform input and output. For example, stdio is a library provided by C and C++ programming languages.

Kernel Level Modules − This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers.

Hardware − This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive.

A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device.

Device Drivers

Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM.

A device driver performs the following jobs −

To accept request from the device independent software above to it.

Interact with the device controller to take and give I/O and perform required error handling

Making sure that the request is executed successfully

How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests.

Interrupt handlers

An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt.

When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen.

The interrupt mechanism accepts an address ─ a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers.

Device-Independent I/O Software

The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software −

Uniform interfacing for device drivers

Device naming - Mnemonic names mapped to Major and Minor device numbers

Device protection

Providing a device-independent block size

Buffering because data coming off a device cannot be stored in final destination.

Storage allocation on block devices

Allocation and releasing dedicated devices

Error Reporting

User-Space I/O Software

These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system.

I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming.

Kernel I/O Subsystem

Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided.

Scheduling − Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications.

Buffering − Kernel I/O Subsystem maintains a memory area known as buffer that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes.

Caching − Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original.

Spooling and Device Reservation − A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread.

Error Handling − An operating system that uses protected memory can guard against many kinds of hardware and application errors.

Operating System - File System

File

A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user.

File Structure

A File Structure should be according to a required format that the operating system can understand.

A file has a certain defined structure according to its type.

A text file is a sequence of characters organized into lines.

A source file is a sequence of procedures and functions.

An object file is a sequence of bytes organized into blocks that are understandable by the machine.

When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure.

File Type

File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files −

Ordinary files

These are the files that contain user information.

These may have text, databases or executable program.

The user can apply various operations on such files like add, modify, delete or even remove the entire file.

Directory files

These files contain list of file names and other information related to these files.

Special files

These files are also known as device files.

These files represent physical device like disks, terminals, printers, networks, tape drive etc.

These files are of two types −

Character special files − data is handled character by character as in case of terminals or printers.

Block special files − data is handled in blocks as in the case of disks and tapes.

File Access Mechanisms

File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files −

Sequential access

Direct/Random access

Indexed sequential access

Sequential access

A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion.

Direct/Random access

Random access file organization provides, accessing the records directly.

Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing.

The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.

Indexed sequential access

This mechanism is built up on base of sequential access.

An index is created for each file which contains pointers to various blocks.

Index is searched sequentially and its pointer is used to access the file directly.

Space Allocation

Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files.

Contiguous Allocation

Linked Allocation

Indexed Allocation

Contiguous Allocation

Each file occupies a contiguous address space on disk.

Assigned disk address is in linear order.

Easy to implement.

External fragmentation is a major issue with this type of allocation technique.

Linked Allocation

Each file carries a list of links to disk blocks.

Directory contains link / pointer to first block of a file.

No external fragmentation

Effectively used in sequential access file.

Inefficient in case of direct access file.

Indexed Allocation

Provides solutions to problems of contiguous and linked allocation.

A index block is created having all pointers to files.

Each file has its own index block which stores the addresses of disk space occupied by the file.

Directory contains the addresses of index blocks of files.

Operating System - Security

Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter.

Authentication

One Time passwords

Program Threats

System Threats

Computer Security Classifications

Authentication

Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways −

Username / Password − User need to enter a registered username and password with Operating system to login into the system.

User card/key − User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system.

User attribute - fingerprint/ eye retina pattern/ signature − User need to pass his/her attribute via designated input device used by operating system to login into the system.

One Time passwords

One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways.

Random numbers − Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen.

Secret key − User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login.

Network password − Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login.

Program Threats

Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as Program Threats. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats.

Trojan Horse − Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources.

Trap Door − If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door.

Logic Bomb − Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect.

Virus − Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user

System Threats

System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats.

Worm − Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network.

Port Scanning − Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system.

Denial of Service − Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings.

Computer Security Classifications

As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification.

S.N. Classification Type & Description 1 Type A Highest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security. 2 Type B Provides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types. B1 − Maintains the security label of each object in the system. Label is used for making decisions to access control.

B2 − Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events.

B3 − Allows creating lists or user groups for access-control to grant access or revoke access to a given named object. 3 Type C Provides protection and user accountability using audit capabilities. It is of two types. C1 − Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class.

C2 − Adds an individual-level access control to the capabilities of a Cl level system. 4 Type D Lowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category.

Operating System - Linux

Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX.

Components of Linux System

Linux Operating System has primarily three components

Kernel − Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.

System Library − System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights.

System Utility − System Utility programs are responsible to do specialized, individual level tasks.

Kernel Mode vs User Mode

Kernel component code executes in a special privileged mode called kernel mode with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes.

Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in User Mode which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks.

Basic Features

Following are some of the important features of Linux Operating System.

Portable − Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform.

Open Source − Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving.

Multi-User − Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time.

Multiprogramming − Linux is a multiprogramming system means multiple applications can run at same time.

Hierarchical File System − Linux provides a standard file structure in which system files/ user files are arranged.

Shell − Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc.

Security − Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data.

Architecture

The following illustration shows the architecture of a Linux system −

The architecture of a Linux System consists of the following layers −

Hardware layer − Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc).

Kernel − It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components.

Shell − An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions.

Utilities − Utility programs that provide the user most of the functionalities of an operating systems."
176,"Operating System - Useful Resources

Advertisements

The following resources contain additional information on Operating System Please use them to get more in-depth knowledge on this topic.

Useful Links on Operating System

Operating system − A wikipage giving a short description about operating system.

What is an Operating System − An operating system is the most important software that runs on a computer.

Computer Basics by BBC − An introduction to computers including computer parts and health and safety.

Basic Computer Literacy Information − A quick go through Basic Computer Literacy Information.

Useful Books on Operating System

To enlist your site on this page, please drop an email to contact@tutorialspoint.com"
177,"Discuss Operating System

Advertisements

An operating system (OS) is a collection of software that manages computer hardware resources and provides common services for computer programs. The operating system is a vital component of the system software in a computer system. This tutorial will take you through step by step approach while learning Operating System concepts."
178,"Operating System Tutorial

Operating System Tutorial provides the basic and advanced concepts of operating system . Our Operating system tutorial is designed for beginners, professionals and GATE aspirants. We have designed this tutorial after the completion of a deep research about every concept.

The content is described in detailed manner and has the ability to answer most of your queries. The tutorial also contains the numerical examples based on previous year GATE questions which will help you to address the problems in a practical manner.

Operating System can be defined as an interface between user and the hardware. It provides an environment to the user so that, the user can perform its task in convenient and efficient way.

The Operating System Tutorial is divided into various parts based on its functions such as Process Management, Process Synchronization, Deadlocks and File Management.

Operating System Definition and Function

In the Computer System (comprises of Hardware and software), Hardware can only understand machine code (in the form of 0 and 1) which doesn't make any sense to a naive user.

We need a system which can act as an intermediary and manage all the processes and resources present in the system.

An Operating System can be defined as an interface between user and hardware. It is responsible for the execution of all the processes, Resource Allocation, CPU management, File Management and many other tasks.

The purpose of an operating system is to provide an environment in which a user can execute programs in convenient and efficient manner.

Structure of a Computer System

A Computer System consists of:

Users (people who are using the computer)

Application Programs (Compilers, Databases, Games, Video player, Browsers, etc.)

System Programs (Shells, Editors, Compilers, etc.)

Operating System ( A special program which acts as an interface between user and hardware )

Hardware ( CPU, Disks, Memory, etc)

What does an Operating system do?

Process Management Process Synchronization Memory Management CPU Scheduling File Management Security

Operating System Index

Prerequisites

Before learning the operating system tutorial, you must have the basic knowledge about the way in which a computer system operates.

Audience

Our operating system tutorial is designed to help beginners, professionals and GATE aspirants.

Problem

We can assure you that you will not find any problem in this operating system tutorial. However, if you find any, you can post the problem in the contact form."
179,"next → ← prev Types of OS There are many types of operating system exists in the current scenario: Batch Operating System In the era of 1970s, the Batch processing was very popular. The Jobs were executed in batches. People were used to have a single computer which was called mainframe. In Batch operating system, access is given to more than one person; they submit their respective jobs to the system for the execution. The system put all of the jobs in a queue on the basis of first come first serve and then executes the jobs one by one. The users collect their respective output when all the jobs get executed. Disadvantages of Batch OS 1. Starvation Batch processing suffers from starvation. If there are five jobs J1, J2, J3, J4, J4 and J5 present in the batch. If the execution time of J1 is very high then other four jobs will never be going to get executed or they will have to wait for a very high time. Hence the other processes get starved. 2. Not Interactive Batch Processing is not suitable for the jobs which are dependent on the user's input. If a job requires the input of two numbers from the console then it will never be going to get it in the batch processing scenario since the user is not present at the time of execution. Multiprogramming Operating System Multiprogramming is an extension to the batch processing where the CPU is kept always busy. Each process needs two types of system time: CPU time and IO time. In multiprogramming environment, for the time a process does its I/O, The CPU can start the execution of other processes. Therefore, multiprogramming improves the efficiency of the system. Multiprocessing Operating System In Multiprocessing, Parallel computing is achieved. There are more than one processors present in the system which can execute more than one process at the same time. This will increase the throughput of the system. Real Time Operating System In Real Time systems, each job carries a certain deadline within which the Job is supposed to be completed, otherwise the huge loss will be there or even if the result is produced then it will be completely useless. The Application of a Real Time system exists in the case of military applications, if you want to drop a missile then the missile is supposed to be dropped with certain precision.

Next Topic Process Management Introduction



← prev next →



"
180,"Process Management Introduction

A Program does nothing unless its instructions are executed by a CPU. A program in execution is called a process. In order to accomplish its task, process needs the computer resources.

There may exist more than one process in the system which may require the same resource at the same time. Therefore, the operating system has to manage all the processes and the resources in a convenient and efficient way.

Some resources may need to be executed by one process at one time to maintain the consistency otherwise the system can become inconsistent and deadlock may occur.

The operating system is responsible for the following activities in connection with Process Management

Scheduling processes and threads on the CPUs. Creating and deleting both user and system processes. Suspending and resuming processes. Providing mechanisms for process synchronization. Providing mechanisms for process communication."
181,"next → ← prev Attributes of a process The Attributes of the process are used by the Operating System to create the process control block (PCB) for each of them. This is also called context of the process. Attributes which are stored in the PCB are described below. 1. Process ID When a process is created, a unique id is assigned to the process which is used for unique identification of the process in the system. 2. Program counter A program counter stores the address of the last instruction of the process on which the process was suspended. The CPU uses this address when the execution of this process is resumed. 3. Process State The Process, from its creation to the completion, goes through various states which are new, ready, running and waiting. We will discuss about them later in detail. 4. Priority Every process has its own priority. The process with the highest priority among the processes gets the CPU first. This is also stored on the process control block. 5. General Purpose Registers Every process has its own set of registers which are used to hold the data which is generated during the execution of the process. 6. List of open files During the Execution, Every process uses some files which need to be present in the main memory. OS also maintains a list of open files in the PCB. 7. List of open devices OS also maintain the list of all open devices which are used during the execution of the process.



Next Topic Process States



← prev next →



"
182,"next → ← prev Process States State Diagram



The process, from its creation to completion, passes through various states. The minimum number of states is five. The names of the states are not standardized although the process may be in one of the following states during execution. 1. New A program which is going to be picked up by the OS into the main memory is called a new process. 2. Ready Whenever a process is created, it directly enters in the ready state, in which, it waits for the CPU to be assigned. The OS picks the new processes from the secondary memory and put all of them in the main memory. The processes which are ready for the execution and reside in the main memory are called ready state processes. There can be many processes present in the ready state. 3. Running One of the processes from the ready state will be chosen by the OS depending upon the scheduling algorithm. Hence, if we have only one CPU in our system, the number of running processes for a particular time will always be one. If we have n processors in the system then we can have n processes running simultaneously. 4. Block or wait From the Running state, a process can make the transition to the block or wait state depending upon the scheduling algorithm or the intrinsic behavior of the process. When a process waits for a certain resource to be assigned or for the input from the user then the OS move this process to the block or wait state and assigns the CPU to the other processes. 5. Completion or termination When a process finishes its execution, it comes in the termination state. All the context of the process (Process Control Block) will also be deleted the process will be terminated by the Operating system. 6. Suspend ready A process in the ready state, which is moved to secondary memory from the main memory due to lack of the resources (mainly primary memory) is called in the suspend ready state. If the main memory is full and a higher priority process comes for the execution then the OS have to make the room for the process in the main memory by throwing the lower priority process out into the secondary memory. The suspend ready processes remain in the secondary memory until the main memory gets available. 7. Suspend wait Instead of removing the process from the ready queue, it's better to remove the blocked process which is waiting for some resources in the main memory. Since it is already waiting for some resource to get available hence it is better if it waits in the secondary memory and make room for the higher priority process. These processes complete their execution once the main memory gets available and their wait is finished.

Operations on the Process 1. Creation Once the process is created, it will be ready and come into the ready queue (main memory) and will be ready for the execution. 2. Scheduling Out of the many processes present in the ready queue, the Operating system chooses one process and start executing it. Selecting the process which is to be executed next, is known as scheduling. 3. Execution Once the process is scheduled for the execution, the processor starts executing it. Process may come to the blocked or wait state during the execution then in that case the processor starts executing the other processes. 4. Deletion/killing Once the purpose of the process gets over then the OS will kill the process. The Context of the process (PCB) will be deleted and the process gets terminated by the Operating system.

Next Topic Process Schedulers



← prev next →



"
183,"next → ← prev Process Schedulers Operating system uses various schedulers for the process scheduling described below. 1. Long term scheduler Long term scheduler is also known as job scheduler. It chooses the processes from the pool (secondary memory) and keeps them in the ready queue maintained in the primary memory. Long Term scheduler mainly controls the degree of Multiprogramming. The purpose of long term scheduler is to choose a perfect mix of IO bound and CPU bound processes among the jobs present in the pool. If the job scheduler chooses more IO bound processes then all of the jobs may reside in the blocked state all the time and the CPU will remain idle most of the time. This will reduce the degree of Multiprogramming. Therefore, the Job of long term scheduler is very critical and may affect the system for a very long time. 2. Short term scheduler Short term scheduler is also known as CPU scheduler. It selects one of the Jobs from the ready queue and dispatch to the CPU for the execution. A scheduling algorithm is used to select which job is going to be dispatched for the execution. The Job of the short term scheduler can be very critical in the sense that if it selects job whose CPU burst time is very high then all the jobs after that, will have to wait in the ready queue for a very long time. This problem is called starvation which may arise if the short term scheduler makes some mistakes while selecting the job. 3. Medium term scheduler Medium term scheduler takes care of the swapped out processes.If the running state processes needs some IO time for the completion then there is a need to change its state from running to waiting. Medium term scheduler is used for this purpose. It removes the process from the running state to make room for the other processes. Such processes are the swapped out processes and this procedure is called swapping. The medium term scheduler is responsible for suspending and resuming the processes. It reduces the degree of multiprogramming. The swapping is necessary to have a perfect mix of processes in the ready queue.

Next Topic Process Queues



← prev next →



"
184,"next → ← prev Process Queues The Operating system manages various types of queues for each of the process states. The PCB related to the process is also stored in the queue of the same state. If the Process is moved from one state to another state then its PCB is also unlinked from the corresponding queue and added to the other state queue in which the transition is made.



There are the following queues maintained by the Operating system. 1. Job Queue In starting, all the processes get stored in the job queue. It is maintained in the secondary memory. The long term scheduler (Job scheduler) picks some of the jobs and put them in the primary memory. 2. Ready Queue Ready queue is maintained in primary memory. The short term scheduler picks the job from the ready queue and dispatch to the CPU for the execution. 3. Waiting Queue When the process needs some IO operation in order to complete its execution, OS changes the state of the process from running to waiting. The context (PCB) associated with the process gets stored on the waiting queue which will be used by the Processor when the process finishes the IO.

Next Topic various time related to process



← prev next →



"
185,"Various Times related to the Process

1. Arrival Time

The time at which the process enters into the ready queue is called the arrival time.

2. Burst Time

The total amount of time required by the CPU to execute the whole process is called the Burst Time. This does not include the waiting time. It is confusing to calculate the execution time for a process even before executing it hence the scheduling problems based on the burst time cannot be implemented in reality.

3. Completion Time

The Time at which the process enters into the completion state or the time at which the process completes its execution, is called completion time.

4. Turnaround time

The total amount of time spent by the process from its arrival to its completion, is called Turnaround time.

5. Waiting Time

The Total amount of time for which the process waits for the CPU to be assigned is called waiting time.

6. Response Time

The difference between the arrival time and the time at which the process first gets the CPU is called Response Time."
186,"next → ← prev CPU Scheduling In the uniprogrammming systems like MS DOS, when a process waits for any I/O operation to be done, the CPU remains idol. This is an overhead since it wastes the time and causes the problem of starvation. However, In Multiprogramming systems, the CPU doesn't remain idle during the waiting time of the Process and it starts executing other processes. Operating System has to define which process the CPU will be given. In Multiprogramming systems, the Operating system schedules the processes on the CPU to have the maximum utilization of it and this procedure is called CPU scheduling. The Operating System uses various scheduling algorithm to schedule the processes. This is a task of the short term scheduler to schedule the CPU for the number of processes present in the Job Pool. Whenever the running process requests some IO operation then the short term scheduler saves the current context of the process (also called PCB) and changes its state from running to waiting. During the time, process is in waiting state; the Short term scheduler picks another process from the ready queue and assigns the CPU to this process. This procedure is called context switching. What is saved in the Process Control Block? The Operating system maintains a process control block during the lifetime of the process. The Process control block is deleted when the process is terminated or killed. There is the following information which is saved in the process control block and is changing with the state of the process.

Why do we need Scheduling? In Multiprogramming, if the long term scheduler picks more I/O bound processes then most of the time, the CPU remains idol. The task of Operating system is to optimize the utilization of resources. If most of the running processes change their state from running to waiting then there may always be a possibility of deadlock in the system. Hence to reduce this overhead, the OS needs to schedule the jobs to get the optimal utilization of CPU and to avoid the possibility to deadlock.

Next Topic Scheduling Algorithms



← prev next →



"
187,"next → ← prev Scheduling Algorithms There are various algorithms which are used by the Operating System to schedule the processes on the processor in an efficient way. The Purpose of a Scheduling algorithm Maximum CPU utilization Fare allocation of CPU Maximum throughput Minimum turnaround time Minimum waiting time Minimum response time There are the following algorithms which can be used to schedule the jobs. 1. First Come First Serve It is the simplest algorithm to implement. The process with the minimal arrival time will get the CPU first. The lesser the arrival time, the sooner will the process gets the CPU. It is the non-preemptive type of scheduling. 2. Round Robin In the Round Robin scheduling algorithm, the OS defines a time quantum (slice). All the processes will get executed in the cyclic way. Each of the process will get the CPU for a small amount of time (called time quantum) and then get back to the ready queue to wait for its next turn. It is a preemptive type of scheduling. 3. Shortest Job First The job with the shortest burst time will get the CPU first. The lesser the burst time, the sooner will the process get the CPU. It is the non-preemptive type of scheduling. 4. Shortest remaining time first It is the preemptive form of SJF. In this algorithm, the OS schedules the Job according to the remaining time of the execution. 5. Priority based scheduling In this algorithm, the priority will be assigned to each of the processes. The higher the priority, the sooner will the process get the CPU. If the priority of the two processes is same then they will be scheduled according to their arrival time. 6. Highest Response Ratio Next In this scheduling Algorithm, the process with highest response ratio will be scheduled next. This reduces the starvation in the system.

Next Topic FCFS Scheduling



← prev next →



"
188,"next → ← prev FCFS Scheduling First come first serve (FCFS) scheduling algorithm simply schedules the jobs according to their arrival time. The job which comes first in the ready queue will get the CPU first. The lesser the arrival time of the job, the sooner will the job get the CPU. FCFS scheduling may cause the problem of starvation if the burst time of the first process is the longest among all the jobs. Advantages of FCFS Simple

Easy

First come, First serv Disadvantages of FCFS The scheduling method is non preemptive, the process will run to the completion. Due to the non-preemptive nature of the algorithm, the problem of starvation may occur. Although it is easy to implement, but it is poor in performance since the average waiting time is higher as compare to other scheduling algorithms. Example Let's take an example of The FCFS scheduling algorithm. In the Following schedule, there are 5 processes with process ID P0, P1, P2, P3 and P4. P0 arrives at time 0, P1 at time 1, P2 at time 2, P3 arrives at time 3 and Process P4 arrives at time 4 in the ready queue. The processes and their respective Arrival and Burst time are given in the following table. The Turnaround time and the waiting time are calculated by using the following formula. Turn Around Time = Completion Time - Arrival Time Waiting Time = Turnaround time - Burst Time The average waiting Time is determined by summing the respective waiting time of all the processes and divided the sum by the total number of processes. Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 0 0 2 2 2 0 1 1 6 8 7 1 2 2 4 12 8 4 3 3 9 21 18 9 4 4 12 33 29 17 Avg Waiting Time=31/5 (Gantt chart)

Next Topic Convoy Effect in FCFS



← prev next →



"
189,"next → ← prev Convoy Effect in FCFS FCFS may suffer from the convoy effect if the burst time of the first job is the highest among all. As in the real life, if a convoy is passing through the road then the other persons may get blocked until it passes completely. This can be simulated in the Operating System also. If the CPU gets the processes of the higher burst time at the front end of the ready queue then the processes of lower burst time may get blocked which means they may never get the CPU if the job in the execution has a very high burst time. This is called convoy effect or starvation.



Example In the Example, We have 3 processes named as P1, P2 and P3. The Burt Time of process P1 is highest. The Turnaround time and the waiting time in the following table, are calculated by the formula, Turn Around Time = Completion Time - Arrival Time Waiting Time = Turn Around Time - Burst Time In the First scenario, The Process P1 arrives at the first in the queue although; the burst time of the process is the highest among all. Since, the Scheduling algorithm, we are following is FCFS hence the CPU will execute the Process P1 first. In this schedule, the average waiting time of the system will be very high. That is because of the convoy effect. The other processes P2, P3 have to wait for their turn for 40 units of time although their burst time is very low. This schedule suffers from starvation. Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 1 0 40 40 40 0 2 1 3 43 42 39 3 1 1 44 43 42 Avg waiting Time = 81/3 In the Second scenario, If Process P1 would have arrived at the last of the queue and the other processes P2 and P3 at earlier then the problem of starvation would not be there. Following example shows the deviation in the waiting times of both the scenarios. Although the length of the schedule is same that is 44 units but the waiting time will be lesser in this schedule. Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 1 1 40 44 43 3 2 0 3 3 3 0 3 0 1 4 4 3 Avg Waiting Time=6/3

Next Topic FCFS with overhead



← prev next →



"
190,"FCFS with Overhead

In the above Examples, we are assuming that all the processes are the CPU bound processes only. We were also neglecting the context switching time.

However if the time taken by the scheduler in context switching is considered then the average waiting time of the system will be increased which also affects the efficiency of the system.

Context Switching is always an overhead. The Following Example describeshow the efficiency will be affected if the context switching time is considered in the system.

Example

In the following Example, we are considering five processes P1, P2, P3, P4, P5 and P6. Their arrival time and Burst time are given below.

Process ID Arrival Time Burst Time 1 0 3 2 1 2 3 2 1 4 3 4 5 4 5 6 5 2

If the context switching time of the system is 1 unit then the Gantt chart of the system will be prepared as follows.

Given δ=1 unit;

The system will take extra 1 unit of time (overhead) after the execution of every process to schedule the next process.

Inefficiency= (6/23) X 100 % Efficiencyͷ = (1-6/23) X 100 %"
191,"next → ← prev Shortest Job First (SJF) Scheduling Till now, we were scheduling the processes according to their arrival time (in FCFS scheduling). However, SJF scheduling algorithm, schedules the processes according to their burst time. In SJF scheduling, the process with the lowest burst time, among the list of available processes in the ready queue, is going to be scheduled next. However, it is very difficult to predict the burst time needed for a process hence this algorithm is very difficult to implement in the system. Advantages of SJF Maximum throughput Minimum average waiting and turnaround time Disadvantages of SJF May suffer with the problem of starvation It is not implementable because the exact Burst time for a process can't be known in advance. There are different techniques available by which, the CPU burst time of the process can be determined. We will discuss them later in detail. Example In the following example, there are five jobs named as P1, P2, P3, P4 and P5. Their arrival time and burst time are given in the table below. PID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 1 1 7 8 7 0 2 3 3 13 10 7 3 6 2 10 4 2 4 7 10 31 24 14 5 9 8 21 12 4 Since, No Process arrives at time 0 hence; there will be an empty slot in the Gantt chart from time 0 to 1 (the time at which the first process arrives). According to the algorithm, the OS schedules the process which is having the lowest burst time among the available processes in the ready queue. Till now, we have only one process in the ready queue hence the scheduler will schedule this to the processor no matter what is its burst time. This will be executed till 8 units of time. Till then we have three more processes arrived in the ready queue hence the scheduler will choose the process with the lowest burst time. Among the processes given in the table, P3 will be executed next since it is having the lowest burst time among all the available processes. So that's how the procedure will go on in shortest job first (SJF) scheduling algorithm. Avg Waiting Time = 27/5

Next Topic Prediction of CPU Burst Time for a process in SJF



← prev next →



"
192,"next → ← prev Prediction of CPU Burst Time for a process in SJF The SJF algorithm is one of the best scheduling algorithms since it provides the maximum throughput and minimal waiting time but the problem with the algorithm is, the CPU burst time can't be known in advance. We can approximate the CPU burst time for a process. There are various techniques which can be used to assume the CPU Burst time for a process. Our Assumption needs to be accurate in order to utilize the algorithm optimally. There are the following techniques used for the assumption of CPU burst time for a process. 1. Static Techniques

Process Size We can predict the Burst Time of the process from its size. If we have two processes T_OLD and T_New and the actual burst time of the old process is known as 20 secs and the size of the process is 20 KB. We know that the size of P_NEW is 21 KB. Then the probability of P_New having the similar burst time as 20 secs is maximum. If, P_OLD → 20 KB P_New → 21 KB BT(P_OLD) → 20 Secs Then, BT(P_New) → 20 secs Hence, in this technique, we actually predict the burst time of a new process according to the burst time of an old process of similar size as of new process. Process Type We can also predict the burst time of the process according to its type. A Process can be of various types defined as follows. OS Process

A Process can be an Operating system process like schedulers, compilers, program managers and many more system processes. Their burst time is generally lower for example, 3 to 5 units of time. User Process

The Processes initiated by the users are called user processes. There can be three types of processes as follows. Interactive Process

The Interactive processes are the one which interact with the user time to time or Execution of which totally depends upon the User inputs for example various games are such processes. There burst time needs to be lower since they don't need CPU for a large amount of time, they mainly depend upon the user's interactivity with the process hence they are mainly IO bound processes. Foreground process

Foreground processes are the processes which are used by the user to perform their needs such as MS office, Editors, utility software etc. These types of processes have a bit higher burst time since they are a perfect mix of CPU and IO bound processes. Background process Background processes supports the execution of other processes. They work in hidden mode. For example, key logger is the process which records the keys pressed by the user and activities of the user on the system. They are mainly CPU bound processes and needs CPU for a higher amount of time. 2. Dynamic Techniques

Simple Averaging In simple averaging, there are given list of n processes P(i).......P(n). Let T(i) denotes the burst time of the process P(i). Let τ(n) denotes the predicted burst time of Pth process. Then according to the simple averaging, the predicted burst time of process n+1 will be calculated as, τ(n+1) = (1/n) ∑ T(i) Where, 0<=i<=n and ∑ T(i) is the summation of actual burst time of all the processes available till now. Exponential Averaging or Aging Let, Tn be the actual burst time of nth process.τ(n) be the predicted burst time for nth process then the CPU burst time for the next process (n+1) will be calculated as, τ(n+1) = α. Tn + (1-α) . τ(n) Where, α is the smoothing. Its value lies between 0 and 1.

Next Topic SRTF scheduling Algorithm



← prev next →



"
193,"next → ← prev Shortest Remaining Time First (SRTF) Scheduling Algorithm This Algorithm is the preemptive version of SJF scheduling. In SRTF, the execution of the process can be stopped after certain amount of time. At the arrival of every process, the short term scheduler schedules the process with the least remaining burst time among the list of available processes and the running process. Once all the processes are available in the ready queue, No preemption will be done and the algorithm will work as SJF scheduling. The context of the process is saved in the Process Control Block when the process is removed from the execution and the next process is scheduled. This PCB is accessed on the next execution of this process. Example In this Example, there are five jobs P1, P2, P3, P4, P5 and P6. Their arrival time and burst time are given below in the table. Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time Response Time 1 0 8 20 20 12 0 2 1 4 10 9 5 1 3 2 2 4 2 0 2 4 3 1 5 2 1 4 5 4 3 13 9 6 10 6 5 2 7 2 0 5 Avg Waiting Time = 24/6 The Gantt chart is prepared according to the arrival and burst time given in the table. Since, at time 0, the only available process is P1 with CPU burst time 8. This is the only available process in the list therefore it is scheduled. The next process arrives at time unit 1. Since the algorithm we are using is SRTF which is a preemptive one, the current execution is stopped and the scheduler checks for the process with the least burst time.

Till now, there are two processes available in the ready queue. The OS has executed P1 for one unit of time till now; the remaining burst time of P1 is 7 units. The burst time of Process P2 is 4 units. Hence Process P2 is scheduled on the CPU according to the algorithm. The next process P3 arrives at time unit 2. At this time, the execution of process P3 is stopped and the process with the least remaining burst time is searched. Since the process P3 has 2 unit of burst time hence it will be given priority over others. The Next Process P4 arrives at time unit 3. At this arrival, the scheduler will stop the execution of P4 and check which process is having least burst time among the available processes (P1, P2, P3 and P4). P1 and P2 are having the remaining burst time 7 units and 3 units respectively. P3 and P4 are having the remaining burst time 1 unit each. Since, both are equal hence the scheduling will be done according to their arrival time. P3 arrives earlier than P4 and therefore it will be scheduled again. The Next Process P5 arrives at time unit 4. Till this time, the Process P3 has completed its execution and it is no more in the list. The scheduler will compare the remaining burst time of all the available processes. Since the burst time of process P4 is 1 which is least among all hence this will be scheduled. The Next Process P6 arrives at time unit 5, till this time, the Process P4 has completed its execution. We have 4 available processes till now, that are P1 (7), P2 (3), P5 (3) and P6 (2). The Burst time of P6 is the least among all hence P6 is scheduled. Since, now, all the processes are available hence the algorithm will now work same as SJF. P6 will be executed till its completion and then the process with the least remaining time will be scheduled. Once all the processes arrive, No preemption is done and the algorithm will work as SJF.

Next Topic SRTF GATE 2011 Example



← prev next →



"
194,"next → ← prev SRTF GATE 2011 Example If we talk about scheduling algorithm from the GATE point of view, they generally ask simple numerical questions about finding the average waiting time and Turnaround Time. Let's discuss the question asked in GATE 2011 on SRTF. Q. Given the arrival time and burst time of 3 jobs in the table below. Calculate the Average waiting time of the system. Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 1 0 9 13 13 4 2 1 4 5 4 0 3 2 9 22 20 11 There are three jobs P1, P2 and P3. P1 arrives at time unit 0; it will be scheduled first for the time until the next process arrives. P2 arrives at 1 unit of time. Its burst time is 4 units which is least among the jobs in the queue. Hence it will be scheduled next. At time 2, P3 will arrive with burst time 9. Since remaining burst time of P2 is 3 units which are least among the available jobs. Hence the processor will continue its execution till its completion. Because all the jobs have been arrived so no preemption will be done now and all the jobs will be executed till the completion according to SJF. Avg Waiting Time = (4+0+11)/3 = 5 units

Next Topic Round Robin Scheduling



← prev next →



"
195,"next → ← prev Round Robin Scheduling Algorithm Round Robin scheduling algorithm is one of the most popular scheduling algorithm which can actually be implemented in most of the operating systems. This is the preemptive version of first come first serve scheduling. The Algorithm focuses on Time Sharing. In this algorithm, every process gets executed in a cyclic way. A certain time slice is defined in the system which is called time quantum. Each process present in the ready queue is assigned the CPU for that time quantum, if the execution of the process is completed during that time then the process will terminate else the process will go back to the ready queue and waits for the next turn to complete the execution.



Advantages It can be actually implementable in the system because it is not depending on the burst time. It doesn't suffer from the problem of starvation or convoy effect. All the jobs get a fare allocation of CPU. Disadvantages The higher the time quantum, the higher the response time in the system. The lower the time quantum, the higher the context switching overhead in the system. Deciding a perfect time quantum is really a very difficult task in the system.

Next Topic RR scheduling Example



← prev next →



"
196,"next → ← prev RR Scheduling Example In the following example, there are six processes named as P1, P2, P3, P4, P5 and P6. Their arrival time and burst time are given below in the table. The time quantum of the system is 4 units. Process ID Arrival Time Burst Time 1 0 5 2 1 6 3 2 3 4 3 1 5 4 5 6 6 4 According to the algorithm, we have to maintain the ready queue and the Gantt chart. The structure of both the data structures will be changed after every scheduling. Ready Queue: Initially, at time 0, process P1 arrives which will be scheduled for the time slice 4 units. Hence in the ready queue, there will be only one process P1 at starting with CPU burst time 5 units. P1 5 GANTT chart The P1 will be executed for 4 units first. Ready Queue Meanwhile the execution of P1, four more processes P2, P3, P4 and P5 arrives in the ready queue. P1 has not completed yet, it needs another 1 unit of time hence it will also be added back to the ready queue. P2 P3 P4 P5 P1 6 3 1 5 1 GANTT chart After P1, P2 will be executed for 4 units of time which is shown in the Gantt chart. Ready Queue During the execution of P2, one more process P6 is arrived in the ready queue. Since P2 has not completed yet hence, P2 will also be added back to the ready queue with the remaining burst time 2 units. P3 P4 P5 P1 P6 P2 3 1 5 1 4 2 GANTT chart After P1 and P2, P3 will get executed for 3 units of time since its CPU burst time is only 3 seconds. Ready Queue Since P3 has been completed, hence it will be terminated and not be added to the ready queue. The next process will be executed is P4. P4 P5 P1 P6 P2 1 5 1 4 2 GANTT chart After, P1, P2 and P3, P4 will get executed. Its burst time is only 1 unit which is lesser then the time quantum hence it will be completed. Ready Queue The next process in the ready queue is P5 with 5 units of burst time. Since P4 is completed hence it will not be added back to the queue. P5 P1 P6 P2 5 1 4 2 GANTT chart P5 will be executed for the whole time slice because it requires 5 units of burst time which is higher than the time slice. Ready Queue P5 has not been completed yet; it will be added back to the queue with the remaining burst time of 1 unit. P1 P6 P2 P5 1 4 2 1 GANTT Chart The process P1 will be given the next turn to complete its execution. Since it only requires 1 unit of burst time hence it will be completed. Ready Queue P1 is completed and will not be added back to the ready queue. The next process P6 requires only 4 units of burst time and it will be executed next. P6 P2 P5 4 2 1 GANTT chart P6 will be executed for 4 units of time till completion. Ready Queue Since P6 is completed, hence it will not be added again to the queue. There are only two processes present in the ready queue. The Next process P2 requires only 2 units of time. P2 P5 2 1 GANTT Chart P2 will get executed again, since it only requires only 2 units of time hence this will be completed. Ready Queue Now, the only available process in the queue is P5 which requires 1 unit of burst time. Since the time slice is of 4 units hence it will be completed in the next burst. P5 1 GANTT chart P5 will get executed till completion. The completion time, Turnaround time and waiting time will be calculated as shown in the table below. As, we know, Turn Around Time = Completion Time - Arrival Time Waiting Time = Turn Around Time - Burst Time

Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 1 0 5 17 17 12 2 1 6 23 22 16 3 2 3 11 9 6 4 3 1 12 9 8 5 4 5 24 20 15 6 6 4 21 15 11 Avg Waiting Time = (12+16+6+8+15+11)/6 = 76/6 units

Next Topic HRRN Scheduling



← prev next →



"
197,"next → ← prev Highest Response Ratio Next (HRRN) Scheduling Highest Response Ratio Next (HRNN) is one of the most optimal scheduling algorithms. This is a non-preemptive algorithm in which, the scheduling is done on the basis of an extra parameter called Response Ratio. A Response Ratio is calculated for each of the available jobs and the Job with the highest response ratio is given priority over the others. Response Ratio is calculated by the given formula. Response Ratio = (W+S)/S Where, W → Waiting Time S → Service Time or Burst Time If we look at the formula, we will notice that the job with the shorter burst time will be given priority but it is also including an extra factor called waiting time. Since, HRNN α W HRNN α (1/S) Hence, This algorithm not only favors shorter job but it also concern the waiting time of the longer jobs. Its mode is non preemptive hence context switching is minimal in this algorithm.

Next Topic HRNN Example



← prev next →



"
198,"HRNN Example

In the following example, there are 5 processes given. Their arrival time and Burst Time are given in the table.

Process ID Arrival Time Burst Time 0 0 3 1 2 5 2 4 4 3 6 1 4 8 2

At time 0, The Process P0 arrives with the CPU burst time of 3 units. Since it is the only process arrived till now hence this will get scheduled immediately.

P0 is executed for 3 units, meanwhile, only one process P1 arrives at time 3. This will get scheduled immediately since the OS doesn't have a choice.

P1 is executed for 5 units. Meanwhile, all the processes get available. We have to calculate the Response Ratio for all the remaining jobs.

RR (P2) = ((8-4) +4)/4 = 2 RR (P3) = (2+1)/1 = 3 RR (P4) = (0+2)/2 = 1

Since, the Response ratio of P3 is higher hence P3 will be scheduled first.

P3 is scheduled for 1 unit. The next available processes are P2 and P4. Let's calculate their Response ratio.

RR ( P2) = (5+4)/4 = 2.25 RR (P4) = (1+2)/2 = 1.5

The response ratio of P2 is higher hence P2 will be scheduled.

Now, the only available process is P4 with the burst time of 2 units, since there is no other process available hence this will be scheduled.

Process ID Arrival Time Burst Time Completion Time Turn Around Time Waiting Time 0 0 3 3 3 0 1 2 5 8 6 1 2 4 4 13 9 5 3 6 1 9 3 2 4 8 2 15 7 5

Average Waiting Time = 13/5"
199,"next → ← prev Priority Scheduling In Priority scheduling, there is a priority number assigned to each process. In some systems, the lower the number, the higher the priority. While, in the others, the higher the number, the higher will be the priority. The Process with the higher priority among the available processes is given the CPU. There are two types of priority scheduling algorithm exists. One is Preemptive priority scheduling while the other is Non Preemptive Priority scheduling.



The priority number assigned to each of the process may or may not vary. If the priority number doesn't change itself throughout the process, it is called static priority, while if it keeps changing itself at the regular intervals, it is called dynamic priority.



Next Topic Non Preemptive Priority Scheduling



← prev next →



"
200,"next → ← prev Non Preemptive Priority Scheduling In the Non Preemptive Priority scheduling, The Processes are scheduled according to the priority number assigned to them. Once the process gets scheduled, it will run till the completion. Generally, the lower the priority number, the higher is the priority of the process. The people might get confused with the priority numbers, hence in the GATE, there clearly mention which one is the highest priority and which one is the lowest one. Example In the Example, there are 7 processes P1, P2, P3, P4, P5, P6 and P7. Their priorities, Arrival Time and burst time are given in the table. Process ID Priority Arrival Time Burst Time 1 2 0 3 2 6 2 5 3 3 1 4 4 5 4 2 5 7 6 9 6 4 5 4 7 10 7 10 We can prepare the Gantt chart according to the Non Preemptive priority scheduling. The Process P1 arrives at time 0 with the burst time of 3 units and the priority number 2. Since No other process has arrived till now hence the OS will schedule it immediately. Meanwhile the execution of P1, two more Processes P2 and P3 are arrived. Since the priority of P3 is 3 hence the CPU will execute P3 over P2. Meanwhile the execution of P3, All the processes get available in the ready queue. The Process with the lowest priority number will be given the priority. Since P6 has priority number assigned as 4 hence it will be executed just after P3. After P6, P4 has the least priority number among the available processes; it will get executed for the whole burst time. Since all the jobs are available in the ready queue hence All the Jobs will get executed according to their priorities. If two jobs have similar priority number assigned to them, the one with the least arrival time will be executed. From the GANTT Chart prepared, we can determine the completion time of every process. The turnaround time, waiting time and response time will be determined. Turn Around Time = Completion Time - Arrival Time Waiting Time = Turn Around Time - Burst Time Process Id Priority Arrival Time Burst Time Completion Time Turnaround Time Waiting Time Response Time 1 2 0 3 3 3 0 0 2 6 2 5 18 16 11 13 3 3 1 4 7 6 2 3 4 5 4 2 13 9 7 11 5 7 6 9 27 21 12 18 6 4 5 4 11 6 2 7 7 10 7 10 37 30 18 27 Avg Waiting Time = (0+11+2+7+12+2+18)/7 = 52/7 units

Next Topic Preemptive Priority Scheduling



← prev next →



"
201,"next → ← prev Preemptive Priority Scheduling In Preemptive Priority Scheduling, at the time of arrival of a process in the ready queue, its Priority is compared with the priority of the other processes present in the ready queue as well as with the one which is being executed by the CPU at that point of time. The One with the highest priority among all the available processes will be given the CPU next. The difference between preemptive priority scheduling and non preemptive priority scheduling is that, in the preemptive priority scheduling, the job which is being executed can be stopped at the arrival of a higher priority job. Once all the jobs get available in the ready queue, the algorithm will behave as non-preemptive priority scheduling, which means the job scheduled will run till the completion and no preemption will be done. Example There are 7 processes P1, P2, P3, P4, P5, P6 and P7 given. Their respective priorities, Arrival Times and Burst times are given in the table below. Process Id Priority Arrival Time Burst Time 1 2(L) 0 1 2 6 1 7 3 3 2 3 4 5 3 6 5 4 4 5 6 10(H) 5 15 7 9 15 8 GANTT chart Preparation At time 0, P1 arrives with the burst time of 1 units and priority 2. Since no other process is available hence this will be scheduled till next job arrives or its completion (whichever is lesser). At time 1, P2 arrives. P1 has completed its execution and no other process is available at this time hence the Operating system has to schedule it regardless of the priority assigned to it. The Next process P3 arrives at time unit 2, the priority of P3 is higher to P2. Hence the execution of P2 will be stopped and P3 will be scheduled on the CPU. During the execution of P3, three more processes P4, P5 and P6 becomes available. Since, all these three have the priority lower to the process in execution so PS can't preempt the process. P3 will complete its execution and then P5 will be scheduled with the priority highest among the available processes. Meanwhile the execution of P5, all the processes got available in the ready queue. At this point, the algorithm will start behaving as Non Preemptive Priority Scheduling. Hence now, once all the processes get available in the ready queue, the OS just took the process with the highest priority and execute that process till completion. In this case, P4 will be scheduled and will be executed till the completion. Since P4 is completed, the other process with the highest priority available in the ready queue is P2. Hence P2 will be scheduled next. P2 is given the CPU till the completion. Since its remaining burst time is 6 units hence P7 will be scheduled after this. The only remaining process is P6 with the least priority, the Operating System has no choice unless of executing it. This will be executed at the last. The Completion Time of each process is determined with the help of GANTT chart. The turnaround time and the waiting time can be calculated by the following formula. Turnaround Time = Completion Time - Arrival Time Waiting Time = Turn Around Time - Burst Time Process Id Priority Arrival Time Burst Time Completion Time Turn around Time Waiting Time 1 2 0 1 1 1 0 2 6 1 7 22 21 14 3 3 2 3 5 3 0 4 5 3 6 16 13 7 5 4 4 5 10 6 1 6 10 5 15 45 40 25 7 9 6 8 30 24 16 Avg Waiting Time = (0+14+0+7+1+25+16)/7 = 63/7 = 9 units

Next Topic SRTF:IO bound processes



← prev next →



"
202,"next → ← prev SRTF with Processes contains CPU and IO Time Till now, we were considering the CPU bound jobs only. However, the process might need some IO operation or some resource to complete its execution. In this Example, we are considering, the IO bound processes. In the Example, there are four jobs with process ID P1, P2, P3 and P4 are available. Their Arrival Time, and the CPU Burst time are given in the table below. Process Id Arrival Time (Burst Time, IO Burst Time, Burst Time) 1 0 (3,2,2) 2 0 (1,3,1) 3 3 (3,1,2) 4 6 (5,4,5) GANTT Chart Preparation At time 0, the process P1 and P2 arrives. Since the algorithm we are using is SRTF hence, the process with the shortest burst time will be scheduled on the CPU. In this case, it is P2.



From time 0 to time 1, P2 will be in running state.



P2 also needs some IO time in order to complete its execution. After 1 unit of execution, P2 will change its state from running to waiting. The processor becomes free to execute other jobs. Since No other process is available at this point of time other than P1 so P1 will get executed. The following diagram illustrates the processes and states at Time 1. The process P2 went to waiting state and the CPU becomes idol at this time.



From time 1 to 3, since P2 is being in waiting state, and no other process is available in ready queue, hence the only available process P1 will be executed in this period of time.



At time 3, the process P3 arrived with the total CPU burst time of 5 units. Since the remaining burst time of P1 is lesser then P3 hence CPU will continue its execution.



Hence, P1 will remain in the running state from time 3 to time 4.



Since P1 is an IO bound process. At time unit 4, it will change its state from running to waiting. Processor becomes free for the execution of other jobs. Since P2 also becomes available at time 4 because it has completed the IO operation and now it needs another 1 unit of CPU burst time. P3 is also available and requires 5 units of total CPU burst time.



The process with the least remaining CPU burst time among the available processes will get executed. In our case, such process is P2 which requires 1 unit of burst time hence it will be given the CPU.



At time 5, P2 is finished. P1 is still in waiting state. At this point of time, the only available process is P3, hence it will be given the CPU.



From Time 5 to time 6, P3 will be in the running state; meanwhile, P1 will still be in waiting state.





At time 6, the Process P4 arrives in the ready queue. The P1 has also done with the IO and becomes available for the execution. P3 is not yet finished and still needs another 2 unit of CPU burst time. From time 6 to time 8, the reaming CPU burst time of Process P3 is least among the available processes, hence P3 will be given the CPU.



P3 needs some IO operation in order to complete its execution. At time 8, P3 will change its state from running to waiting. The CPU becomes free to execute the other processes. Process P4 and P1 are available out of which, the process with the least remaining burst time will get executed.



From time 8 to time 9, the process P1 will get executed.



At time 9, the IO of process P3 is finished and it will now be available in the ready state along with P4 which is already waiting there for its turn. In order to complete its execution, it needs another 2 unit of burst time. P1 is in running state at this point of the time while no process is present in the waiting state.





from time 9 to 10 , the process P1 will get executed since its remaining CPU burst time is lesser then the processes P4 and P3 available in the ready queue.



At time 10, execution of P1 is finished, and now the CPU becomes idol. The process with the lesser CPU burst time among the ready processes will get the CPU turn. From time 10 to 12, the process P3 will get executed till its completion because of the fact that its remaining CPU burst time is the between the two available processes. It needs 2 units of more CPU burst time, since No other process will be arrived in the ready state hence No preemption will be done and it will be executed till the completion.



At time 12, the process P3 will get completed, since there is only one process P4 available in the ready state hence P4 will be given the CPU.



P4 needs 5 units of CPU burst time before IO, hence it will be executed till time 17 (for 5 units) and then it will change its state from running to waiting. At time 17, the Process P4 changes its state from running to waiting. Since this is the only process in the system hence the CPU will remain idol until P4 becomes available again.



At time 21, P4 will be done with the IO operation and becomes available in the ready state.



From time 21, the process P4 will get scheduled. Since No other process is in ready queue hence the processor don't have any choice. It will be executed till completion.



Final Gantt chart: Process Id Arrival Time Total CPU Burst Time Completion Time Turn Around Time Waiting Time 1 0 5 10 10 5 2 0 2 5 5 3 3 3 5 12 9 4 4 6 10 26 20 10 Average waiting Time = (5+3+4+10)/4 = 22/4 units

Next Topic Process Synchronization Introduction



← prev next →



"
203,"Introduction

When two or more process cooperates with each other, their order of execution must be preserved otherwise there can be conflicts in their execution and inappropriate outputs can be produced.

A cooperative process is the one which can affect the execution of other process or can be affected by the execution of other process. Such processes need to be synchronized so that their order of execution can be guaranteed.

The procedure involved in preserving the appropriate order of execution of cooperative processes is known as Process Synchronization. There are various synchronization mechanisms that are used to synchronize the processes.

Race Condition

A Race Condition typically occurs when two or more threads try to read, write and possibly make the decisions based on the memory that they are accessing concurrently.

Critical Section

The regions of a program that try to access shared resources and may cause race conditions are called critical section. To avoid race condition among the processes, we need to assure that only one process at a time can execute within the critical section."
204,"next → ← prev The Critical Section Problem Critical Section is the part of a program which tries to access shared resources. That resource may be any resource in a computer like a memory location, Data structure, CPU or any IO device. The critical section cannot be executed by more than one process at the same time; operating system faces the difficulties in allowing and disallowing the processes from entering the critical section. The critical section problem is used to design a set of protocols which can ensure that the Race condition among the processes will never arise. In order to synchronize the cooperative processes, our main task is to solve the critical section problem. We need to provide a solution in such a way that the following conditions can be satisfied. Requirements of Synchronization mechanisms

Primary Mutual Exclusion Our solution must provide mutual exclusion. By Mutual Exclusion, we mean that if one process is executing inside critical section then the other process must not enter in the critical section.







Progress Progress means that if one process doesn't need to execute into critical section then it should not stop other processes to get into the critical section. Secondary Bounded Waiting We should be able to predict the waiting time for every process to get into the critical section. The process must not be endlessly waiting for getting into the critical section. Architectural Neutrality Our mechanism must be architectural natural. It means that if our solution is working fine on one architecture then it should also run on the other ones as well.

Next Topic Lock Variable Mechanism



← prev next →



"
205,"next → ← prev Lock Variable This is the simplest synchronization mechanism. This is a Software Mechanism implemented in User mode. This is a busy waiting solution which can be used for more than two processes. In this mechanism, a Lock variable lockis used. Two values of lock can be possible, either 0 or 1. Lock value 0 means that the critical section is vacant while the lock value 1 means that it is occupied. A process which wants to get into the critical section first checks the value of the lock variable. If it is 0 then it sets the value of lock as 1 and enters into the critical section, otherwise it waits. The pseudo code of the mechanism looks like following. Entry Section → While (lock! = 0); Lock = 1; //Critical Section Exit Section → Lock =0; If we look at the Pseudo Code, we find that there are three sections in the code. Entry Section, Critical Section and the exit section. Initially the value of lock variable is 0. The process which needs to get into the critical section, enters into the entry section and checks the condition provided in the while loop. The process will wait infinitely until the value of lock is 1 (that is implied by while loop). Since, at the very first time critical section is vacant hence the process will enter the critical section by setting the lock variable as 1. When the process exits from the critical section, then in the exit section, it reassigns the value of lock as 0. Every Synchronization mechanism is judged on the basis of four conditions. Mutual Exclusion Progress Bounded Waiting Portability Out of the four parameters, Mutual Exclusion and Progress must be provided by any solution. Let?s analyze this mechanism on the basis of the above mentioned conditions. Mutual Exclusion The lock variable mechanism doesn't provide Mutual Exclusion in some of the cases. This can be better described by looking at the pseudo code by the Operating System point of view I.E. Assembly code of the program. Let's convert the Code into the assembly language. Load Lock, R0 CMP R0, #0 JNZ Step 1 Store #1, Lock Store #0, Lock Let us consider that we have two processes P1 and P2. The process P1 wants to execute its critical section. P1 gets into the entry section. Since the value of lock is 0 hence P1 changes its value from 0 to 1 and enters into the critical section. Meanwhile, P1 is preempted by the CPU and P2 gets scheduled. Now there is no other process in the critical section and the value of lock variable is 0. P2 also wants to execute its critical section. It enters into the critical section by setting the lock variable to 1. Now, CPU changes P1's state from waiting to running. P1 is yet to finish its critical section. P1 has already checked the value of lock variable and remembers that its value was 0 when it previously checked it. Hence, it also enters into the critical section without checking the updated value of lock variable. Now, we got two processes in the critical section. According to the condition of mutual exclusion, morethan one process in the critical section must not be present at the same time. Hence, the lock variable mechanism doesn't guarantee the mutual exclusion. The problem with the lock variable mechanism is that, at the same time, more than one process can see the vacant tag and more than one process can enter in the critical section. Hence, the lock variable doesn't provide the mutual exclusion that's why it cannot be used in general. Since, this method is failed at the basic step; hence, there is no need to talk about the other conditions to be fulfilled.

Next Topic TSL Mechanism



← prev next →



"
206,"next → ← prev Test Set Lock Mechanism Modification in the assembly code In lock variable mechanism, Sometimes Process reads the old value of lock variable and enters the critical section. Due to this reason, more than one process might get into critical section. However, the code shown in the part one of the following section can be replaced with the code shown in the part two. This doesn't affect the algorithm but, by doing this, we can manage to provide the mutual exclusion to some extent but not completely. In the updated version of code, the value of Lock is loaded into the local register R0 and then value of lock is set to 1. However, in step 3, the previous value of lock (that is now stored into R0) is compared with 0. if this is 0 then the process will simply enter into the critical section otherwise will wait by executing continuously in the loop. The benefit of setting the lock immediately to 1 by the process itself is that, now the process which enters into the critical section carries the updated value of lock variable that is 1. In the case when it gets preempted and scheduled again then also it will not enter the critical section regardless of the current value of the lock variable as it already knows what the updated value of lock variable is. Section 1 Section 2 1. Load Lock, R0 2. CMP R0, #0 3. JNZ step1 4. store #1, Lock 1. Load Lock, R0 2. Store #1, Lock 3. CMP R0, #0 4. JNZ step 1 TSL Instruction However, the solution provided in the above segment provides mutual exclusion to some extent but it doesn't make sure that the mutual exclusion will always be there. There is a possibility of having more than one process in the critical section. What if the process gets preempted just after executing the first instruction of the assembly code written in section 2? In that case, it will carry the old value of lock variable with it and it will enter into the critical section regardless of knowing the current value of lock variable. This may make the two processes present in the critical section at the same time. To get rid of this problem, we have to make sure that the preemption must not take place just after loading the previous value of lock variable and before setting it to 1. The problem can be solved if we can be able to merge the first two instructions. In order to address the problem, the operating system provides a special instruction called Test Set Lock (TSL) instruction which simply loads the value of lock variable into the local register R0 and sets it to 1 simultaneously The process which executes the TSL first will enter into the critical section and no other process after that can enter until the first process comes out. No process can execute the critical section even in the case of preemption of the first process. The assembly code of the solution will look like following. TSL Lock, R0 CMP R0, #0 JNZ step 1 Let's examine TSL on the basis of the four conditions. Mutual Exclusion

Mutual Exclusion is guaranteed in TSL mechanism since a process can never be preempted just before setting the lock variable. Only one process can see the lock variable as 0 at a particular time and that's why, the mutual exclusion is guaranteed. Progress

According to the definition of the progress, a process which doesn't want to enter in the critical section should not stop other processes to get into it. In TSL mechanism, a process will execute the TSL instruction only when it wants to get into the critical section. The value of the lock will always be 0 if no process doesn't want to enter into the critical section hence the progress is always guaranteed in TSL. Bounded Waiting

Bounded Waiting is not guaranteed in TSL. Some process might not get a chance for so long. We cannot predict for a process that it will definitely get a chance to enter in critical section after a certain time. Architectural Neutrality TSL doesn't provide Architectural Neutrality. It depends on the hardware platform. The TSL instruction is provided by the operating system. Some platforms might not provide that. Hence it is not Architectural natural.



Next Topic Priority Inversion in TSL



← prev next →



"
207,"next → ← prev Priority Inversion In TSL mechanism, there can be a problem of priority inversion. Let?s say that there are two cooperative processes, P1 and P2. The priority of P1 is 2 while that of P2 is 1. P1 arrives earlier and got scheduled by the CPU. Since it is a cooperative process and wants to execute in the critical section hence it will enter in the critical section by setting the lock variable to 1. Now, P2 arrives in the ready queue. The priority of P2 is higher than P1 hence according to priority scheduling, P2 is scheduled and P1 got preempted. P2 is also a cooperative process and wants to execute inside the critical section. Although, P1 got preempted but it the value of lock variable will be shown as 1 since P1 is not completed and it is yet to finish its critical section. P1 needs to finish the critical section but according to the scheduling algorithm, CPU is with P2. P2 wants to execute in the critical section, but according to the synchronization mechanism, critical section is with P1. This is a kind of lock where each of the process neither executes nor completes. Such kind of lock is called Spin Lock. This is different from deadlock since they are not in blocked state. One is in ready state and the other is in running state, but neither of the two is being executed.

Next Topic Turn Variable or Strict Alternation



← prev next →



"
208,"next → ← prev Turn Variable or Strict Alternation Approach Turn Variable or Strict Alternation Approach is the software mechanism implemented at user mode. It is a busy waiting solution which can be implemented only for two processes. In this approach, A turn variable is used which is actually a lock. This approach can only be used for only two processes. In general, let the two processes be Pi and Pj. They share a variable called turn variable. The pseudo code of the program can be given as following. For Process Pi Non - CS while (turn ! = i); Critical Section turn = j; Non - CS For Process Pj Non - CS while (turn ! = j); Critical Section turn = i ; Non - CS The actual problem of the lock variable approach was the fact that the process was entering in the critical section only when the lock variable is 1. More than one process could see the lock variable as 1 at the same time hence the mutual exclusion was not guaranteed there. This problem is addressed in the turn variable approach. Now, A process can enter in the critical section only in the case when the value of the turn variable equal to the PID of the process. There are only two values possible for turn variable, i or j. if its value is not i then it will definitely be j or vice versa. In the entry section, in general, the process Pi will not enter in the critical section until its value is j or the process Pj will not enter in the critical section until its value is i. Initially, two processes Pi and Pj are available and want to execute into critical section.



The turn variable is equal to i hence Pi will get the chance to enter into the critical section. The value of Pi remains I until Pi finishes critical section.



Pi finishes its critical section and assigns j to turn variable. Pj will get the chance to enter into the critical section. The value of turn remains j until Pj finishes its critical section.



Analysis of Strict Alternation approach Let's analyze Strict Alternation approach on the basis of four requirements. Mutual Exclusion The strict alternation approach provides mutual exclusion in every case. This procedure works only for two processes. The pseudo code is different for both of the processes. The process will only enter when it sees that the turn variable is equal to its Process ID otherwise not Hence No process can enter in the critical section regardless of its turn. Progress Progress is not guaranteed in this mechanism. If Pi doesn't want to get enter into the critical section on its turn then Pj got blocked for infinite time. Pj has to wait for so long for its turn since the turn variable will remain 0 until Pi assigns it to j. Portability The solution provides portability. It is a pure software mechanism implemented at user mode and doesn't need any special instruction from the Operating System.



Next Topic Interested Variable Mechanism



← prev next →



"
209,"next → ← prev Interested Variable Mechanism We have to make sure that the progress must be provided by our synchronization mechanism. In the turn variable mechanism, progress was not provided due to the fact that the process which doesn't want to enter in the critical section does not consider the other interested process as well. The other process will also have to wait regardless of the fact that there is no one inside the critical section. If the operating system can make use of an extra variable along with the turn variable then this problem can be solved and our problem can provide progress to most of the extent. Interested variable mechanism makes use of an extra Boolean variable to make sure that the progress is provided. For Process Pi Non CS Int[i] = T ; while ( Int[j] == T ) ; Critical Section Int[i] = F ; For Process Pj Non CS Int [1] = T ; while ( Int[i] == T ) ; Critical Section Int[j]=F ; In this mechanism, an extra variable interested is used. This is a Boolean variable used to store the interest of the processes to get enter inside the critical section. A process which wants to enter in the critical section first checks in the entry section whether the other process is interested to get inside. The process will wait for the time until the other process is interested. In exit section, the process makes the value of its interest variable false so that the other process can get into the critical section. The table shows the possible values of interest variable of both the processes and the process which get the chance in the scenario. Interest [Pi] Interest [Pj] Process which get the chance True True The process which first shows interest. True False Pi False True Pj False False X Let's analyze the mechanism on the basis of the requirements. Mutual Exclusion In interested variable mechanism, if one process is interested in getting into the CPU then the other process will wait until it becomes uninterested. Therefore, more than one process can never be present in the critical section at the same time hence the mechanism guarantees mutual exclusion. Progress In this mechanism, if a process is not interested in getting into the critical section then it will not stop the other process from getting into the critical section. Therefore the progress will definitely be provided by this method. Bounded Waiting To analyze bounded waiting, let us consider two processes Pi and Pj, are the cooperative processes wants to execute in the critical section. The instructions executed by the processes are shown below in relative manner. Process Pi Process Pj Process Pi Process Pj 1. Int [Pi] = True

2. while (Int [Pj] == True);

3. Critical Section 1. Int [Pj] = True

2. while (Int[Pi]==True); 1. Int [Pi] = False

2. Int [Pi] = True

3. while (Int [Pj] == True); //waiting for Pj 1. While (Int [Pi] == True); //waiting for Pj Initially, the interest variable of both the processes is false. The process Pi shows the interest to get inside the critical section. It sets its Interest Variable to true and check whether the Pj is also interested or not. Since the other process's interest variable is false hence Pi will get enter into the critical section. Meanwhile, the process Pi is preempted and Pj is scheduled. Pj is a cooperative process and therefore, it also wants to enter in the critical section. It shows its interest by setting the interest variable to true. It also checks whether the other process is also interested or not. We should notice that Pi is preempted but its interested variable is true that means it needs to further execute in the critical section. Therefore Pj will not get the chance and gets stuck in the while loop. Meanwhile, CPU changes Pi's state from blocked to running. Pi is yet to finish its critical section hence it finishes the critical section and makes an exit by setting the interest variable to False. Now, a case can be possible when Pi again wants to enter in the critical section and set its interested variable to true and checks whether the interested variable of Pj is true. Here, Pj's interest variable is True hence Pi will get stuck in the while loop and waits for Pj become uninterested. Since, Pj still stuck in the while loop waiting for the Pi' interested variable to become false. Therefore, both the processes are waiting for each other and none of them is getting into the critical section. This is a condition of deadlock and bounded waiting can never be provided in the case of deadlock. Therefore, we can say that the interested variable mechanism doesn't guarantee deadlock. Architectural Neutrality The mechanism is a complete software mechanism executed in the user mode therefore it guarantees portability or architectural neutrality.



Next Topic Paterson Solution



← prev next →



"
210,"next → ← prev Paterson Solution This is a software mechanism implemented at user mode. It is a busy waiting solution can be implemented for only two processes. It uses two variables that are turn variable and interested variable. The Code of the solution is given below # define N 2 # define TRUE 1 # define FALSE 0 int interested[N] = FALSE; int turn; voidEntry_Section (int process) { int other; other = 1-process; interested[process] = TRUE; turn = process; while (interested [other] =True && TURN=process); } voidExit_Section (int process) { interested [process] = FALSE; } Till now, each of our solution is affected by one or the other problem. However, the Peterson solution provides you all the necessary requirements such as Mutual Exclusion, Progress, Bounded Waiting and Portability. Analysis of Peterson Solution voidEntry_Section (int process) { 1. int other; 2. other = 1-process; 3. interested[process] = TRUE; 4. turn = process; 5. while (interested [other] =True && TURN=process); } Critical Section voidExit_Section (int process) { 6. interested [process] = FALSE; } This is a two process solution. Let us consider two cooperative processes P1 and P2. The entry section and exit section are shown below. Initially, the value of interested variables and turn variable is 0. Initially process P1 arrives and wants to enter into the critical section. It sets its interested variable to True (instruction line 3) and also sets turn to 1 (line number 4). Since the condition given in line number 5 is completely satisfied by P1 therefore it will enter in the critical section. P1 → 1 2 3 4 5 CS Meanwhile, Process P1 got preempted and process P2 got scheduled. P2 also wants to enter in the critical section and executes instructions 1, 2, 3 and 4 of entry section. On instruction 5, it got stuck since it doesn't satisfy the condition (value of other interested variable is still true). Therefore it gets into the busy waiting. P2 → 1 2 3 4 5 P1 again got scheduled and finish the critical section by executing the instruction no. 6 (setting interested variable to false). Now if P2 checks then it are going to satisfy the condition since other process's interested variable becomes false. P2 will also get enter the critical section. P1 → 6 P2 → 5 CS Any of the process may enter in the critical section for multiple numbers of times. Hence the procedure occurs in the cyclic order. Mutual Exclusion The method provides mutual exclusion for sure. In entry section, the while condition involves the criteria for two variables therefore a process cannot enter in the critical section until the other process is interested and the process is the last one to update turn variable. Progress An uninterested process will never stop the other interested process from entering in the critical section. If the other process is also interested then the process will wait. Bounded waiting The interested variable mechanism failed because it was not providing bounded waiting. However, in Peterson solution, A deadlock can never happen because the process which first sets the turn variable will enter in the critical section for sure. Therefore, if a process is preempted after executing line number 4 of the entry section then it will definitely get into the critical section in its next chance. Portability This is the complete software solution and therefore it is portable on every hardware.



Next Topic Synchronization Mechanism Without Busy Waiting



← prev next →



"
211,"Synchronization Mechanism without busy waiting

All the solutions we have seen till now were intended to provide mutual exclusion with busy waiting. However, busy waiting is not the optimal allocation of resources because it keeps CPU busy all the time in checking the while loops condition continuously although the process is waiting for the critical section to become available.

All the synchronization mechanism with busy waiting are also suffering from the priority inversion problem that is there is always a possibility of spin lock whenever there is a process with the higher priority has to wait outside the critical section since the mechanism intends to execute the lower priority process in the critical section.

However these problems need a proper solution without busy waiting and priority inversion."
212,"next → ← prev Sleep and Wake (Producer Consumer problem) Let's examine the basic model that is sleep and wake. Assume that we have two system calls as sleep and wake. The process which calls sleep will get blocked while the process which calls will get waked up. There is a popular example called producer consumer problem which is the most popular problem simulating sleep and wake mechanism. The concept of sleep and wake is very simple. If the critical section is not empty then the process will go and sleep. It will be waked up by the other process which is currently executing inside the critical section so that the process can get inside the critical section. In producer consumer problem, let us say there are two processes, one process writes something while the other process reads that. The process which is writing something is called producer while the process which is reading is called consumer. In order to read and write, both of them are usinga buffer. The code that simulates the sleep and wake mechanism in terms of providing the solution to producer consumer problem is shown below.

#define N 100 //maximum slots in buffer #define count=0 //items in the buffer void producer (void) { int item; while(True) { item = produce_item(); //producer produces an item if(count == N) //if the buffer is full then the producer will sleep Sleep(); insert_item (item); //the item is inserted into buffer count=count+1; if(count==1) //The producer will wake up the //consumer if there is at least 1 item in the buffer wake-up(consumer); } } void consumer (void) { int item; while(True) { { if(count == 0) //The consumer will sleep if the buffer is empty. sleep(); item = remove_item(); count = count - 1; if(count == N-1) //if there is at least one slot available in the buffer //then the consumer will wake up producer wake-up(producer); consume_item(item); //the item is read by consumer. } } }

The producer produces the item and inserts it into the buffer. The value of the global variable count got increased at each insertion. If the buffer is filled completely and no slot is available then the producer will sleep, otherwise it keep inserting. On the consumer's end, the value of count got decreased by 1 at each consumption. If the buffer is empty at any point of time then the consumer will sleep otherwise, it keeps consuming the items and decreasing the value of count by 1. The consumer will be waked up by the producer if there is at least 1 item available in the buffer which is to be consumed. The producer will be waked up by the consumer if there is at least one slot available in the buffer so that the producer can write that. Well, the problem arises in the case when the consumer got preempted just before it was about to sleep. Now the consumer is neither sleeping nor consuming. Since the producer is not aware of the fact that consumer is not actually sleeping therefore it keep waking the consumer while the consumer is not responding since it is not sleeping. This leads to the wastage of system calls. When the consumer get scheduled again, it will sleep because it was about to sleep when it was preempted. The producer keep writing in the buffer and it got filled after some time. The producer will also sleep at that time keeping in the mind that the consumer will wake him up when there is a slot available in the buffer. The consumer is also sleeping and not aware with the fact that the producer will wake him up. This is a kind of deadlock where neither producer nor consumer is active and waiting for each other to wake them up. This is a serious problem which needs to be addressed. Using a flag bit to get rid of this problem A flag bit can be used in order to get rid of this problem. The producer can set the bit when it calls wake-up on the first time. When the consumer got scheduled, it checks the bit. The consumer will now get to know that the producer tried to wake him and therefore it will not sleep and get into the ready state to consume whatever produced by the producer. This solution works for only one pair of producer and consumer, what if there are n producers and n consumers. In that case, there is a need to maintain an integer which can record how many wake-up calls have been made and how many consumers need not sleep. This integer variable is called semaphore. We will discuss more about semaphore later in detail.

Next Topic Semaphore Introduction



← prev next →



"
213,"Introduction to semaphore

To get rid of the problem of wasting the wake-up signals, Dijkstra proposed an approach which involves storing all the wake-up calls. Dijkstra states that, instead of giving the wake-up calls directly to the consumer, producer can store the wake-up call in a variable. Any of the consumers can read it whenever it needs to do so.

Semaphore is the variables which storesthe entire wake up calls that are being transferred from producer to consumer. It is a variable on which read, modify and update happens automatically in kernel mode.

Semaphore cannot be implemented in the user mode because race condition may always arise when two or more processes try to access the variable simultaneously. It always needs support from the operating system to be implemented.

According to the demand of the situation, Semaphore can be divided into two categories.

Counting Semaphore Binary Semaphore or Mutex

We will discuss each one in detail."
214,"next → ← prev Counting Semaphore There are the scenarios in which more than one processes need to execute in critical section simultaneously. However, counting semaphore can be used when we need to have more than one process in the critical section at the same time. The programming code of semaphore implementation is shown below which includes the structure of semaphore and the logic using which the entry and the exit can be performed in the critical section.

struct Semaphore { int value; // processes that can enter in the critical section simultaneously. queue type L; // L contains set of processes which get blocked } Down (Semaphore S) { S.value = S.value - 1; //semaphore's value will get decreased when a new //process enter in the critical section if (S.value< 0) { put_process(PCB) in L; //if the value is negative then //the process will get into the blocked state. Sleep(); } else return; } up (Semaphore s) { S.value = S.value+1; //semaphore value will get increased when //it makes an exit from the critical section. if(S.value<=0) { select a process from L; //if the value of semaphore is positive //then wake one of the processes in the blocked queue. wake-up(); } } }

In this mechanism, the entry and exit in the critical section are performed on the basis of the value of counting semaphore. The value of counting semaphore at any point of time indicates the maximum number of processes that can enter in the critical section at the same time. A process which wants to enter in the critical section first decrease the semaphore value by 1 and then check whether it gets negative or not. If it gets negative then the process is pushed in the list of blocked processes (i.e. q) otherwise it gets enter in the critical section. When a process exits from the critical section, it increases the counting semaphore by 1 and then checks whether it is negative or zero. If it is negative then that means that at least one process is waiting in the blocked state hence, to ensure bounded waiting, the first process among the list of blocked processes will wake up and gets enter in the critical section. The processes in the blocked list will get waked in the order in which they slept. If the value of counting semaphore is negative then it states the number of processes in the blocked state while if it is positive then it states the number of slots available in the critical section.

Next Topic Problem on Counting Semaphore



← prev next →



"
215,"Problem on Counting Semaphore

The questions are being asked on counting semaphore in GATE. Generally the questions are very simple that contains only subtraction and addition.

Wait → Decre → Down → P Signal → Inc → Up → V

The following type questions can be asked in GATE.

A Counting Semaphore was initialized to 12. then 10P (wait) and 4V (Signal) operations were computed on this semaphore. What is the result?

S = 12 (initial) 10 p (wait) : S = S -10 = 12 - 10 = 2 then 4 V : S = S + 4 =2 + 4 = 6

Hence, the final value of counting semaphore is 6."
216,"next → ← prev Binary Semaphore or Mutex In counting semaphore, Mutual exclusion was not provided because we has the set of processes which required to execute in the critical section simultaneously. However, Binary Semaphore strictly provides mutual exclusion. Here, instead of having more than 1 slots available in the critical section, we can only have at most 1 process in the critical section. The semaphore can have only two values, 0 or 1. Let's see the programming implementation of Binary Semaphore.

StructBsemaphore { enum Value(0,1); //value is enumerated data type which can only have two values 0 or 1. Queue type L; } /* L contains all PCBs corresponding to process Blocked while processing down operation unsuccessfully. */ Down (Bsemaphore S) { if (s.value == 1) // if a slot is available in the //critical section then let the process enter in the queue. { S.value = 0; // initialize the value to 0 so that no other process can read it as 1. } else { put the process (PCB) in S.L; //if no slot is available //then let the process wait in the blocked queue. sleep(); } } Up (Bsemaphore S) { if (S.L is empty) //an empty blocked processes list implies that no process //has ever tried to get enter in the critical section. { S.Value =1; } else { Select a process from S.L; Wakeup(); // if it is not empty then wake the first process of the blocked queue. } }



Next Topic Introduction Deadlocks



← prev next →



"
217,"next → ← prev Introduction to Deadlock Every process needs some resources to complete its execution. However, the resource is granted in a sequential order. The process requests for some resource. OS grant the resource if it is available otherwise let the process waits. The process uses it and release on the completion. A Deadlock is a situation where each of the computer process waits for a resource which is being assigned to some another process. In this situation, none of the process gets executed since the resource it needs, is held by some other process which is also waiting for some other resource to be released. Let us assume that there are three processes P1, P2 and P3. There are three different resources R1, R2 and R3. R1 is assigned to P1, R2 is assigned to P2 and R3 is assigned to P3. After some time, P1 demands for R1 which is being used by P2. P1 halts its execution since it can't complete without R2. P2 also demands for R3 which is being used by P3. P2 also stops its execution because it can't continue without R3. P3 also demands for R1 which is being used by P1 therefore P3 also stops its execution. In this scenario, a cycle is being formed among the three processes. None of the process is progressing and they are all waiting. The computer becomes unresponsive since all the processes got blocked. Difference between Starvation and Deadlock Sr. Deadlock Starvation 1 Deadlock is a situation where no process got blocked and no process proceeds Starvation is a situation where the low priority process got blocked and the high priority processes proceed. 2 Deadlock is an infinite waiting. Starvation is a long waiting but not infinite. 3 Every Deadlock is always a starvation. Every starvation need not be deadlock. 4 The requested resource is blocked by the other process. The requested resource is continuously be used by the higher priority processes. 5 Deadlock happens when Mutual exclusion, hold and wait, No preemption and circular wait occurs simultaneously. It occurs due to the uncontrolled priority and resource management. Necessary conditions for Deadlocks Mutual Exclusion A resource can only be shared in mutually exclusive manner. It implies, if two process cannot use the same resource at the same time. Hold and Wait A process waits for some resources while holding another resource at the same time. No preemption The process which once scheduled will be executed till the completion. No other process can be scheduled by the scheduler meanwhile. Circular Wait All the processes must be waiting for the resources in a cyclic manner so that the last process is waiting for the resource which is being held by the first process.

Next Topic strategies Handling Deadlock



← prev next →



"
218,"next → ← prev Strategies for handling Deadlock 1. Deadlock Ignorance Deadlock Ignorance is the most widely used approach among all the mechanism. This is being used by many operating systems mainly for end user uses. In this approach, the Operating system assumes that deadlock never occurs. It simply ignores deadlock. This approach is best suitable for a single end user system where User uses the system only for browsing and all other normal stuff. There is always a tradeoff between Correctness and performance. The operating systems like Windows and Linux mainly focus upon performance. However, the performance of the system decreases if it uses deadlock handling mechanism all the time if deadlock happens 1 out of 100 times then it is completely unnecessary to use the deadlock handling mechanism all the time. In these types of systems, the user has to simply restart the computer in the case of deadlock. Windows and Linux are mainly using this approach. 2. Deadlock prevention Deadlock happens only when Mutual Exclusion, hold and wait, No preemption and circular wait holds simultaneously. If it is possible to violate one of the four conditions at any time then the deadlock can never occur in the system. The idea behind the approach is very simple that we have to fail one of the four conditions but there can be a big argument on its physical implementation in the system. We will discuss it later in detail. 3. Deadlock avoidance In deadlock avoidance, the operating system checks whether the system is in safe state or in unsafe state at every step which the operating system performs. The process continues until the system is in safe state. Once the system moves to unsafe state, the OS has to backtrack one step. In simple words, The OS reviews each allocation so that the allocation doesn't cause the deadlock in the system. We will discuss Deadlock avoidance later in detail. 4. Deadlock detection and recovery This approach let the processes fall in deadlock and then periodically check whether deadlock occur in the system or not. If it occurs then it applies some of the recovery methods to the system to get rid of deadlock. We will discuss deadlock detection and recovery later in more detail since it is a matter of discussion.

Next Topic Deadlock Prevention



← prev next →



"
219,"next → ← prev Deadlock Prevention If we simulate deadlock with a table which is standing on its four legs then we can also simulate four legs with the four conditions which when occurs simultaneously, cause the deadlock. However, if we break one of the legs of the table then the table will fall definitely. The same happens with deadlock, if we can be able to violate one of the four necessary conditions and don't let them occur together then we can prevent the deadlock. Let's see how we can prevent each of the conditions. 1. Mutual Exclusion Mutual section from the resource point of view is the fact that a resource can never be used by more than one process simultaneously which is fair enough but that is the main reason behind the deadlock. If a resource could have been used by more than one process at the same time then the process would have never been waiting for any resource. However, if we can be able to violate resources behaving in the mutually exclusive manner then the deadlock can be prevented. Spooling For a device like printer, spooling can work. There is a memory associated with the printer which stores jobs from each of the process into it. Later, Printer collects all the jobs and print each one of them according to FCFS. By using this mechanism, the process doesn't have to wait for the printer and it can continue whatever it was doing. Later, it collects the output when it is produced.



Although, Spooling can be an effective approach to violate mutual exclusion but it suffers from two kinds of problems. This cannot be applied to every resource. After some point of time, there may arise a race condition between the processes to get space in that spool. We cannot force a resource to be used by more than one process at the same time since it will not be fair enough and some serious problems may arise in the performance. Therefore, we cannot violate mutual exclusion for a process practically. 2. Hold and Wait Hold and wait condition lies when a process holds a resource and waiting for some other resource to complete its task. Deadlock occurs because there can be more than one process which are holding one resource and waiting for other in the cyclic order. However, we have to find out some mechanism by which a process either doesn't hold any resource or doesn't wait. That means, a process must be assigned all the necessary resources before the execution starts. A process must not wait for any resource once the execution has been started. !(Hold and wait) = !hold or !wait (negation of hold and wait is, either you don't hold or you don't wait) This can be implemented practically if a process declares all the resources initially. However, this sounds very practical but can't be done in the computer system because a process can't determine necessary resources initially. Process is the set of instructions which are executed by the CPU. Each of the instruction may demand multiple resources at the multiple times. The need cannot be fixed by the OS. The problem with the approach is: Practically not possible. Possibility of getting starved will be increases due to the fact that some process may hold a resource for a very long time. 3. No Preemption Deadlock arises due to the fact that a process can't be stopped once it starts. However, if we take the resource away from the process which is causing deadlock then we can prevent deadlock. This is not a good approach at all since if we take a resource away which is being used by the process then all the work which it has done till now can become inconsistent. Consider a printer is being used by any process. If we take the printer away from that process and assign it to some other process then all the data which has been printed can become inconsistent and ineffective and also the fact that the process can't start printing again from where it has left which causes performance inefficiency. 4. Circular Wait To violate circular wait, we can assign a priority number to each of the resource. A process can't request for a lesser priority resource. This ensures that not a single process can request a resource which is being utilized by some other process and no cycle will be formed.



Among all the methods, violating Circular wait is the only approach that can be implemented practically.

Next Topic Deadlock Avoidance



← prev next →



"
220,"next → ← prev Deadlock avoidance In deadlock avoidance, the request for any resource will be granted if the resulting state of the system doesn't cause deadlock in the system. The state of the system will continuously be checked for safe and unsafe states. In order to avoid deadlocks, the process must tell OS, the maximum number of resources a process can request to complete its execution. The simplest and most useful approach states that the process should declare the maximum number of resources of each type it may ever need. The Deadlock avoidance algorithm examines the resource allocations so that there can never be a circular wait condition. Safe and Unsafe States The resource allocation state of a system can be defined by the instances of available and allocated resources, and the maximum instance of the resources demanded by the processes. A state of a system recorded at some random time is shown below. Resources Assigned Process Type 1 Type 2 Type 3 Type 4 A 3 0 2 2 B 0 0 1 1 C 1 1 1 0 D 2 1 4 0 Resources still needed Process Type 1 Type 2 Type 3 Type 4 A 1 1 0 0 B 0 1 1 2 C 1 2 1 0 D 2 1 1 2

E = (7 6 8 4) P = (6 2 8 3) A = (1 4 0 1)

Above tables and vector E, P and A describes the resource allocation state of a system. There are 4 processes and 4 types of the resources in a system. Table 1 shows the instances of each resource assigned to each process. Table 2 shows the instances of the resources, each process still needs. Vector E is the representation of total instances of each resource in the system. Vector P represents the instances of resources that have been assigned to processes. Vector A represents the number of resources that are not in use. A state of the system is called safe if the system can allocate all the resources requested by all the processes without entering into deadlock. If the system cannot fulfill the request of all processes then the state of the system is called unsafe. The key of Deadlock avoidance approach is when the request is made for resources then the request must only be approved in the case if the resulting state is also a safe state.

Next Topic Resource Allocation Graph



← prev next →



"
221,"next → ← prev Resource Allocation Graph The resource allocation graph is the pictorial representation of the state of a system. As its name suggests, the resource allocation graph is the complete information about all the processes which are holding some resources or waiting for some resources. It also contains the information about all the instances of all the resources whether they are available or being used by the processes. In Resource allocation graph, the process is represented by a Circle while the Resource is represented by a rectangle. Let's see the types of vertices and edges in detail.



Vertices are mainly of two types, Resource and process. Each of them will be represented by a different shape. Circle represents process while rectangle represents resource. A resource can have more than one instance. Each instance will be represented by a dot inside the rectangle.



Edges in RAG are also of two types, one represents assignment and other represents the wait of a process for a resource. The above image shows each of them. A resource is shown as assigned to a process if the tail of the arrow is attached to an instance to the resource and the head is attached to a process. A process is shown as waiting for a resource if the tail of an arrow is attached to the process while the head is pointing towards the resource.



Example Let'sconsider 3 processes P1, P2 and P3, and two types of resources R1 and R2. The resources are having 1 instance each. According to the graph, R1 is being used by P1, P2 is holding R2 and waiting for R1, P3 is waiting for R1 as well as R2. The graph is deadlock free since no cycle is being formed in the graph.



Next Topic Deadlock Detection using RAG



← prev next →



"
222,"next → ← prev Deadlock Detection using RAG If a cycle is being formed in a Resource allocation graph where all the resources have the single instance then the system is deadlocked. In Case of Resource allocation graph with multi-instanced resource types, Cycle is a necessary condition of deadlock but not the sufficient condition. The following example contains three processes P1, P2, P3 and three resources R2, R2, R3. All the resources are having single instances each.



If we analyze the graph then we can find out that there is a cycle formed in the graph since the system is satisfying all the four conditions of deadlock. Allocation Matrix Allocation matrix can be formed by using the Resource allocation graph of a system. In Allocation matrix, an entry will be made for each of the resource assigned. For Example, in the following matrix, en entry is being made in front of P1 and below R3 since R3 is assigned to P1. Process R1 R2 R3 P1 0 0 1 P2 1 0 0 P3 0 1 0 Request Matrix In request matrix, an entry will be made for each of the resource requested. As in the following example, P1 needs R1 therefore an entry is being made in front of P1 and below R1. Process R1 R2 R3 P1 1 0 0 P2 0 1 0 P3 0 0 1 Avial = (0,0,0) Neither we are having any resource available in the system nor a process going to release. Each of the process needs at least single resource to complete therefore they will continuously be holding each one of them. We cannot fulfill the demand of at least one process using the available resources therefore the system is deadlocked as determined earlier when we detected a cycle in the graph.

Next Topic Deadlock Detection and Recovery



← prev next →



"
223,"next → ← prev Deadlock Detection and Recovery In this approach, The OS doesn't apply any mechanism to avoid or prevent the deadlocks. Therefore the system considers that the deadlock will definitely occur. In order to get rid of deadlocks, The OS periodically checks the system for any deadlock. In case, it finds any of the deadlock then the OS will recover the system using some recovery techniques. The main task of the OS is detecting the deadlocks. The OS can detect the deadlocks with the help of Resource allocation graph.



In single instanced resource types, if a cycle is being formed in the system then there will definitely be a deadlock. On the other hand, in multiple instanced resource type graph, detecting a cycle is not just enough. We have to apply the safety algorithm on the system by converting the resource allocation graph into the allocation matrix and request matrix. In order to recover the system from deadlocks, either OS considers resources or processes. For Resource

Preempt the resource We can snatch one of the resources from the owner of the resource (process) and give it to the other process with the expectation that it will complete the execution and will release this resource sooner. Well, choosing a resource which will be snatched is going to be a bit difficult. Rollback to a safe state System passes through various states to get into the deadlock state. The operating system canrollback the system to the previous safe state. For this purpose, OS needs to implement check pointing at every state. The moment, we get into deadlock, we will rollback all the allocations to get into the previous safe state. For Process

Kill a process Killing a process can solve our problem but the bigger concern is to decide which process to kill. Generally, Operating system kills a process which has done least amount of work until now. Kill all process This is not a suggestible approach but can be implemented if the problem becomes very serious. Killing all process will lead to inefficiency in the system because all the processes will execute again from starting.



Next Topic Memory Management Introduction



← prev next →



"
224,"next → ← prev What is Memory? Computer memory can be defined as a collection of some data represented in the binary format. On the basis of various functions, memory can be classified into various categories. We will discuss each one of them later in detail. A computer device that is capable to store any information or data temporally or permanently, is called storage device. How Data is being stored in a computer system? In order to understand memory management, we have to make everything clear about how data is being stored in a computer system. Machine understands only binary language that is 0 or 1. Computer converts every data into binary language first and then stores it into the memory. That means if we have a program line written as int α = 10 then the computer converts it into the binary language and then store it into the memory blocks. The representation of inti = 10 is shown below.



The binary representation of 10 is 1010. Here, we are considering 32 bit system therefore, the size of int is 2 bytes i.e. 16 bit. 1 memory block stores 1 bit. If we are using signed integer then the most significant bit in the memory array is always a signed bit. Signed bit value 0 represents positive integer while 1 represents negative integer. Here, the range of values that can be stored using the memory array is -32768 to +32767. well, we can enlarge this range by using unsigned int. in that case, the bit which is now storing the sign will also store the bit value and therefore the range will be 0 to 65,535. Need for Multi programming However, The CPU can directly access the main memory, Registers and cache of the system. The program always executes in main memory. The size of main memory affects degree of Multi programming to most of the extant. If the size of the main memory is larger than CPU can load more processes in the main memory at the same time and therefore will increase degree of Multi programming as well as CPU utilization. Let's consider, Process Size = 4 MB Main memory size = 4 MB The process can only reside in the main memory at any time. If the time for which the process does IO is P, Then, CPU utilization = (1-P) let's say, P = 70% CPU utilization = 30 % Now, increase the memory size, Let's say it is 8 MB. Process Size = 4 MB Two processes can reside in the main memory at the same time. Let's say the time for which, one process does its IO is P, Then CPU utilization = (1-P^2) let's say P = 70 % CPU utilization = (1-0.49) =0.51 = 51 % Therefore, we can state that the CPU utilization will be increased if the memory size gets increased.

Next Topic Fixed Partitioning



← prev next →



"
225,"next → ← prev Fixed Partitioning The earliest and one of the simplest technique which can be used to load more than one processes into the main memory is Fixed partitioning or Contiguous memory allocation. In this technique, the main memory is divided into partitions of equal or different sizes. The operating system always resides in the first partition while the other partitions can be used to store user processes. The memory is assigned to the processes in contiguous way. In fixed partitioning, The partitions cannot overlap. A process must be contiguously present in a partition for the execution. There are various cons of using this technique. 1. Internal Fragmentation If the size of the process is lesser then the total size of the partition then some size of the partition get wasted and remain unused. This is wastage of the memory and called internal fragmentation. As shown in the image below, the 4 MB partition is used to load only 3 MB process and the remaining 1 MB got wasted. 2. External Fragmentation The total unused space of various partitions cannot be used to load the processes even though there is space available but not in the contiguous form. As shown in the image below, the remaining 1 MB space of each partition cannot be used as a unit to store a 4 MB process. Despite of the fact that the sufficient space is available to load the process, process will not be loaded. 3. Limitation on the size of the process If the process size is larger than the size of maximum sized partition then that process cannot be loaded into the memory. Therefore, a limitation can be imposed on the process size that is it cannot be larger than the size of the largest partition. 4. Degree of multiprogramming is less By Degree of multi programming, we simply mean the maximum number of processes that can be loaded into the memory at the same time. In fixed partitioning, the degree of multiprogramming is fixed and very less due to the fact that the size of the partition cannot be varied according to the size of processes.



Next Topic Dynamic Partitioning



← prev next →



"
226,"next → ← prev Dynamic Partitioning Dynamic partitioning tries to overcome the problems caused by fixed partitioning. In this technique, the partition size is not declared initially. It is declared at the time of process loading. The first partition is reserved for the operating system. The remaining space is divided into parts. The size of each partition will be equal to the size of the process. The partition size varies according to the need of the process so that the internal fragmentation can be avoided.



Advantages of Dynamic Partitioning over fixed partitioning

1. No Internal Fragmentation Given the fact that the partitions in dynamic partitioning are created according to the need of the process, It is clear that there will not be any internal fragmentation because there will not be any unused remaining space in the partition. 2. No Limitation on the size of the process In Fixed partitioning, the process with the size greater than the size of the largest partition could not be executed due to the lack of sufficient contiguous memory. Here, In Dynamic partitioning, the process size can't be restricted since the partition size is decided according to the process size. 3. Degree of multiprogramming is dynamic Due to the absence of internal fragmentation, there will not be any unused space in the partition hence more processes can be loaded in the memory at the same time. Disadvantages of dynamic partitioning

External Fragmentation Absence of internal fragmentation doesn't mean that there will not be external fragmentation. Let's consider three processes P1 (1 MB) and P2 (3 MB) and P3 (1 MB) are being loaded in the respective partitions of the main memory. After some time P1 and P3 got completed and their assigned space is freed. Now there are two unused partitions (1 MB and 1 MB) available in the main memory but they cannot be used to load a 2 MB process in the memory since they are not contiguously located. The rule says that the process must be contiguously present in the main memory to get executed. We need to change this rule to avoid external fragmentation.



Complex Memory Allocation In Fixed partitioning, the list of partitions is made once and will never change but in dynamic partitioning, the allocation and deallocation is very complex since the partition size will be varied every time when it is assigned to a new process. OS has to keep track of all the partitions. Due to the fact that the allocation and deallocation are done very frequently in dynamic memory allocation and the partition size will be changed at each time, it is going to be very difficult for OS to manage everything.

Next Topic Compaction



← prev next →



"
227,"next → ← prev Compaction We got to know that the dynamic partitioning suffers from external fragmentation. However, this can cause some serious problems. To avoid compaction, we need to change the rule which says that the process can't be stored in the different places in the memory. We can also use compaction to minimize the probability of external fragmentation. In compaction, all the free partitions are made contiguous and all the loaded partitions are brought together. By applying this technique, we can store the bigger processes in the memory. The free partitions are merged which can now be allocated according to the needs of new processes. This technique is also called defragmentation.



As shown in the image above, the process P5, which could not be loaded into the memory due to the lack of contiguous space, can be loaded now in the memory since the free partitions are made contiguous. Problem with Compaction The efficiency of the system is decreased in the case of compaction due to the fact that all the free spaces will be transferred from several places to a single place. Huge amount of time is invested for this procedure and the CPU will remain idle for all this time. Despite of the fact that the compaction avoids external fragmentation, it makes system inefficient. Let us consider that OS needs 6 NS to copy 1 byte from one place to another. 1 B transfer needs 6 NS 256 MB transfer needs 256 X 2^20 X 6 X 10 ^ -9 secs hence, it is proved to some extent that the larger size memory transfer needs some huge amount of time that is in seconds.

Next Topic Bit Map for Dynamic Partitioning



← prev next →



"
228,"next → ← prev Bit Map for Dynamic Partitioning The Main concern for dynamic partitioning is keeping track of all the free and allocated partitions. However, the Operating system uses following data structures for this task. Bit Map Linked List Bit Map is the least famous data structure to store the details. In this scheme, the main memory is divided into the collection of allocation units. One or more allocation units may be allocated to a process according to the need of that process. However, the size of the allocation unit is fixed that is defined by the Operating System and never changed. Although the partition size may vary but the allocation size is fixed. The main task of the operating system is to keep track of whether the partition is free or filled. For this purpose, the operating system also manages another data structure that is called bitmap. The process or the hole in Allocation units is represented by a flag bit of bitmap. In the image shown below, a flag bit is defined for every bit of allocation units. However, it is not the general case, it depends on the OS that, for how many bits of the allocation units, it wants to store the flag bit. The flag bit is set to 1 if there is a contiguously present process at the adjacent bit in allocation unit otherwise it is set to 0. A string of 0s in the bitmap shows that there is a hole in the relative Allocation unit while the string of 1s represents the process in the relative allocation unit.

Disadvantages of using Bitmap 1. The OS has to assign some memory for bitmap as well since it stores the details about allocation units. That much amount of memory cannot be used to load any process therefore that decreases the degree of multiprogramming as well as throughput. In the above image, The allocation unit is of 4 bits that is 0.5 bits. Here, 1 bit of the bitmap is representing 1 bit of allocation unit. Size of 1 allocation unit = 4 bits Size of bitmap = 1/(4+1) = 1/5 of total main memory. Therefore, in this bitmap configuration, 1/5 of total main memory is wasted. 2. To identify any hole in the memory, the OS need to search the string of 0s in the bitmap. This searching takes a huge amount of time which makes the system inefficient to some extent

Next Topic Linked List for Dynamic Partitioning



← prev next →



"
229,"next → ← prev Linked List for Dynamic Partitioning The better and the most popular approach to keep track the free or filled partitions is using Linked List. In this approach, the Operating system maintains a linked list where each node represents each partition. Every node has three fields. First field of the node stores a flag bit which shows whether the partition is a hole or some process is inside. Second field stores the starting index of the partition. Third filed stores the end index of the partition. If a partition is freed at some point of time then that partition will be merged with its adjacent free partition without doing any extra effort. There are some points which need to be focused while using this approach. The OS must be very clear about the location of the new node which is to be added in the linked list. However, adding the node according to the increasing order of starting index is suggestible. Using a doubly linked list will make some positive effects on the performance due to the fact that a node in the doubly link list can also keep track of its previous node.



Next Topic Partitioning Algorithms



← prev next →



"
230,"next → ← prev Partitioning Algorithms There are various algorithms which are implemented by the Operating System in order to find out the holes in the linked list and allocate them to the processes. The explanation about each of the algorithm is given below. 1. First Fit Algorithm First Fit algorithm scans the linked list and whenever it finds the first big enough hole to store a process, it stops scanning and load the process into that hole. This procedure produces two partitions. Out of them, one partition will be a hole while the other partition will store the process. First Fit algorithm maintains the linked list according to the increasing order of starting index. This is the simplest to implement among all the algorithms and produces bigger holes as compare to the other algorithms. 2. Next Fit Algorithm Next Fit algorithm is similar to First Fit algorithm except the fact that, Next fit scans the linked list from the node where it previously allocated a hole. Next fit doesn't scan the whole list, it starts scanning the list from the next node. The idea behind the next fit is the fact that the list has been scanned once therefore the probability of finding the hole is larger in the remaining part of the list. Experiments over the algorithm have shown that the next fit is not better then the first fit. So it is not being used these days in most of the cases. 3. Best Fit Algorithm The Best Fit algorithm tries to find out the smallest hole possible in the list that can accommodate the size requirement of the process. Using Best Fit has some disadvantages. 1. It is slower because it scans the entire list every time and tries to find out the smallest hole which can satisfy the requirement the process. Due to the fact that the difference between the whole size and the process size is very small, the holes produced will be as small as it cannot be used to load any process and therefore it remains useless.

Despite of the fact that the name of the algorithm is best fit, It is not the best algorithm among all. 4. Worst Fit Algorithm The worst fit algorithm scans the entire list every time and tries to find out the biggest hole in the list which can fulfill the requirement of the process. Despite of the fact that this algorithm produces the larger holes to load the other processes, this is not the better approach due to the fact that it is slower because it searches the entire list every time again and again. 5. Quick Fit Algorithm The quick fit algorithm suggestsmaintaining the different lists of frequently used sizes. Although, it is not practically suggestible because the procedure takes so much time to create the different lists and then expending the holes to load a process. The first fit algorithm is the best algorithm among all because It takes lesser time compare to the other algorithms. It produces bigger holes that can be used to load other processes later on. It is easiest to implement.

Next Topic GATE Question on Best Fit and First Fit



← prev next →



"
231,"next → ← prev GATE question on best fit and first fit From the GATE point of view, Numerical on best fit and first fit are being asked frequently in 1 mark. Let's have a look on the one given as below. Q. Process requests are given as; 25 K , 50 K , 100 K , 75 K



Determine the algorithm which can optimally satisfy this requirement. First Fit algorithm Best Fit Algorithm Neither of the two Both of them In the question, there are five partitions in the memory. 3 partitions are having processes inside them and two partitions are holes. Our task is to check the algorithm which can satisfy the request optimally. Using First Fit algorithm Let's see, how first fit algorithm works on this problem. 1. 25 K requirement The algorithm scans the list until it gets first hole which should be big enough to satisfy the request of 25 K. it gets the space in the second partition which is free hence it allocates 25 K out of 75 K to the process and the remaining 50 K is produced as hole.



2. 50 K requirement The 50 K requirement can be fulfilled by allocating the third partition which is 50 K in size to the process. No free space is produced as free space.



3. 100 K requirement 100 K requirement can be fulfilled by using the fifth partition of 175 K size. Out of 175 K, 100 K will be allocated and remaining 75 K will be there as a hole.



4. 75 K requirement Since we are having a 75 K free partition hence we can allocate that much space to the process which is demanding just 75 K space.



Using first fit algorithm, we have fulfilled the entire request optimally and no useless space is remaining. Let's see, How Best Fit algorithm performs for the problem. Using Best Fit Algorithm 1. 25 K requirement To allocate 25 K space using best fit approach, need to scan the whole list and then we find that a 75 K partition is free and the smallest among all, which can accommodate the need of the process. Therefore 25 K out of those 75 K free partition is allocated to the process and the remaining 5o K is produced as a hole.



2. 50 K requirement To satisfy this need, we will again scan the whole list and then find the 50 K space is free which the exact match of the need is. Therefore, it will be allocated for the process.



3. 100 K requirement 100 K need is close enough to the 175 K space. The algorithm scans the whole list and then allocates 100 K out of 175 K from the 5th free partition.



4. 75 K requirement 75 K requirement will get the space of 75 K from the 6th free partition but the algorithm will scan the whole list in the process of taking this decision.



By following both of the algorithms, we have noticed that both the algorithms perform similar to most of the extant in this case. Both can satisfy the need of the processes but however, the best fit algorithm scans the list again and again which takes lot of time. Therefore, if you ask me that which algorithm performs in more optimal way then it will be First Fit algorithm for sure. Therefore, the answer in this case is A.

Next Topic Need for Paging



← prev next →



"
232,"next → ← prev Need for Paging Disadvantage of Dynamic Partitioning The main disadvantage of Dynamic Partitioning is External fragmentation. Although, this can be removed by Compaction but as we have discussed earlier, the compaction makes the system inefficient. We need to find out a mechanism which can load the processes in the partitions in a more optimal way. Let us discuss a dynamic and flexible mechanism called paging. Need for Paging Lets consider a process P1 of size 2 MB and the main memory which is divided into three partitions. Out of the three partitions, two partitions are holes of size 1 MB each. P1 needs 2 MB space in the main memory to be loaded. We have two holes of 1 MB each but they are not contiguous. Although, there is 2 MB space available in the main memory in the form of those holes but that remains useless until it become contiguous. This is a serious problem to address. We need to have some kind of mechanism which can store one process at different locations of the memory. The Idea behind paging is to divide the process in pages so that, we can store them in the memory at different holes. We will discuss paging with the examples in the next sections.



Next Topic Paging with Example



← prev next →



"
233,"next → ← prev Paging with Example In Operating Systems, Paging is a storage mechanism used to retrieve processes from the secondary storage into the main memory in the form of pages. The main idea behind the paging is to divide each process in the form of pages. The main memory will also be divided in the form of frames. One page of the process is to be stored in one of the frames of the memory. The pages can be stored at the different locations of the memory but the priority is always to find the contiguous frames or holes. Pages of the process are brought into the main memory only when they are required otherwise they reside in the secondary storage. Different operating system defines different frame sizes. The sizes of each frame must be equal. Considering the fact that the pages are mapped to the frames in Paging, page size needs to be as same as frame size.



Example Let us consider the main memory size 16 Kb and Frame size is 1 KB therefore the main memory will be divided into the collection of 16 frames of 1 KB each. There are 4 processes in the system that is P1, P2, P3 and P4 of 4 KB each. Each process is divided into pages of 1 KB each so that one page can be stored in one frame. Initially, all the frames are empty therefore pages of the processes will get stored in the contiguous way. Frames, pages and the mapping between the two is shown in the image below.



Let us consider that, P2 and P4 are moved to waiting state after some time. Now, 8 frames become empty and therefore other pages can be loaded in that empty place. The process P5 of size 8 KB (8 pages) is waiting inside the ready queue. Given the fact that, we have 8 non contiguous frames available in the memory and paging provides the flexibility of storing the process at the different places. Therefore, we can load the pages of process P5 in the place of P2 and P4.



Memory Management Unit The purpose of Memory Management Unit (MMU) is to convert the logical address into the physical address. The logical address is the address generated by the CPU for every page while the physical address is the actual address of the frame where each page will be stored. When a page is to be accessed by the CPU by using the logical address, the operating system needs to obtain the physical address to access that page physically. The logical address has two parts. Page Number Offset Memory management unit of OS needs to convert the page number to the frame number. Example Considering the above image, let's say that the CPU demands 10th word of 4th page of process P3. Since the page number 4 of process P1 gets stored at frame number 9 therefore the 10th word of 9th frame will be returned as the physical address.

Next Topic Basics of Binary Addresses



← prev next →



"
234,"Basics of Binary Addresses

Computer system assigns the binary addresses to the memory locations. However, The system uses amount of bits to address a memory location.

Using 1 bit, we can address two memory locations. Using 2 bits we can address 4 and using 3 bits we can address 8 memory locations.

A pattern can be identified in the mapping between the number of bits in the address and the range of the memory locations.

We know,

Using 1 Bit we can represent 2^1 i.e 2 memory locations. Using 2 bits, we can represent 2^2 i.e. 4 memory locations. Using 3 bits, we can represent 2^3 i.e. 8 memory locations. Therefore, if we generalize this, Using n bits, we can assign 2^n memory locations. n bits of address → 2 ^ n memory locations

these n bits can be divided into two parts, that are, K bits and (n-k) bits."
235,"Physical and Logical Address Space

Physical Address Space

Physical address space in a system can be defined as the size of the main memory. It is really important to compare the process size with the physical address space. The process size must be less than the physical address space.

Physical Address Space = Size of the Main Memory



If, physical address space = 64 KB = 2 ^ 6 KB = 2 ^ 6 X 2 ^ 10 Bytes = 2 ^ 16 bytes



Let us consider,

word size = 8 Bytes = 2 ^ 3 Bytes



Hence,

Physical address space (in words) = (2 ^ 16) / (2 ^ 3) = 2 ^ 13 Words



Therefore,

Physical Address = 13 bits



In General,

If, Physical Address Space = N Words



then, Physical Address = log 2 N



Logical Address Space

Logical address space can be defined as the size of the process. The size of the process should be less enough so that it can reside in the main memory.

Let's say,

Logical Address Space = 128 MB = (2 ^ 7 X 2 ^ 20) Bytes = 2 ^ 27 Bytes

Word size = 4 Bytes = 2 ^ 2 Bytes



Logical Address Space (in words) = (2 ^ 27) / (2 ^ 2) = 2 ^ 25 Words

Logical Address = 25 Bits



In general,

If, logical address space = L words

Then, Logical Address = Log 2 L bits



What is a Word?

The Word is the smallest unit of the memory. It is the collection of bytes. Every operating system defines different word sizes after analyzing the n-bit address that is inputted to the decoder and the 2 ^ n memory locations that are produced from the decoder."
236,"Page Table

Page Table is a data structure used by the virtual memory system to store the mapping between logical addresses and physical addresses.

Logical addresses are generated by the CPU for the pages of the processes therefore they are generally used by the processes.

Physical addresses are the actual frame address of the memory. They are generally used by the hardware or more specifically by RAM subsystems.

The image given below considers,

Physical Address Space = M words

Logical Address Space = L words

Page Size = P words



Physical Address = log 2 M = m bits

Logical Address = log 2 L = l bits

page offset = log 2 P = p bits



The CPU always accesses the processes through their logical addresses. However, the main memory recognizes physical address only.

In this situation, a unit named as Memory Management Unit comes into the picture. It converts the page number of the logical address to the frame number of the physical address. The offset remains same in both the addresses.

To perform this task, Memory Management unit needs a special kind of mapping which is done by page table. The page table stores all the Frame numbers corresponding to the page numbers of the page table.

In other words, the page table maps the page number to its actual location (frame number) in the memory.

In the image given below shows, how the required word of the frame is accessed with the help of offset."
237,"Mapping from page table to main memory

In operating systems, there is always a requirement of mapping from logical address to the physical address. However, this process involves various steps which are defined as follows.

1. Generation of logical address

CPU generates logical address for each page of the process. This contains two parts: page number and offset.

2. Scaling

To determine the actual page number of the process, CPU stores the page table base in a special register. Each time the address is generated, the value of the page table base is added to the page number to get the actual location of the page entry in the table. This process is called scaling.

3. Generation of physical Address

The frame number of the desired page is determined by its entry in the page table. A physical address is generated which also contains two parts : frame number and offset. The Offset will be similar to the offset of the logical address therefore it will be copied from the logical address.

4. Getting Actual Frame Number

The frame number and the offset from the physical address is mapped to the main memory in order to get the actual word address."
238,"next → ← prev Page Table Entry Along with page frame number, the page table also contains some of the bits representing the extra information regarding the page. Let's see what the each bit represents about the page. 1. Caching Disabled Sometimes, there are differences between the information closest to the CPU and the information closest to the user. Operating system always wants CPU to access user's data as soon as possible. CPU accesses cache which can be inaccurate in some of the cases, therefore, OS can disable the cache for the required pages. This bit is set to 1 if the cache is disabled. 2. Referenced There are variouspage replacement algorithms which will be covered later in this tutorial. This bit is set to 1 if the page is referred in the last clock cycle otherwise it remains 0. 3. Modified This bit will be set if the page has been modified otherwise it remains 0. 4. Protection The protection field represents the protection level which is applied on the page. It can be read only or read & write or execute. We need to remember that it is not a bit rather it is a field which contains many bits. 5. Present/Absent In the concept of demand paging, all the pages doesn't need to be present in the main memory Therefore, for all the pages that are present in the main memory, this bit will be set to 1 and the bit will be 0 for all the pages which are absent. If some page is not present in the main memory then it is called page fault.



Next Topic Page Table Size



← prev next →



"
239,"next → ← prev Size of the page table However, the part of the process which is being executed by the CPU must be present in the main memory during that time period. The page table must also be present in the main memory all the time because it has the entry for all the pages. The size of the page table depends upon the number of entries in the table and the bytes stored in one entry. Let's consider, Logical Address = 24 bits Logical Address space = 2 ^ 24 bytes Let's say, Page size = 4 KB = 2 ^ 12 Bytes Page offset = 12 Number of bits in a page = Logical Address - Page Offset = 24 - 12 = 12 bits Number of pages = 2 ^ 12 = 2 X 2 X 10 ^ 10 = 4 KB Let's say, Page table entry = 1 Byte Therefore, the size of the page table = 4 KB X 1 Byte = 4 KB Here we are lucky enough to get the page table size equal to the frame size. Now, the page table will be simply stored in one of the frames of the main memory. The CPU maintains a register which contains the base address of that frame, every page number from the logical address will first be added to that base address so that we can access the actual location of the word being asked. However, in some cases, the page table size and the frame size might not be same. In those cases, the page table is considered as the collection of frames and will be stored in the different frames.

Next Topic Finding Optimal Page Size



← prev next →



"
240,"next → ← prev Finding Optimal Page Size We have seen that the bigger page table size cause an extra overhead because we have to divide that table into the pages and then store that into the main memory. Our concern must be about executing processes not on the execution of page table. Page table provides a support for the execution of the process. The larger the page Table, the higher the overhead. We know that, Page Table Size = number of page entries in page table X size of one page entry Let's consider an example, Virtual Address Space = 2 GB = 2 X 2 ^ 30 Bytes Page Size = 2 KB = 2 X 2 ^ 10 Bytes Number of Pages in Page Table = (2 X 2 ^ 30)/(2 X 2 ^ 10) = 1 M pages There will be 1 million pages which is quite big number. However, try to make page size larger, say 2 MB. Then, Number of pages in page table = (2 X 2 ^ 30)/(2 X 2 ^ 20) = 1 K pages. If we compare the two scenarios, we can find out that the page table size is anti proportional to Page Size. In Paging, there is always wastage on the last page. If the virtual address space is not a multiple of page size, then there will be some bytes remaining and we have to assign a full page to those many bytes. This is simply a overhead. Let's consider, Page Size = 2 KB Virtual Address Space = 17 KB Then number of pages = 17 KB / 2 KB The number of pages will be 9 although the 9th page will only contain 1 byte and the remaining page will be wasted. In general, If page size = p bytes Entry size = e bytes Virtual Address Space = S bytes Then, overhead O = (S/p) X e + (p/2) On an average, the wasted number of pages in a virtual space is p/2(the half of total number of pages). For, the minimal overhead, ∂O/∂p = 0 -S/(p^2) + ½ = 0 p = √ (2.S.e) bytes Hence, if the page size √(2.S.e) bytes then the overhead will be minimal.

Next Topic Virtual Memory



← prev next →



"
241,"next → ← prev Virtual Memory Virtual Memory is a storage scheme that provides user an illusion of having a very big main memory. This is done by treating a part of secondary memory as the main memory. In this scheme, User can load the bigger size processes than the available main memory by having the illusion that the memory is available to load the process. Instead of loading one big process in the main memory, the Operating System loads the different parts of more than one process in the main memory. By doing this, the degree of multiprogramming will be increased and therefore, the CPU utilization will also be increased. How Virtual Memory Works? In modern word, virtual memory has become quite common these days. In this scheme, whenever some pages needs to be loaded in the main memory for the execution and the memory is not available for those many pages, then in that case, instead of stopping the pages from entering in the main memory, the OS search for the RAM area that are least used in the recent times or that are not referenced and copy that into the secondary memory to make the space for the new pages in the main memory. Since all this procedure happens automatically, therefore it makes the computer feel like it is having the unlimited RAM. Demand Paging Demand Paging is a popular method of virtual memory management. In demand paging, the pages of a process which are least used, get stored in the secondary memory. A page is copied to the main memory when its demand is made or page fault occurs. There are various page replacement algorithms which are used to determine the pages which will be replaced. We will discuss each one of them later in detail. Snapshot of a virtual memory management system Let us assume 2 processes, P1 and P2, contains 4 pages each. Each page size is 1 KB. The main memory contains 8 frame of 1 KB each. The OS resides in the first two partitions. In the third partition, 1st page of P1 is stored and the other frames are also shown as filled with the different pages of processes in the main memory. The page tables of both the pages are 1 KB size each and therefore they can be fit in one frame each. The page tables of both the processes contain various information that is also shown in the image. The CPU contains a register which contains the base address of page table that is 5 in the case of P1 and 7 in the case of P2. This page table base address will be added to the page number of the Logical address when it comes to accessing the actual corresponding entry.



Advantages of Virtual Memory The degree of Multiprogramming will be increased. User can run large application with less real RAM. There is no need to buy more memory RAMs. Disadvantages of Virtual Memory The system becomes slower since swapping takes time. It takes more time in switching between applications. The user will have the lesser hard disk space for its use.

Next Topic Translation Look aside Buffer



← prev next →



"
242,"next → ← prev Translation Look aside buffer Drawbacks of Paging Size of Page table can be very big and therefore it wastes main memory. CPU will take more time to read a single word from the main memory. How to decrease the page table size The page table size can be decreased by increasing the page size but it will cause internal fragmentation and there will also be page wastage. Other way is to use multilevel paging but that increases the effective access time therefore this is not a practical approach. How to decrease the effective access time CPU can use a register having the page table stored inside it so that the access time to access page table can become quite less but the register are not cheaper and they are very small in compare to the page table size therefore, this is also not a practical approach. To overcome these many drawbacks in paging, we have to look for a memory that is cheaper than the register and faster than the main memory so that the time taken by the CPU to access page table again and again can be reduced and it can only focus to access the actual word. Locality of reference In operating systems, the concept of locality of reference states that, instead of loading the entire process in the main memory, OS can load only those number of pages in the main memory that are frequently accessed by the CPU and along with that, the OS can also load only those page table entries which are corresponding to those many pages. Translation look aside buffer (TLB) A Translation look aside buffer can be defined as a memory cache which can be used to reduce the time taken to access the page table again and again. It is a memory cache which is closer to the CPU and the time taken by CPU to access TLB is lesser then that taken to access main memory. In other words, we can say that TLB is faster and smaller than the main memory but cheaper and bigger than the register. TLB follows the concept of locality of reference which means that it contains only the entries of those many pages that are frequently accessed by the CPU.



In translation look aside buffers, there are tags and keys with the help of which, the mapping is done. TLB hit is a condition where the desired entry is found in translation look aside buffer. If this happens then the CPU simply access the actual location in the main memory. However, if the entry is not found in TLB (TLB miss) then CPU has to access page table in the main memory and then access the actual frame in the main memory. Therefore, in the case of TLB hit, the effective access time will be lesser as compare to the case of TLB miss. If the probability of TLB hit is P% (TLB hit rate) then the probability of TLB miss (TLB miss rate) will be (1-P) %. Therefore, the effective access time can be defined as; EAT = P (t + m) + (1 - p) (t + k.m + m) Where, p → TLB hit rate, t → time taken to access TLB, m → time taken to access main memory k = 1, if the single level paging has been implemented. By the formula, we come to know that Effective access time will be decreased if the TLB hit rate is increased. Effective access time will be increased in the case of multilevel paging.

Next Topic GATE 2014 question on TLB



← prev next →



"
243,"GATE Question on TLB

GATE | GATE-CS-2014-(Set-3)

Consider a paging hardware with a TLB. Assume that the entire page table and all the pages are in the physical memory. It takes 10 milliseconds to search the TLB and 80 milliseconds to access the physical memory. If the TLB hit ratio is 0.6, the effective memory access time (in milliseconds) is _________.

A. 120

B. 122

C. 124

D. 118

Given,

TLB hit ratio = 0.6 Therefore, TLB miss ratio = 0.4 Time taken to access TLB (t) = 10 ms Time taken to access main memory (m) = 80 ms

Effective Access Time (EAT) = 0.6 ( 10 + 80 ) + 0.4 ( 10 + 80 + 80 ) = 90 X 0.6 + 0.4 X 170 = 122

Hence, the right answer is option B."
244,"next → ← prev Demand Paging According to the concept of Virtual Memory, in order to execute some process, only a part of the process needs to be present in the main memory which means that only a few pages will only be present in the main memory at any time. However, deciding, which pages need to be kept in the main memory and which need to be kept in the secondary memory, is going to be difficult because we cannot say in advance that a process will require a particular page at particular time. Therefore, to overcome this problem, there is a concept called Demand Paging is introduced. It suggests keeping all pages of the frames in the secondary memory until they are required. In other words, it says that do not load any page in the main memory until it is required. Whenever any page is referred for the first time in the main memory, then that page will be found in the secondary memory. After that, it may or may not be present in the main memory depending upon the page replacement algorithm which will be covered later in this tutorial. What is a Page Fault? If the referred page is not present in the main memory then there will be a miss and the concept is called Page miss or page fault. The CPU has to access the missed page from the secondary memory. If the number of page fault is very high then the effective access time of the system will become very high. What is Thrashing? If the number of page faults is equal to the number of referred pages or the number of page faults are so high so that the CPU remains busy in just reading the pages from the secondary memory then the effective access time will be the time taken by the CPU to read one word from the secondary memory and it will be so high. The concept is called thrashing. If the page fault rate is PF %, the time taken in getting a page from the secondary memory and again restarting is S (service time) and the memory access time is ma then the effective access time can be given as; EAT = PF X S + (1 - PF) X (ma)

Next Topic Inverted Page Table



← prev next →



"
245,"next → ← prev Inverted Page Table Inverted Page Table is the global page table which is maintained by the Operating System for all the processes. In inverted page table, the number of entries is equal to the number of frames in the main memory. It can be used to overcome the drawbacks of page table. There is always a space reserved for the page regardless of the fact that whether it is present in the main memory or not. However, this is simply the wastage of the memory if the page is not present.



We can save this wastage by just inverting the page table. We can save the details only for the pages which are present in the main memory. Frames are the indices and the information saved inside the block will be Process ID and page number.



Next Topic Page Replacement Algorithms



← prev next →



"
246,"next → ← prev Page Replacement Algorithms The page replacement algorithm decides which memory page is to be replaced. The process of replacement is sometimes called swap out or write to disk. Page replacement is done when the requested page is not found in the main memory (page fault).



There are two main aspects of virtual memory, Frame allocation and Page Replacement. It is very important to have the optimal frame allocation and page replacement algorithm. Frame allocation is all about how many frames are to be allocated to the process while the page replacement is all about determining the page number which needs to be replaced in order to make space for the requested page. What If the algorithm is not optimal? 1. if the number of frames which are allocated to a process is not sufficient or accurate then there can be a problem of thrashing. Due to the lack of frames, most of the pages will be residing in the main memory and therefore more page faults will occur. However, if OS allocates more frames to the process then there can be internal fragmentation. 2. If the page replacement algorithm is not optimal then there will also be the problem of thrashing. If the number of pages that are replaced by the requested pages will be referred in the near future then there will be more number of swap-in and swap-out and therefore the OS has to perform more replacements then usual which causes performance deficiency. Therefore, the task of an optimal page replacement algorithm is to choose the page which can limit the thrashing. Types of Page Replacement Algorithms There are various page replacement algorithms. Each algorithm has a different method by which the pages can be replaced. Optimal Page Replacement algorithm → this algorithms replaces the page which will not be referred for so long in future. Although it can not be practically implementable but it can be used as a benchmark. Other algorithms are compared to this in terms of optimality. Least recent used (LRU) page replacement algorithm → this algorithm replaces the page which has not been referred for a long time. This algorithm is just opposite to the optimal page replacement algorithm. In this, we look at the past instead of staring at future. FIFO → in this algorithm, a queue is maintained. The page which is assigned the frame first will be replaced first. In other words, the page which resides at the rare end of the queue will be replaced on the every page fault.

Next Topic Gate 2015 question on LRU and FIFO



← prev next →



"
247,"next → ← prev GATE 2015 question on LRU and FIFO Q. Consider a main memory with five page frames and the following sequence of page references: 3, 8, 2, 3, 9, 1, 6, 3, 8, 9, 3, 6, 2, 1, 3. which one of the following is true with respect to page replacement policies First-In-First-out (FIFO) and Least Recently Used (LRU)? A. Both incur the same number of page faults

B. FIFO incurs 2 more page faults than LRU

C. LRU incurs 2 more page faults than FIFO

D. FIFO incurs 1 more page faults than LRU Solution: Number of frames = 5 FIFO According to FIFO, the page which first comes in the memory will first goes out.



Number of Page Faults = 9

Number of hits = 6 LRU According to LRU, the page which has not been requested for a long time will get replaced with the new one.



Number of Page Faults = 9

Number of Hits = 6 The Number of page faults in both the cases is equal therefore the Answer is option (A).

Next Topic Numerical on LRU, FIFO and Optimal



← prev next →



"
248,"next → ← prev Numerical on Optimal, LRU and FIFO Q. Consider a reference string: 4, 7, 6, 1, 7, 6, 1, 2, 7, 2. the number of frames in the memory is 3. Find out the number of page faults respective to: Optimal Page Replacement Algorithm FIFO Page Replacement Algorithm LRU Page Replacement Algorithm Optimal Page Replacement Algorithm



Number of Page Faults in Optimal Page Replacement Algorithm = 5 LRU Page Replacement Algorithm



Number of Page Faults in LRU = 6 FIFO Page Replacement Algorithm



Number of Page Faults in FIFO = 6

Next Topic Beladys Anamoly



← prev next →



"
249,"Belady'sAnomaly

In the case of LRU and optimal page replacement algorithms, it is seen that the number of page faults will be reduced if we increase the number of frames. However, Balady found that, In FIFO page replacement algorithm, the number of page faults will get increased with the increment in number of frames.

This is the strange behavior shown by FIFO algorithm in some of the cases. This is an Anomaly called as Belady'sAnomaly.

Let's examine such example :

The reference String is given as 0 1 5 3 0 1 4 0 1 5 3 4. Let's analyze the behavior of FIFO algorithm in two cases.

Case 1: Number of frames = 3

Request 0 1 5 3 0 1 4 0 1 5 3 4 Frame 3 5 5 5 1 1 1 1 1 3 3 Frame 2 1 1 1 0 0 0 0 0 5 5 5 Frame 1 0 0 0 3 3 3 4 4 4 4 4 4 Miss/Hit Miss Miss Miss Miss Miss Miss Miss Hit Hit Miss Miss Hit

Number of Page Faults = 9

Case 2: Number of frames = 4

Request 0 1 5 3 0 1 4 0 1 5 3 4 Frame 4 3 3 3 3 3 3 5 5 5 Frame 3 5 5 5 5 5 5 1 1 1 1 Frame 2 1 1 1 1 1 1 0 0 0 0 4 Frame 1 0 0 0 0 0 0 4 4 4 4 3 3 Miss/Hit Miss Miss Miss Miss Hit Hit Miss Miss Miss Miss Miss Miss

Number of Page Faults = 10

Therefore, in this example, the number of page faults is increasing by increasing the number of frames hence this suffers from Belady'sAnomaly."
250,"next → ← prev Segmentation In Operating Systems, Segmentation is a memory management technique in which, the memory is divided into the variable size parts. Each part is known as segment which can be allocated to a process. The details about each segment are stored in a table called as segment table. Segment table is stored in one (or many) of the segments. Segment table contains mainly two information about segment: Base: It is the base address of the segment Limit: It is the length of the segment. Why Segmentation is required? Till now, we were using Paging as our main memory management technique. Paging is more close to Operating system rather than the User. It divides all the process into the form of pages regardless of the fact that a process can have some relative parts of functions which needs to be loaded in the same page. Operating system doesn't care about the User's view of the process. It may divide the same function into different pages and those pages may or may not be loaded at the same time into the memory. It decreases the efficiency of the system. It is better to have segmentation which divides the process into the segments. Each segment contain same type of functions such as main function can be included in one segment and the library functions can be included in the other segment, Translation of Logical address into physical address by segment table CPU generates a logical address which contains two parts: Segment Number Offset The Segment number is mapped to the segment table. The limit of the respective segment is compared with the offset. If the offset is less than the limit then the address is valid otherwise it throws an error as the address is invalid. In the case of valid address, the base address of the segment is added to the offset to get the physical address of actual word in the main memory.



Advantages of Segmentation No internal fragmentation Average Segment Size is larger than the actual page size. Less overhead It is easier to relocate segments than entire address space. The segment table is of lesser size as compare to the page table in paging. Disadvantages It can have external fragmentation. it is difficult to allocate contiguous memory to variable sized partition. Costly memory management algorithms.

Next Topic Paging VS Segmentation



← prev next →



"
251,"next → ← prev Paging VS Segmentation Sr No. Paging Segmentation 1 Non-Contiguous memory allocation Non-contiguous memory allocation 2 Paging divides program into fixed size pages. Segmentation divides program into variable size segments. 3 OS is responsible Compiler is responsible. 4 Paging is faster than segmentation Segmentation is slower than paging 5 Paging is closer to Operating System Segmentation is closer to User 6 It suffers from internal fragmentation It suffers from external fragmentation 7 There is no external fragmentation There is no external fragmentation 8 Logical address is divided into page number and page offset Logical address is divided into segment number and segment offset 9 Page table is used to maintain the page information. Segment Table maintains the segment information 10 Page table entry has the frame number and some flag bits to represent details about pages. Segment table entry has the base address of the segment and some protection bits for the segments.

Next Topic Segmented Paging



← prev next →



"
252,"next → ← prev Segmented Paging Pure segmentation is not very popular and not being used in many of the operating systems. However, Segmentation can be combined with Paging to get the best features out of both the techniques. In Segmented Paging, the main memory is divided into variable size segments which are further divided into fixed size pages. Pages are smaller than segments. Each Segment has a page table which means every program has multiple page tables. The logical address is represented as Segment Number (base address), Page number and page offset. Segment Number → It points to the appropriate Segment Number. Page Number → It Points to the exact page within the segment Page Offset → Used as an offset within the page frame Each Page table contains the various information about every page of the segment. The Segment Table contains the information about every segment. Each segment table entry points to a page table entry and every page table entry is mapped to one of the page within a segment.



Translation of logical address to physical address The CPU generates a logical address which is divided into two parts: Segment Number and Segment Offset. The Segment Offset must be less than the segment limit. Offset is further divided into Page number and Page Offset. To map the exact page number in the page table, the page number is added into the page table base. The actual frame number with the page offset is mapped to the main memory to get the desired word in the page of the certain segment of the process.



Advantages of Segmented Paging It reduces memory usage. Page table size is limited by the segment size. Segment table has only one entry corresponding to one actual segment. External Fragmentation is not there. It simplifies memory allocation. Disadvantages of Segmented Paging Internal Fragmentation will be there. The complexity level will be much higher as compare to paging. Page Tables need to be contiguously stored in the memory.

Next Topic Attributes of the File



← prev next →



"
253,"next → ← prev What is a File ? A file can be defined as a data structure which stores the sequence of records. Files are stored in a file system, which may exist on a disk or in the main memory. Files can be simple (plain text) or complex (specially-formatted). The collection of files is known as Directory. The collection of directories at the different levels, is known as File System.



Attributes of the File 1.Name Every file carries a name by which the file is recognized in the file system. One directory cannot have two files with the same name. 2.Identifier Along with the name, Each File has its own extension which identifies the type of the file. For example, a text file has the extension .txt, A video file can have the extension .mp4. 3.Type In a File System, the Files are classified in different types such as video files, audio files, text files, executable files, etc. 4.Location In the File System, there are several locations on which, the files can be stored. Each file carries its location as its attribute. 5.Size The Size of the File is one of its most important attribute. By size of the file, we mean the number of bytes acquired by the file in the memory. 6.Protection The Admin of the computer may want the different protections for the different files. Therefore each file carries its own set of permissions to the different group of Users. 7.Time and Date Every file carries a time stamp which contains the time and date on which the file is last modified.

Next Topic Operations on the File



← prev next →



"
254,"next → ← prev Operations on the File There are various operations which can be implemented on a file. We will see all of them in detail. 1.Create Creation of the file is the most important operation on the file. Different types of files are created by different methods for example text editors are used to create a text file, word processors are used to create a word file and Image editors are used to create the image files. 2.Write Writing the file is different from creating the file. The OS maintains a write pointer for every file which points to the position in the file from which, the data needs to be written. 3.Read Every file is opened in three different modes : Read, Write and append. A Read pointer is maintained by the OS, pointing to the position up to which, the data has been read. 4.Re-position Re-positioning is simply moving the file pointers forward or backward depending upon the user's requirement. It is also called as seeking. 5.Delete Deleting the file will not only delete all the data stored inside the file, It also deletes all the attributes of the file. The space which is allocated to the file will now become available and can be allocated to the other files. 6.Truncate Truncating is simply deleting the file except deleting attributes. The file is not completely deleted although the information stored inside the file get replaced.

Next Topic File Access Methods



← prev next →



"
255,"next → ← prev File Access Methods Let's look at various ways to access files stored in secondary memory. Sequential Access



Most of the operating systems access the file sequentially. In other words, we can say that most of the files need to be accessed sequentially by the operating system. In sequential access, the OS read the file word by word. A pointer is maintained which initially points to the base address of the file. If the user wants to read first word of the file then the pointer provides that word to the user and increases its value by 1 word. This process continues till the end of the file. Modern word systems do provide the concept of direct access and indexed access but the most used method is sequential access due to the fact that most of the files such as text files, audio files, video files, etc need to be sequentially accessed. Direct Access The Direct Access is mostly required in the case of database systems. In most of the cases, we need filtered information from the database. The sequential access can be very slow and inefficient in such cases. Suppose every block of the storage stores 4 records and we know that the record we needed is stored in 10th block. In that case, the sequential access will not be implemented because it will traverse all the blocks in order to access the needed record. Direct access will give the required result despite of the fact that the operating system has to perform some complex tasks such as determining the desired block number. However, that is generally implemented in database applications.



Indexed Access If a file can be sorted on any of the filed then an index can be assigned to a group of certain records. However, A particular record can be accessed by its index. The index is nothing but the address of a record in the file. In index accessing, searching in a large database became very quick and easy but we need to have some extra space in the memory to store the index value.

Next Topic Directory Structure



← prev next →



"
256,"Directory Structure

What is a directory?

Directory can be defined as the listing of the related files on the disk. The directory may store some or the entire file attributes.

To get the benefit of different file systems on the different operating systems, A hard disk can be divided into the number of partitions of different sizes. The partitions are also called volumes or mini disks.

Each partition must have at least one directory in which, all the files of the partition can be listed. A directory entry is maintained for each file in the directory which stores all the information related to that file.

A directory can be viewed as a file which contains the Meta data of the bunch of files.

Every Directory supports a number of common operations on the file:

File Creation Search for the file File deletion Renaming the file Traversing Files Listing of files"
257,"next → ← prev Single Level Directory The simplest method is to have one big list of all the files on the disk. The entire system will contain only one directory which is supposed to mention all the files present in the file system. The directory contains one entry per each file present on the file system.



This type of directories can be used for a simple system. Advantages Implementation is very simple. If the sizes of the files are very small then the searching becomes faster. File creation, searching, deletion is very simple since we have only one directory. Disadvantages We cannot have two files with the same name. The directory may be very big therefore searching for a file may take so much time. Protection cannot be implemented for multiple users. There are no ways to group same kind of files. Choosing the unique name for every file is a bit complex and limits the number of files in the system because most of the Operating System limits the number of characters used to construct the file name.

Next Topic Two level Directory



← prev next →



"
258,"next → ← prev Two Level Directory In two level directory systems, we can create a separate directory for each user. There is one master directory which contains separate directories dedicated to each user. For each user, there is a different directory present at the second level, containing group of user's file. The system doesn't let a user to enter in the other user's directory without permission.



Characteristics of two level directory system Each files has a path name as /User-name/directory-name/ Different users can have the same file name. Searching becomes more efficient as only one user's list needs to be traversed. The same kind of files cannot be grouped into a single directory for a particular user. Every Operating System maintains a variable as PWD which contains the present directory name (present user name) so that the searching can be done appropriately.

Next Topic Tree structured Directory



← prev next →



"
259,"next → ← prev Tree Structured Directory In Tree structured directory system, any directory entry can either be a file or sub directory. Tree structured directory system overcomes the drawbacks of two level directory system. The similar kind of files can now be grouped in one directory. Each user has its own directory and it cannot enter in the other user's directory. However, the user has the permission to read the root's data but he cannot write or modify this. Only administrator of the system has the complete access of root directory. Searching is more efficient in this directory structure. The concept of current working directory is used. A file can be accessed by two types of path, either relative or absolute. Absolute path is the path of the file with respect to the root directory of the system while relative path is the path with respect to the current working directory of the system. In tree structured directory systems, the user is given the privilege to create the files as well as directories.



Permissions on the file and directory A tree structured directory system may consist of various levels therefore there is a set of permissions assigned to each file and directory. The permissions are R W X which are regarding reading, writing and the execution of the files or directory. The permissions are assigned to three types of users: owner, group and others. There is a identification bit which differentiate between directory and file. For a directory, it is d and for a file, it is dot (.) The following snapshot shows the permissions assigned to a file in a Linux based system. Initial bit d represents that it is a directory.



Next Topic Acyclic Graph Directories



← prev next →



"
260,"Acyclic-Graph Structured Directories

The tree structured directory system doesn't allow the same file to exist in multiple directories therefore sharing is major concern in tree structured directory system. We can provide sharing by making the directory an acyclic graph. In this system, two or more directory entry can point to the same file or sub directory. That file or sub directory is shared between the two directory entries.

These kinds of directory graphs can be made using links or aliases. We can have multiple paths for a same file. Links can either be symbolic (logical) or hard link (physical).

If a file gets deleted in acyclic graph structured directory system, then

1. In the case of soft link, the file just gets deleted and we are left with a dangling pointer.

2. In the case of hard link, the actual file will be deleted only if all the references to it gets deleted."
261,"next → ← prev File Systems File system is the part of the operating system which is responsible for file management. It provides a mechanism to store the data and access to the file contents including data and programs. Some Operating systems treats everything as a file for example Ubuntu. The File system takes care of the following issues File Structure

We have seen various data structures in which the file can be stored. The task of the file system is to maintain an optimal file structure. Recovering Free space

Whenever a file gets deleted from the hard disk, there is a free space created in the disk. There can be many such spaces which need to be recovered in order to reallocate them to other files. disk space assignment to the files

The major concern about the file is deciding where to store the files on the hard disk. There are various disks scheduling algorithm which will be covered later in this tutorial. tracking data location A File may or may not be stored within only one block. It can be stored in the non contiguous blocks on the disk. We need to keep track of all the blocks on which the part of the files reside.

Next Topic File System Structure



← prev next →



"
262,"next → ← prev File System Structure File System provide efficient access to the disk by allowing data to be stored, located and retrieved in a convenient way. A file System must be able to store the file, locate the file and retrieve the file. Most of the Operating Systems use layering approach for every task including file systems. Every layer of the file system is responsible for some activities. The image shown below, elaborates how the file system is divided in different layers, and also the functionality of each layer.



When an application program asks for a file, the first request is directed to the logical file system. The logical file system contains the Meta data of the file and directory structure. If the application program doesn't have the required permissions of the file then this layer will throw an error. Logical file systems also verify the path to the file.

Generally, files are divided into various logical blocks. Files are to be stored in the hard disk and to be retrieved from the hard disk. Hard disk is divided into various tracks and sectors. Therefore, in order to store and retrieve the files, the logical blocks need to be mapped to physical blocks. This mapping is done by File organization module. It is also responsible for free space management.

Once File organization module decided which physical block the application program needs, it passes this information to basic file system. The basic file system is responsible for issuing the commands to I/O control in order to fetch those blocks.

I/O controls contain the codes by using which it can access hard disk. These codes are known as device drivers. I/O controls are also responsible for handling interrupts.

Next Topic Master Boot Record



← prev next →



"
263,"next → ← prev Master Boot Record (MBR) Master boot record is the information present in the first sector of any hard disk. It contains the information regarding how and where the Operating system is located in the hard disk so that it can be booted in the RAM. MBR is sometimes called master partition table because it includes a partition table which locates every partition in the hard disk. Master boot record (MBR) also includes a program which reads the boot sector record of the partition that contains operating system.



What happens when you turn on your computer? Due to the fact that the main memory is volatile, when we turn on our computer, CPU cannot access the main memory directly. However, there is a special program called as BIOS stored in ROM is accessed for the first time by the CPU. BIOS contains the code, by executing which, the CPU access the very first partition of hard disk that is MBR. It contains a partition table for all the partitions of the hard disk. Since, MBR contains the information about where the operating system is being stored and it also contains a program which can read the boot sector record of the partition, hence the CPU fetches all this information and load the operating system into the main memory.

Next Topic On Disk Data Structures



← prev next →



"
264,"There are various on disk data structures that are used to implement a file system. This structure may vary depending upon the operating system.

Boot Control Block

Boot Control Block contains all the information which is needed to boot an operating system from that volume. It is called boot block in UNIX file system. In NTFS, it is called the partition boot sector.

Volume Control Block

Volume control block all the information regarding that volume such as number of blocks, size of each block, partition table, pointers to free blocks and free FCB blocks. In UNIX file system, it is known as super block. In NTFS, this information is stored inside master file table.

Directory Structure (per file system)

A directory structure (per file system) contains file names and pointers to corresponding FCBs. In UNIX, it includes inode numbers associated to file names.

File Control Block

File Control block contains all the details about the file such as ownership details, permission details, file size,etc. In UFS, this detail is stored in inode. In NTFS, this information is stored inside master file table as a relational database structure. A typical file control block is shown in the image below."
265,"next → ← prev In Memory Data Structure Till now, we have discussed the data structures that are required to be present on the hard disk in order to implement file systems. Here, we will discuss the data structures required to be present in memory in order to implement the file system. The in-memory data structures are used for file system management as well as performance improvement via caching. This information is loaded on the mount time and discarded on ejection. In-memory Mount Table In-memory mount table contains the list of all the devices which are being mounted to the system. Whenever the connection is maintained to a device, its entry will be done in the mount table. In-memory Directory structure cache This is the list of directory which is recently accessed by the CPU. The directories present in the list can also be accessed in the near future so it will be better to store them temporally in cache. System-wide open file table This is the list of all the open files in the system at a particular time. Whenever the user open any file for reading or writing, the entry will be made in this open file table. Per process Open file table It is the list of open files subjected to every process. Since there is already a list which is there for every open file in the system thereforeIt only contains Pointers to the appropriate entry in the system wide table.

Next Topic Directory Implementation



← prev next →



"
266,"next → ← prev Directory Implementation There is the number of algorithms by using which, the directories can be implemented. However, the selection of an appropriate directory implementation algorithm may significantly affect the performance of the system. The directory implementation algorithms are classified according to the data structure they are using. There are mainly two algorithms which are used in these days. 1. Linear List In this algorithm, all the files in a directory are maintained as singly lined list. Each file contains the pointers to the data blocks which are assigned to it and the next file in the directory. Characteristics When a new file is created, then the entire list is checked whether the new file name is matching to a existing file name or not. In case, it doesn't exist, the file can be created at the beginning or at the end. Therefore, searching for a unique name is a big concern because traversing the whole list takes time. The list needs to be traversed in case of every operation (creation, deletion, updating, etc) on the files therefore the systems become inefficient.



2. Hash Table To overcome the drawbacks of singly linked list implementation of directories, there is an alternative approach that is hash table. This approach suggests to use hash table along with the linked lists. A key-value pair for each file in the directory gets generated and stored in the hash table. The key can be determined by applying the hash function on the file name while the key points to the corresponding file stored in the directory. Now, searching becomes efficient due to the fact that now, entire list will not be searched on every operating. Only hash table entries are checked using the key and if an entry found then the corresponding file will be fetched using the value.



Next Topic Allocation Methods



← prev next →



"
267,"next → ← prev Allocation Methods There are various methods which can be used to allocate disk space to the files. Selection of an appropriate allocation method will significantly affect the performance and efficiency of the system. Allocation method provides a way in which the disk will be utilized and the files will be accessed. There are following methods which can be used for allocation. Contiguous Allocation. Extents Linked Allocation Clustering FAT Indexed Allocation Linked Indexed Allocation Multilevel Indexed Allocation Inode We will discuss three of the most used methods in detail.

Next Topic Contiguous Allocation



← prev next →



"
268,"next → ← prev Contiguous Allocation If the blocks are allocated to the file in such a way that all the logical blocks of the file get the contiguous physical block in the hard disk then such allocation scheme is known as contiguous allocation. In the image shown below, there are three files in the directory. The starting block and the length of each file are mentioned in the table. We can check in the table that the contiguous blocks are assigned to each file as per its need.



Advantages It is simple to implement. We will get Excellent read performance. Supports Random Access into files. Disadvantages The disk will become fragmented. It may be difficult to have a file grow.

Next Topic Linked List Allocation



← prev next →



"
269,"next → ← prev Linked List Allocation Linked List allocation solves all problems of contiguous allocation. In linked list allocation, each file is considered as the linked list of disk blocks. However, the disks blocks allocated to a particular file need not to be contiguous on the disk. Each disk block allocated to a file contains a pointer which points to the next disk block allocated to the same file.



Advantages There is no external fragmentation with linked allocation. Any free block can be utilized in order to satisfy the file block requests. File can continue to grow as long as the free blocks are available. Directory entry will only contain the starting block address. Disadvantages Random Access is not provided. Pointers require some space in the disk blocks. Any of the pointers in the linked list must not be broken otherwise the file will get corrupted. Need to traverse each block.

Next Topic File Allocation Table



← prev next →



"
270,"next → ← prev File Allocation Table The main disadvantage of linked list allocation is that the Random access to a particular block is not provided. In order to access a block, we need to access all its previous blocks. File Allocation Table overcomes this drawback of linked list allocation. In this scheme, a file allocation table is maintained, which gathers all the disk block links. The table has one entry for each disk block and is indexed by block number. File allocation table needs to be cached in order to reduce the number of head seeks. Now the head doesn't need to traverse all the disk blocks in order to access one successive block. It simply accesses the file allocation table, read the desired block entry from there and access that block. This is the way by which the random access is accomplished by using FAT. It is used by MS-DOS and pre-NT Windows versions.



Advantages Uses the whole disk block for data. A bad disk block doesn't cause all successive blocks lost. Random access is provided although its not too fast. Only FAT needs to be traversed in each file operation. Disadvantages Each Disk block needs a FAT entry. FAT size may be very big depending upon the number of FAT entries. Number of FAT entries can be reduced by increasing the block size but it will also increase Internal Fragmentation.

Next Topic Indexed Allocation



← prev next →



"
271,"next → ← prev Indexed Allocation Limitation of FAT Limitation in the existing technology causes the evolution of a new technology. Till now, we have seen various allocation methods; each of them was carrying several advantages and disadvantages. File allocation table tries to solve as many problems as possible but leads to a drawback. The more the number of blocks, the more will be the size of FAT. Therefore, we need to allocate more space to a file allocation table. Since, file allocation table needs to be cached therefore it is impossible to have as many space in cache. Here we need a new technology which can solve such problems. Indexed Allocation Scheme Instead of maintaining a file allocation table of all the disk pointers, Indexed allocation scheme stores all the disk pointers in one of the blocks called as indexed block. Indexed block doesn't hold the file data, but it holds the pointers to all the disk blocks allocated to that particular file. Directory entry will only contain the index block address.



Advantages Supports direct access A bad data block causes the lost of only that block. Disadvantages A bad index block could cause the lost of entire file. Size of a file depends upon the number of pointers, a index block can hold. Having an index block for a small file is totally wastage. More pointer overhead

Next Topic Linked Index Allocation



← prev next →



"
272,"next → ← prev Linked Index Allocation Single level linked Index Allocation In index allocation, the file size depends on the size of a disk block. To allow large files, we have to link several index blocks together. In linked index allocation, Small header giving the name of the file

Set of the first 100 block addresses

Pointer to another index block For the larger files, the last entry of the index block is a pointer which points to another index block. This is also called as linked schema.



Advantage: It removes file size limitations Disadvantage: Random Access becomes a bit harder Multilevel Index Allocation In Multilevel index allocation, we have various levels of indices. There are outer level index blocks which contain the pointers to the inner level index blocks and the inner level index blocks contain the pointers to the file data. The outer level index is used to find the inner level index.

The inner level index is used to find the desired data block. Advantage: Random Access becomes better and efficient. Disadvantage: Access time for a file will be higher.



Next Topic Inode



← prev next →



"
273,"next → ← prev Inode In UNIX based operating systems, each file is indexed by an Inode. Inode are the special disk block which is created with the creation of the file system. The number of files or directories in a file system depends on the number of Inodes in the file system. An Inode includes the following information Attributes (permissions, time stamp, ownership details, etc) of the file A number of direct blocks which contains the pointers to first 12 blocks of the file. A single indirect pointer which points to an index block. If the file cannot be indexed entirely by the direct blocks then the single indirect pointer is used. A double indirect pointer which points to a disk block that is a collection of the pointers to the disk blocks which are index blocks. Double index pointer is used if the file is too big to be indexed entirely by the direct blocks as well as the single indirect pointer. A triple index pointer that points to a disk block that is a collection of pointers. Each of the pointers is separately pointing to a disk block which also contains a collection of pointers which are separately pointing to an index block that contains the pointers to the file blocks.



Next Topic Free space Management



← prev next →



"
274,"Free Space Management

A file system is responsible to allocate the free blocks to the file therefore it has to keep track of all the free blocks present in the disk. There are mainly two approaches by using which, the free blocks in the disk are managed.

1. Bit Vector

In this approach, the free space list is implemented as a bit map vector. It contains the number of bits where each bit represents each block.

If the block is empty then the bit is 1 otherwise it is 0. Initially all the blocks are empty therefore each bit in the bit map vector contains 1.

LAs the space allocation proceeds, the file system starts allocating blocks to the files and setting the respective bit to 0.

2. Linked List

It is another approach for free space management. This approach suggests linking together all the free blocks and keeping a pointer in the cache which points to the first free block.

Therefore, all the free blocks on the disks will be linked together with a pointer. Whenever a block gets allocated, its previous free block will be linked to its next free block."
275,"Disk Scheduling

As we know, a process needs two type of time, CPU time and IO time. For I/O, it requests the Operating system to access the disk.

However, the operating system must be fare enough to satisfy each request and at the same time, operating system must maintain the efficiency and speed of process execution.

The technique that operating system uses to determine the request which is to be satisfied next is called disk scheduling.

Let's discuss some important terms related to disk scheduling.

Seek Time

Seek time is the time taken in locating the disk arm to a specified track where the read/write request will be satisfied.

Rotational Latency

It is the time taken by the desired sector to rotate itself to the position from where it can access the R/W heads.

Transfer Time

It is the time taken to transfer the data.

Disk Access Time

Disk access time is given as,

Disk Access Time = Rotational Latency + Seek Time + Transfer Time

Disk Response Time

It is the average of time spent by each request waiting for the IO operation.

Purpose of Disk Scheduling

The main purpose of disk scheduling algorithm is to select a disk request from the queue of IO requests and decide the schedule when this request will be processed.

Goal of Disk Scheduling Algorithm

Fairness

High throughout

Minimal traveling head time

Disk Scheduling Algorithms

The list of various disks scheduling algorithm is given below. Each algorithm is carrying some advantages and disadvantages. The limitation of each algorithm leads to the evolution of a new algorithm.

FCFS scheduling algorithm

SSTF (shortest seek time first) algorithm

SCAN scheduling

C-SCAN scheduling

LOOK Scheduling

C-LOOK scheduling"
276,"FCFS Scheduling Algorithm

It is the simplest Disk Scheduling algorithm. It services the IO requests in the order in which they arrive. There is no starvation in this algorithm, every request is serviced.

Disadvantages

The scheme does not optimize the seek time.

The request may come from different processes therefore there is the possibility of inappropriate movement of the head.

Example

Consider the following disk request sequence for a disk with 100 tracks 45, 21, 67, 90, 4, 50, 89, 52, 61, 87, 25

Head pointer starting at 50 and moving in left direction. Find the number of head movements in cylinders using FCFS scheduling.

Solution

Number of cylinders moved by the head

= (50-45)+(45-21)+(67-21)+(90-67)+(90-4)+(50-4)+(89-50)+(61-52)+(87-61)+(87-25)

= 5 + 24 + 46 + 23 + 86 + 46 + 49 + 9 + 26 + 62

= 376"
277,"SSTF Scheduling Algorithm

Shortest seek time first (SSTF) algorithm selects the disk I/O request which requires the least disk arm movement from its current position regardless of the direction. It reduces the total seek time as compared to FCFS.

It allows the head to move to the closest track in the service queue.

Disadvantages

It may cause starvation for some requests.

Switching direction on the frequent basis slows the working of algorithm.

It is not the most optimal algorithm.

Example

Consider the following disk request sequence for a disk with 100 tracks

45, 21, 67, 90, 4, 89, 52, 61, 87, 25

Head pointer starting at 50. Find the number of head movements in cylinders using SSTF scheduling.

Solution:

Number of cylinders = 5 + 7 + 9 + 6 + 20 + 2 + 1 + 65 + 4 + 17 = 136"
278,"SCAN and C-SCAN algorithm

Scan Algorithm

It is also called as Elevator Algorithm. In this algorithm, the disk arm moves into a particular direction till the end, satisfying all the requests coming in its path,and then it turns backand moves in the reverse direction satisfying requests coming in its path.

It works in the way an elevator works, elevator moves in a direction completely till the last floor of that direction and then turns back.

Example

Consider the following disk request sequence for a disk with 100 tracks

98, 137, 122, 183, 14, 133, 65, 78

Head pointer starting at 54 and moving in left direction. Find the number of head movements in cylinders using SCAN scheduling.

Number of Cylinders = 40 + 14 + 65 + 13 + 20 + 24 + 11 + 4 + 46 = 237

C-SCAN algorithm

In C-SCAN algorithm, the arm of the disk moves in a particular direction servicing requests until it reaches the last cylinder, then it jumps to the last cylinder of the opposite direction without servicing any request then it turns back and start moving in that direction servicing the remaining requests.

Example

Consider the following disk request sequence for a disk with 100 tracks

98, 137, 122, 183, 14, 133, 65, 78

Head pointer starting at 54 and moving in left direction. Find the number of head movements in cylinders using C-SCAN scheduling.

No. of cylinders crossed = 40 + 14 + 199 + 16 + 46 + 4 + 11 + 24 + 20 + 13 = 387"
279,"next → ← prev Look Scheduling It is like SCAN scheduling Algorithm to some extant except the difference that, in this scheduling algorithm, the arm of the disk stops moving inwards (or outwards) when no more request in that direction exists. This algorithm tries to overcome the overhead of SCAN algorithm which forces disk arm to move in one direction till the end regardless of knowing if any request exists in the direction or not. Example Consider the following disk request sequence for a disk with 100 tracks 98, 137, 122, 183, 14, 133, 65, 78 Head pointer starting at 54 and moving in left direction. Find the number of head movements in cylinders using LOOK scheduling.



Number of cylinders crossed = 40 + 51 + 13 + +20 + 24 + 11 + 4 + 46 = 209 C Look Scheduling C Look Algorithm is similar to C-SCAN algorithm to some extent. In this algorithm, the arm of the disk moves outwards servicing requests until it reaches the highest request cylinder, then it jumps to the lowest request cylinder without servicing any request then it again start moving outwards servicing the remaining requests. It is different from C SCAN algorithm in the sense that, C SCAN force the disk arm to move till the last cylinder regardless of knowing whether any request is to be serviced on that cylinder or not. Example Consider the following disk request sequence for a disk with 100 tracks 98, 137, 122, 183, 14, 133, 65, 78 Head pointer starting at 54 and moving in left direction. Find the number of head movements in cylinders using C LOOK scheduling.



Number of cylinders crossed = 11 + 13 + 20 + 24 + 11 + 4 + 46 + 169 = 298

Next Topic Numerical on SSTF and SCAN



← prev next →



"
280,"next → ← prev Numerical on SSTF and SCAN Question: Suppose the following disk request sequence (track numbers) for a disk with 100 tracks is given: 45, 20, 90, 10, 50, 60, 80 and 70. Assume that the initial position of the R/W head is on track 50. The additional distance that will be traversed by the R/W head when the Shortest Seek Time First (SSTF) algorithm is used compared to the SCAN (Elevator) algorithm (assuming that SCAN algorithm moves towards 100 when it starts execution) is _________ tracks (A) 5

(B) 9

(C) 10

(D) 11 Using SSTF Algorithm Number of track are 100. Initial Position of R/W head is 50. The requests are: 45, 20, 90, 10, 50, 60, 80 and 70



Number of crossed cylinders = 5 + 15 + 10 + 10 + 10 + 70 + 10 = 130 Using SCAN Algorithm



Number of cylinders crosses = 0 + 10 + 10 + 10 + 10 + 10 + 55 + 20 + 10 = 135 Therefore the answer is (A). The SCAN algorithm travels for 5 additional tracks.

Next Topic Numerical on Disk Scheduling



← prev next →



"
281,"next → ← prev Numerical on Disk Scheduling Algorithms Q. Consider a disk with 200 tracks and the queue has random requests from different processes in the order: 55, 58, 39, 18, 90, 160, 150, 38, 184 Initially arm is at 100. Find the Average Seek length using FIFO, SSTF, SCAN and C-SCAN algorithm. Solution :



Next Topic #



← prev next →



"
282,"next → ← prev Functions of Operation System An operating system is a program that acts as a user-computer GUI (Graphical user interface). It controls the execution of all types of applications. The operating system performs the following functions in a device. Instruction Input/output Management Memory Management File Management Processor Management Job Priority Special Control Program Scheduling of resources and jobs Security Monitoring activities Job accounting Instruction: The operating system establishes a mutual understanding between the various instructions given by the user. Input/output Management: What output will come from the input given by the user, the operating system runs this program. This management involves coordinating various input and output devices. It assigns the functions of those devices where one or more applications are executed. Memory Management: The operating system handles the responsibility of storing any data, system programs, and user programs in memory. This function of the operating system is called memory management. File Management: The operating system is helpful in making changes in the stored files and in replacing them. It also plays an important role in transferring various files to a device. Processor Management: The processor is the execution of a program that accomplishes the specified work in that program. It can be defined as an execution unit where a program runs. Job Priority: The work of job priority is creation and promotion. It determines what action should be done first in a computer system. Special Control Program: The operating systems make automatic changes to the task through specific control programs. These programs are called Special Control Program. Scheduling of resources and jobs: The operating system prepares the list of tasks to be performed for the device of the computer system. The operating system decides which device to use for which task. This action becomes complicated when multiple tasks are to be performed simultaneously in a computer system. The scheduling programs of the operating system determine the order in which tasks are completed. It performs these tasks based on the priority of performing the tasks given by the user. It makes the tasks available based on the priority of the device. Security: Computer security is a very important aspect of any operating system. The reliability of an operating system is determined by how much better security it provides us. Modern operating systems use a firewall for security. A firewall is a security system that monitors every activity happening in the computer and blocks that activity in case of any threat. Monitoring activities: The operating system takes care of the activities of the computer system during various processes. This aborts the program if there are errors. The operating system sends instant messages to the user for any unexpected error in the input/output device. It also provides security to the system when the operating system is used in systems operated by multiple users. So that illegal users cannot get data from the system. Job accounting: It keeps track of time & resources used by various jobs and users. Next Topic Mobile OS



← prev next →



"
283,"next → ← prev Mobile Operating System A mobile operating system is an operating system that helps to run other application software on mobile devices. It is the same kind of software as the famous computer operating systems like Linux and Windows, but now they are light and simple to some extent. The operating systems found on smartphones include Symbian OS, iPhone OS, RIM's BlackBerry, Windows Mobile, Palm WebOS, Android, and Maemo. Android, WebOS, and Maemo are all derived from Linux. The iPhone OS originated from BSD and NeXTSTEP, which are related to Unix. It combines the beauty of computer and hand use devices. It typically contains a cellular built-in modem and SIM tray for telephony and internet connections. If you buy a mobile, the manufacturer company chooses the OS for that specific device. Popular platforms of the Mobile OS 1. Android OS: The Android operating system is the most popular operating system today. It is a mobile OS based on the Linux Kernel and open-source software. The android operating system was developed by Google. The first Android device was launched in 2008. 2. Bada (Samsung Electronics): Bada is a Samsung mobile operating system that was launched in 2010. The Samsung wave was the first mobile to use the bada operating system. The bada operating system offers many mobile features, such as 3-D graphics, application installation, and multipoint-touch. 3. BlackBerry OS: The BlackBerry operating system is a mobile operating system developed by Research In Motion (RIM). This operating system was designed specifically for BlackBerry handheld devices. This operating system is beneficial for the corporate users because it provides synchronization with Microsoft Exchange, Novell GroupWise email, Lotus Domino, and other business software when used with the BlackBerry Enterprise Server. 4. iPhone OS / iOS: The iOS was developed by the Apple inc for the use on its device. The iOS operating system is the most popular operating system today. It is a very secure operating system. The iOS operating system is not available for any other mobiles. 5. Symbian OS: Symbian operating system is a mobile operating system that provides a high-level of integration with communication. The Symbian operating system is based on the java language. It combines middleware of wireless communications and personal information management (PIM) functionality. The Symbian operating system was developed by Symbian Ltd in 1998 for the use of mobile phones. Nokia was the first company to release Symbian OS on its mobile phone at that time. 6. Windows Mobile OS: The window mobile OS is a mobile operating system that was developed by Microsoft. It was designed for the pocket PCs and smart mobiles. 7. Harmony OS: The harmony operating system is the latest mobile operating system that was developed by Huawei for the use of its devices. It is designed primarily for IoT devices. 8. Palm OS: The palm operating system is a mobile operating system that was developed by Palm Ltd for use on personal digital assistants (PADs). It was introduced in 1996. Palm OS is also known as the Garnet OS. 9. WebOS (Palm/HP): The WebOS is a mobile operating system that was developed by Palm. It based on the Linux Kernel. The HP uses this operating system in its mobile and touchpads. Next Topic Swapping in OS



← prev next →



"
284,"next → ← prev Swapping in Operating System Swapping is a memory management scheme in which any process can be temporarily swapped from main memory to secondary memory so that the main memory can be made available for other processes. It is used to improve main memory utilization. In secondary memory, the place where the swapped-out process is stored is called swap space. The purpose of the swapping in operating system is to access the data present in the hard disk and bring it to RAM so that the application programs can use it. The thing to remember is that swapping is used only when data is not present in RAM. Although the process of swapping affects the performance of the system, it helps to run larger and more than one process. This is the reason why swapping is also referred to as memory compaction. The concept of swapping has divided into two more concepts: Swap-in and Swap-out. Swap-out is a method of removing a process from RAM and adding it to the hard disk.

Swap-in is a method of removing a program from a hard disk and putting it back into the main memory or RAM. Example: Suppose the user process's size is 2048KB and is a standard hard disk where swapping has a data transfer rate of 1Mbps. Now we will calculate how long it will take to transfer from main memory to secondary memory. User process size is 2048Kb Data transfer rate is 1Mbps = 1024 kbps Time = process size / transfer rate = 2048 / 1024 = 2 seconds = 2000 milliseconds Now taking swap-in and swap-out time, the process will take 4000 milliseconds. Advantages of Swapping It helps the CPU to manage multiple processes within a single main memory. It helps to create and use virtual memory. Swapping allows the CPU to perform multiple tasks simultaneously. Therefore, processes do not have to wait very long before they are executed. It improves the main memory utilization. Disadvantages of Swapping If the computer system loses power, the user may lose all information related to the program in case of substantial swapping activity. If the swapping algorithm is not good, the composite method can increase the number of Page Fault and decrease the overall processing performance. Note: In a single tasking operating system, only one process occupies the user program area of memory and stays in memory until the process is complete.

In a multitasking operating system, a situation arises when all the active processes cannot coordinate in the main memory, then a process is swap out from the main memory so that other processes can enter it. Next Topic Threads in OS



← prev next →



"
285,"next → ← prev Threads in Operating System There is a way of thread execution inside the process of any operating system. Apart from this, there can be more than one thread inside a process. Thread is often referred to as a lightweight process. The process can be split down into so many threads. For example, in a browser, many tabs can be viewed as threads. MS Word uses many threads - formatting text from one thread, processing input from another thread, etc. Types of Threads In the operating system, there are two types of threads. Kernel level thread. User-level thread. User-level thread The operating system does not recognize the user-level thread. User threads can be easily implemented and it is implemented by the user. If a user performs a user-level thread blocking operation, the whole process is blocked. The kernel level thread does not know nothing about the user level thread. The kernel-level thread manages user-level threads as if they are single-threaded processes?examples: Java thread, POSIX threads, etc. Advantages of User-level threads The user threads can be easily implemented than the kernel thread. User-level threads can be applied to such types of operating systems that do not support threads at the kernel-level. It is faster and efficient. Context switch time is shorter than the kernel-level threads. It does not require modifications of the operating system. User-level threads representation is very simple. The register, PC, stack, and mini thread control blocks are stored in the address space of the user-level process. It is simple to create, switch, and synchronize threads without the intervention of the process. Disadvantages of User-level threads User-level threads lack coordination between the thread and the kernel. If a thread causes a page fault, the entire process is blocked. Kernel level thread The kernel thread recognizes the operating system. There are a thread control block and process control block in the system for each thread and process in the kernel-level thread. The kernel-level thread is implemented by the operating system. The kernel knows about all the threads and manages them. The kernel-level thread offers a system call to create and manage the threads from user-space. The implementation of kernel threads is difficult than the user thread. Context switch time is longer in the kernel thread. If a kernel thread performs a blocking operation, the Banky thread execution can continue. Example: Window Solaris. Advantages of Kernel-level threads The kernel-level thread is fully aware of all threads. The scheduler may decide to spend more CPU time in the process of threads being large numerical. The kernel-level thread is good for those applications that block the frequency. Disadvantages of Kernel-level threads The kernel thread manages and schedules all threads. The implementation of kernel threads is difficult than the user thread. The kernel-level thread is slower than user-level threads. Components of Threads Any thread has the following components. Program counter Register set Stack space Benefits of Threads Enhanced throughput of the system: When the process is split into many threads, and each thread is treated as a job, the number of jobs done in the unit time increases. That is why the throughput of the system also increases.

When the process is split into many threads, and each thread is treated as a job, the number of jobs done in the unit time increases. That is why the throughput of the system also increases. Effective Utilization of Multiprocessor system: When you have more than one thread in one process, you can schedule more than one thread in more than one processor.

When you have more than one thread in one process, you can schedule more than one thread in more than one processor. Faster context switch: The context switching period between threads is less than the process context switching. The process context switch means more overhead for the CPU.

The context switching period between threads is less than the process context switching. The process context switch means more overhead for the CPU. Responsiveness: When the process is split into several threads, and when a thread completes its execution, that process can be responded to as soon as possible.

When the process is split into several threads, and when a thread completes its execution, that process can be responded to as soon as possible. Communication: Multiple-thread communication is simple because the threads share the same address space, while in process, we adopt just a few exclusive communication strategies for communication between two processes.

Multiple-thread communication is simple because the threads share the same address space, while in process, we adopt just a few exclusive communication strategies for communication between two processes. Resource sharing: Resources can be shared between all threads within a process, such as code, data, and files. Note: The stack and register cannot be shared between threads. There are a stack and register for each thread. Next Topic Fedora Operating System



← prev next →



"
286,"next → ← prev Fedora Operating System Fedora operating system is an open-source operating system that is based on the Linux OS kernel architecture. A group of developers was developed the Fedora operating system under the Fedora Project. It is sponsored by Red Hat. It is designed as a secure operating system for the general-purpose. Fedora operating system offers a suite of virus protection, system tools, office productivity services, media playback, and other desktop application. According to the Fedora Project, it is always free to use, modify, and distribute. Fedora OS is integrated with applications and packaged software. This operating system enhances the abilities of the software. It offers the same consistency, procedures, and functionality as a traditional OS. Fedora operating system is the second most commonly used distribution of Linux after Ubuntu. There are over 100 distributions based on the Fedora operating system, including the XO operating system of Red Hat Enterprise Linux. Features of Fedora Operating System List of the Fedora OS features: Fedora OS offers many architectures.

Fedora OS is a very reliable and stable operating system.

It provides unique security features.

Fedora OS provides a very powerful firewall.

Fedora OS is very easy to use.

It supports a large community.

Fedora OS is actively developed.

Fedora OS is an open-source OS.

The interface of Fedora OS is very attractive.

This operating system offers live mode tools.

This operating system enhances internet speed. Fedora OS comes with many pre-installed applications and tools, such as Internet Browser, PDF and Word files Viewer, Pre-installed Games, Libre Office Suite, Programming language Support, etc. Fedora is a very stable, secure, and light-weight operating system. It supports different types of architectures, such as IBM Z, AMD x86-x64, Intel i686, IBM Power64le, ARM-hfp, MIPS-64el, ARM AArch64, IBM Power64, etc. Usually, it also works on the latest Linux kernel. Fedora Server Fedora Server is a very flexible and powerful OS. It keeps all your infrastructure and services under your control. Fedora operating system offers the latest data center technologies. Advantages of Fedora Operating System Fedora OS is a very reliable and stable operating system. It enhances the security in this operating system. It offers many graphical tools. This operating system updates automatically. This OS supports many file formats. It also offers many education software. It supports a large community. It provides unique security features. Disadvantages of Fedora Operating System It requires a long time to set up. It requires additional software tools for the server. It does not provide any standard model for multi-file objects. Fedora has its own server, so we can't work on another server in real-time. Next Topic Uses of Operating System



← prev next →



"
287,"next → ← prev Uses of Operating System The operating system is used everywhere today, such as banks, schools, hospitals, companies, mobiles, etc. No device can operate without an operating system because it controls all the user's commands. LINUX/UNIX operating system is used in the bank because it is a very secure operating system.

operating system is used in the bank because it is a very secure operating system. Symbian OS, Windows Mobile, iOS, and Android OS are used in mobile phone operating systems as these operating systems are a lightweight operating system. Features of Operating System The operating system has many notable features that are developing day by day. The growth of the operating system is commendable as it was developed in 1950 to handle storage tape. It acts as an interface. The features of operating system are given below. Error detection and handling

Handling I/O operations

Virtual Memory Multitasking

Program Execution

Allows disk access and file systems

Memory management

Protected and supervisor mode

Security

Resource allocation

Easy to run

Information and Resource Protection

Manipulation of the file system Characteristics of Operating System Memory Management: The operating system manages memory. It has complete knowledge of primary memory; which part of the memory is used by which program. Whenever a program requests, it allocates memory. Processor Management: It allocates the program to the processor (CPU) and also deallocates it when a program runs out of the CPU needs. Device Management: The operating system keeps the information about all devices. It is also called the I/O controller, and the operating system also decides which devices are used to which program, when, and for how long. Security: It prevents unauthorized access to any program. It uses passwords and other technologies. Reliability: It is very reliable because no any virus and harmful code can be detected in it. File Management: It allocates and deallocates resources and decides which program to allocate resources. Easy to use: It can be easily used as it also has a GUI interface. Needs of Operating System The following points indicate the need for the operating system: More than one program runs at a time in a computer, and all of them require your computer's CPU and memory. The operating system manages resources for all those programs. That is why the operating system is required.

Multitasking is a very critical feature of the OS. With its help, we can run many programs simultaneously.

The operating system provides a platform to run any application program in the computer. Due to which we can do our work with the help of that application.

It helps the user in file management. Through this, the user can save the data according to his needs.

You use your mouse to open the application and click on the menu. All this is possible due to the modern operating system. This operating system allows you to do this with the help of GUI (Graphical user interface).

The operating system creates a communication link between the user and the computer, allowing the user to run any application program and obtain the required output properly.

It is almost impossible for a user to use a computer system without an operating system. Many processes run simultaneously when a program is executed, which is not easy for a person to manage. Next Topic Producer-Consumer problem



← prev next →



"
288,"next → ← prev Producer-Consumer problem The Producer-Consumer problem is a classical multi-process synchronization problem, that is we are trying to achieve synchronization between more than one process. There is one Producer in the producer-consumer problem, Producer is producing some items, whereas there is one Consumer that is consuming the items produced by the Producer. The same memory buffer is shared by both producers and consumers which is of fixed-size. The task of the Producer is to produce the item, put it into the memory buffer, and again start producing items. Whereas the task of the Consumer is to consume the item from the memory buffer. Let's understand what is the problem? Below are a few points that considered as the problems occur in Producer-Consumer: The producer should produce data only when the buffer is not full. In case it is found that the buffer is full, the producer is not allowed to store any data into the memory buffer.

Data can only be consumed by the consumer if and only if the memory buffer is not empty. In case it is found that the buffer is empty, the consumer is not allowed to use any data from the memory buffer.

Accessing memory buffer should not be allowed to producer and consumer at the same time. Let's see the code for the above problem: Producer Code Producer Code Let's understand above Producer and Consumer code: Before Starting an explanation of code, first, understand the few terms used in the above code: ""in"" used in a producer code represent the next empty buffer ""out"" used in consumer code represent first filled buffer count keeps the count number of elements in the buffer count is further divided into 3 lines code represented in the block in both the producer and consumer code. If we talk about Producer code first: --Rp is a register which keeps the value of m[count] --Rp is incremented (As element has been added to buffer) --an Incremented value of Rp is stored back to m[count] Similarly, if we talk about Consumer code next: --Rc is a register which keeps the value of m[count] --Rc is decremented (As element has been removed out of buffer) --the decremented value of Rc is stored back to m[count]. BUFFER

As we can see from Fig: Buffer has total 8 spaces out of which the first 5 are filled, in = 5(pointing next empty position) and out = 0(pointing first filled position). Let's start with the producer who wanted to produce an element "" F "", according to code it will enter into the producer() function, while(1) will always be true, itemP = F will be tried to insert into the buffer, before that while(count == n); will evaluate to be False. Note: Semicolon after while loop will not let the code to go ahead if it turns out to be True(i.e. infinite loop/ Buffer is full) Buffer[in] = itemP → Buffer[5] = F. ( F is inserted now) in = (in + 1) mod n → (5 + 1)mod 8→ 6, therefore in = 6; (next empty buffer) After insertion of F, Buffer looks like this Where out = 0, but in = 6 Since count = count + 1; is divided into three parts: Load Rp, m[count] → will copy count value which is 5 to register Rp. Increment Rp → will increment Rp to 6. Suppose just after Increment and before the execution of third line (store m[count], Rp) Context Switch occurs and code jumps to consumer code. . . Consumer Code: Now starting consumer who wanted to consume the first element "" A "", according to code it will enter into the consumer() function, while(1) will always be true, while(count == 0); will evaluate to be False( since the count is still 5, which is not equal to 0. Note: Semicolon after while loop will not let the code to go ahead if it turns out to be True( i.e. infinite loop/ no element in buffer) itemC = Buffer[out]→ itemC = A ( since out is 0) out = (out + 1) mod n → (0 + 1)mod 8→ 1, therefore out = 1( first filled position) A is removed now After removal of A, Buffer look like this Where out = 1, and in = 6 Since count = count - 1; is divided into three parts: Load Rc, m[count] → will copy count value which is 5 to register Rp. Decrement Rc → will decrement Rc to 4. store m[count], Rc → count = 4. Now the current value of count is 4 Suppose after this Context Switch occurs back to the leftover part of producer code. . . Since context switch at producer code was occurred after Increment and before the execution of the third line (store m[count], Rp) So we resume from here since Rp holds 6 as incremented value Hence store m[count], Rp → count = 6 Now the current value of count is 6, which is wrong as Buffer has only 5 elements, this condition is known as Race Condition and Problem is Producer-Consumer Problem. The solution of Producer-Consumer Problem using Semaphore The above problems of Producer and Consumer which occurred due to context switch and producing inconsistent result can be solved with the help of semaphores. To solve the problem occurred above of race condition, we are going to use Binary Semaphore and Counting Semaphore Binary Semaphore: In Binary Semaphore, only two processes can compete to enter into its CRITICAL SECTION at any point in time, apart from this the condition of mutual exclusion is also preserved. Counting Semaphore: In counting semaphore, more than two processes can compete to enter into its CRITICAL SECTION at any point of time apart from this the condition of mutual exclusion is also preserved. Semaphore: A semaphore is an integer variable in S, that apart from initialization is accessed by only two standard atomic operations - wait and signal, whose definitions are as follows: 1. wait( S ) { while( S <= 0) ; S--; }

2. signal( S ) { S++; } From the above definitions of wait, it is clear that if the value of S <= 0 then it will enter into an infinite loop (because of the semicolon; after while loop). Whereas the job of the signal is to increment the value of S. Let's see the code as a solution of producer and consumer problem using semaphore ( Both Binary and Counting Semaphore): Producer Code- solution void producer( void ) { wait ( empty ); wait(S); Produce_item(item P) buffer[ in ] = item P; in = (in + 1)mod n signal(S); signal(full); } Consumer Code- solution void consumer(void) { wait ( empty ); wait(S); itemC = buffer[ out ]; out = ( out + 1 ) mod n; signal(S); signal(empty); } Let's understand the above Solution of Producer and Consumer code: Before Starting an explanation of code, first, understand the few terms used in the above code: ""in"" used in a producer code represent the next empty buffer ""out"" used in consumer code represent first filled buffer ""empty"" is counting semaphore which keeps a score of no. of empty buffer ""full"" is counting semaphore which scores of no. of full buffer ""S"" is a binary semaphore BUFFER If we see the current situation of Buffer S = 1(init. Value of Binary semaphore in = 5( next empty buffer) out = 0(first filled buffer) As we can see from Fig: Buffer has total 8 spaces out of which the first 5 are filled, in = 5(pointing next empty position) and out = 0(pointing first filled position). Semaphores used in Producer Code: 6. wait(empty) will decrease the value of the counting semaphore variable empty by 1, that is when the producer produces some element then the value of the space gets automatically decreased by one in the buffer. In case the buffer is full, that is the value of the counting semaphore variable ""empty"" is 0, then wait(empty); will trap the process (as per definition of wait) and does not allow to go further. 7. wait(S) decreases the binary semaphore variable S to 0 so that no other process which is willing to enter into its critical section is allowed. 8. signal(s) increases the binary semaphore variable S to 1 so that other processes who are willing to enter into its critical section can now be allowed. 9. signal(full) increases the counting semaphore variable full by 1, as on adding the item into the buffer, one space is occupied in the buffer and the variable full must be updated. Semaphores used in Producer Code: 10.0wait(full) will decrease the value of the counting semaphore variable full by 1, that is when the consumer consumes some element then the value of the full space gets automatically decreased by one in the buffer. In case the buffer is empty, that is the value of the counting semaphore variable full is 0, then wait(full); will trap the process(as per definition of wait) and does not allow to go further. 11. wait(S) decreases the binary semaphore variable S to 0 so that no other process which is willing to enter into its critical section is allowed. 12. signal(S) increases the binary semaphore variable S to 1 so that other processes who are willing to enter into its critical section can now be allowed. 13. signal(empty) increases the counting semaphore variable empty by 1, as on removing an item from the buffer, one space is vacant in the buffer and the variable empty must be updated accordingly. Producer Code: Let's start with producer() who wanted to produce an element "" F "", according to code it will enter into the producer() function. wait(empty); will decrease the value of empty by one, i.e. empty = 2 Suppose just after this context switch occurs and jumps to consumer code. Consumer Code: Now starting consumer who wanted to consume first element "" A "", according to code it will enter into consumer() function, wait(full); will decrease the value of full by one, i.e. full = 4 wait (S); will decrease the value of S to 0 itemC = Buffer[out]; → itemC = A ( since out is 0) A is removed now out = (out + 1) mod n → (0 + 1)mod 8 → 1, therefore out = 1( first filled position) S = 0(Value of Binary semaphore) in = 5( next empty buffer) out = 1(first filled buffer) Suppose just after this context, switch occurs back to producer code Since the next instruction of producer() is wait(S);, this will trap the producer process, as the current value of S is 0, and wait(0); is an infinite loop: as per the definition of wait, hence producer cannot move further. Therefore, we move back to the consumer process next instruction. signal(S); will now increment the value of S to 1. signal(empty); will increment empty by 1, i.e. empty = 3 Now moving back to producer() code; Since the next instruction of producer() is wait(S); will successfully execute, as S is now 1 and it will decrease the value of S by 1, i.e. S = 0 Buffer[in] = itemP; → Buffer[5] = F. ( F is inserted now) in = (in + 1) mod n → (5 + 1)mod 8 → 6, therefore in = 6; (next empty buffer) signal(S); will increment S by 1, signal(full); will increment full by 1, i.e. full = 5 Now add current value of full and empty, i.e. full + empty = 5 + 3 = 8(which is absolutely fine) No inconsistent result is generated even after so many context switches. But in the previous condition of producer and consumer without semaphore, we see the inconsistent result in case of context switches. This is the solution to the Producer consumer problem. Next Topic DINING PHILOSOPHERS PROBLEM



← prev next →



"
289,"next → ← prev THE DINING PHILOSOPHERS PROBLEM The dining philosopher's problem is the classical problem of synchronization which says that Five philosophers are sitting around a circular table and their job is to think and eat alternatively. A bowl of noodles is placed at the center of the table along with five chopsticks for each of the philosophers. To eat a philosopher needs both their right and a left chopstick. A philosopher can only eat if both immediate left and right chopsticks of the philosopher is available. In case if both immediate left and right chopsticks of the philosopher are not available then the philosopher puts down their (either left or right) chopstick and starts thinking again. The dining philosopher demonstrates a large class of concurrency control problems hence it's a classic synchronization problem. Five Philosophers sitting around the table Dining Philosophers Problem- Let's understand the Dining Philosophers Problem with the below code, we have used fig 1 as a reference to make you understand the problem exactly. The five Philosophers are represented as P0, P1, P2, P3, and P4 and five chopsticks by C0, C1, C2, C3, and C4. Void Philosopher { while(1) { take_chopstick[i]; take_chopstick[ (i+1) % 5] ; . . . EATING THE NOODLE . put_chopstick[i] ); put_chopstick[ (i+1) % 5] ; . . THINKING } } Let's discuss the above code: Suppose Philosopher P0 wants to eat, it will enter in Philosopher() function, and execute take_chopstick[i]; by doing this it holds C0 chopstick after that it execute take_chopstick[ (i+1) % 5]; by doing this it holds C1 chopstick( since i =0, therefore (0 + 1) % 5 = 1) Similarly suppose now Philosopher P1 wants to eat, it will enter in Philosopher() function, and execute take_chopstick[i]; by doing this it holds C1 chopstick after that it execute take_chopstick[ (i+1) % 5]; by doing this it holds C2 chopstick( since i =1, therefore (1 + 1) % 5 = 2) But Practically Chopstick C1 is not available as it has already been taken by philosopher P0, hence the above code generates problems and produces race condition. The solution of the Dining Philosophers Problem We use a semaphore to represent a chopstick and this truly acts as a solution of the Dining Philosophers Problem. Wait and Signal operations will be used for the solution of the Dining Philosophers Problem, for picking a chopstick wait operation can be executed while for releasing a chopstick signal semaphore can be executed. Semaphore: A semaphore is an integer variable in S, that apart from initialization is accessed by only two standard atomic operations - wait and signal, whose definitions are as follows: 1. wait( S ) { while( S <= 0) ; S--; } 2. signal( S ) { S++; } From the above definitions of wait, it is clear that if the value of S <= 0 then it will enter into an infinite loop(because of the semicolon; after while loop). Whereas the job of the signal is to increment the value of S. The structure of the chopstick is an array of a semaphore which is represented as shown below - semaphore C[5]; Initially, each element of the semaphore C0, C1, C2, C3, and C4 are initialized to 1 as the chopsticks are on the table and not picked up by any of the philosophers. Let's modify the above code of the Dining Philosopher Problem by using semaphore operations wait and signal, the desired code looks like void Philosopher { while(1) { Wait( take_chopstickC[i] ); Wait( take_chopstickC[(i+1) % 5] ) ; . . . EATING THE NOODLE . Signal( put_chopstickC[i] ); Signal( put_chopstickC[ (i+1) % 5] ) ; . . THINKING } } In the above code, first wait operation is performed on take_chopstickC[i] and take_chopstickC [ (i+1) % 5]. This shows philosopher i have picked up the chopsticks from its left and right. The eating function is performed after that. On completion of eating by philosopher i the, signal operation is performed on take_chopstickC[i] and take_chopstickC [ (i+1) % 5]. This shows that the philosopher i have eaten and put down both the left and right chopsticks. Finally, the philosopher starts thinking again. Let's understand how the above code is giving a solution to the dining philosopher problem? Let value of i = 0( initial value ), Suppose Philosopher P0 wants to eat, it will enter in Philosopher() function, and execute Wait( take_chopstickC[i] ); by doing this it holds C0 chopstick and reduces semaphore C0 to 0, after that it execute Wait( take_chopstickC[(i+1) % 5] ); by doing this it holds C1 chopstick( since i =0, therefore (0 + 1) % 5 = 1) and reduces semaphore C1 to 0 Similarly, suppose now Philosopher P1 wants to eat, it will enter in Philosopher() function, and execute Wait( take_chopstickC[i] ); by doing this it will try to hold C1 chopstick but will not be able to do that, since the value of semaphore C1 has already been set to 0 by philosopher P0, therefore it will enter into an infinite loop because of which philosopher P1 will not be able to pick chopstick C1 whereas if Philosopher P2 wants to eat, it will enter in Philosopher() function, and execute Wait( take_chopstickC[i] ); by doing this it holds C2 chopstick and reduces semaphore C2 to 0, after that, it executes Wait( take_chopstickC[(i+1) % 5] ); by doing this it holds C3 chopstick( since i =2, therefore (2 + 1) % 5 = 3) and reduces semaphore C3 to 0. Hence the above code is providing a solution to the dining philosopher problem, A philosopher can only eat if both immediate left and right chopsticks of the philosopher are available else philosopher needs to wait. Also at one go two independent philosophers can eat simultaneously (i.e., philosopher P0 and P2, P1 and P3 & P2 and P4 can eat simultaneously as all are the independent processes and they are following the above constraint of dining philosopher problem) The drawback of the above solution of the dining philosopher problem From the above solution of the dining philosopher problem, we have proved that no two neighboring philosophers can eat at the same point in time. The drawback of the above solution is that this solution can lead to a deadlock condition. This situation happens if all the philosophers pick their left chopstick at the same time, which leads to the condition of deadlock and none of the philosophers can eat. To avoid deadlock, some of the solutions are as follows - Maximum number of philosophers on the table should not be more than four, in this case, chopstick C4 will be available for philosopher P3, so P3 will start eating and after the finish of his eating procedure, he will put down his both the chopstick C3 and C4, i.e. semaphore C3 and C4 will now be incremented to 1. Now philosopher P2 which was holding chopstick C2 will also have chopstick C3 available, hence similarly, he will put down his chopstick after eating and enable other philosophers to eat.

A philosopher at an even position should pick the right chopstick and then the left chopstick while a philosopher at an odd position should pick the left chopstick and then the right chopstick.

Only in case if both the chopsticks ( left and right ) are available at the same time, only then a philosopher should be allowed to pick their chopsticks

All the four starting philosophers ( P0, P1, P2, and P3) should pick the left chopstick and then the right chopstick, whereas the last philosopher P4 should pick the right chopstick and then the left chopstick. This will force P4 to hold his right chopstick first since the right chopstick of P4 is C0, which is already held by philosopher P0 and its value is set to 0, i.e C0 is already 0, because of which P4 will get trapped into an infinite loop and chopstick C4 remains vacant. Hence philosopher P3 has both left C3 and right C4 chopstick available, therefore it will start eating and will put down its both chopsticks once finishes and let others eat which removes the problem of deadlock. The design of the problem was to illustrate the challenges of avoiding deadlock, a deadlock state of a system is a state in which no progress of system is possible. Consider a proposal where each philosopher is instructed to behave as follows: The philosopher is instructed to think till the left fork is available, when it is available, hold it.

The philosopher is instructed to think till the right fork is available, when it is available, hold it.

The philosopher is instructed to eat when both forks are available.

then, put the right fork down first

then, put the left fork down next

repeat from the beginning. Next Topic READERS WRITERS PROBLEM



← prev next →



"
290,"next → ← prev READERS WRITERS PROBLEM The readers-writers problem is a classical problem of process synchronization, it relates to a data set such as a file that is shared between more than one process at a time. Among these various processes, some are Readers - which can only read the data set; they do not perform any updates, some are Writers - can both read and write in the data sets. The readers-writers problem is used for managing synchronization among various reader and writer process so that there are no problems with the data sets, i.e. no inconsistency is generated. Let's understand with an example - If two or more than two readers want to access the file at the same point in time there will be no problem. However, in other situations like when two writers or one reader and one writer wants to access the file at the same point of time, there may occur some problems, hence the task is to design the code in such a manner that if one reader is reading then no writer is allowed to update at the same point of time, similarly, if one writer is writing no reader is allowed to read the file at that point of time and if one writer is updating a file other writers should not be allowed to update the file at the same point of time. However, multiple readers can access the object at the same time. Let us understand the possibility of reading and writing with the table given below: TABLE 1 Case Process 1 Process 2 Allowed / Not Allowed Case 1 Writing Writing Not Allowed Case 2 Reading Writing Not Allowed Case 3 Writing Reading Not Allowed Case 4 Reading Reading Allowed The solution of readers and writers can be implemented using binary semaphores. We use two binary semaphores ""write"" and ""mutex"", where binary semaphore can be defined as: Semaphore: A semaphore is an integer variable in S, that apart from initialization is accessed by only two standard atomic operations - wait and signal, whose definitions are as follows: 1. wait( S ) { while( S <= 0) ; S--; } 2. signal( S ) { S++; } From the above definitions of wait, it is clear that if the value of S <= 0 then it will enter into an infinite loop (because of the semicolon; after while loop). Whereas the job of the signal is to increment the value of S. The below code will provide the solution of the reader-writer problem, reader and writer process codes are given as follows - Code for Reader Process The code of the reader process is given below - static int readcount = 0; wait (mutex); readcount ++; // on each entry of reader increment readcount if (readcount == 1) { wait (write); } signal(mutex); --READ THE FILE? wait(mutex); readcount --; // on every exit of reader decrement readcount if (readcount == 0) { signal (write); } signal(mutex); In the above code of reader, mutex and write are semaphores that have an initial value of 1, whereas the readcount variable has an initial value as 0. Both mutex and write are common in reader and writer process code, semaphore mutex ensures mutual exclusion and semaphore write handles the writing mechanism. The readcount variable denotes the number of readers accessing the file concurrently. The moment variable readcount becomes 1, wait operation is used to write semaphore which decreases the value by one. This means that a writer is not allowed how to access the file anymore. On completion of the read operation, readcount is decremented by one. When readcount becomes 0, the signal operation which is used to write permits a writer to access the file. Code for Writer Process The code that defines the writer process is given below: wait(write); WRITE INTO THE FILE signal(wrt); If a writer wishes to access the file, wait operation is performed on write semaphore, which decrements write to 0 and no other writer can access the file. On completion of the writing job by the writer who was accessing the file, the signal operation is performed on write. Let's see the proof of each case mentioned in Table 1 CASE 1: WRITING - WRITING → NOT ALLOWED. That is when two or more than two processes are willing to write, then it is not allowed. Let us see that our code is working accordingly or not? Explanation : The initial value of semaphore write = 1 Suppose two processes P0 and P1 wants to write, let P0 enter first the writer code, The moment P0 enters Wait( write ); will decrease semaphore write by one, now write = 0 And continue WRITE INTO THE FILE Now suppose P1 wants to write at the same time (will it be allowed?) let's see. P1 does Wait( write ), since the write value is already 0, therefore from the definition of wait, it will go into an infinite loop (i.e. Trap), hence P1 can never write anything, till P0 is writing. Now suppose P0 has finished the task, it will signal( write); will increase semaphore write by 1, now write = 1 if now P1 wants to write it since semaphore write > 0 This proofs that, if one process is writing, no other process is allowed to write. CASE 2: READING - WRITING → NOT ALLOWED. That is when one or more than one process is reading the file, then writing by another process is not allowed. Let us see that our code is working accordingly or not? Explanation: Initial value of semaphore mutex = 1 and variable readcount = 0 Suppose two processes P0 and P1 are in a system, P0 wants to read while P1 wants to write, P0 enter first into the reader code, the moment P0 enters Wait( mutex ); will decrease semaphore mutex by 1, now mutex = 0 Increment readcount by 1, now readcount = 1, next if (readcount == 1)// evaluates to TRUE { wait (write); // decrement write by 1, i.e. write = 0(which clearly proves that if one or more than one reader is reading then no writer will be allowed. } signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to enter. And reader continues to --READ THE FILE? Suppose now any writer wants to enter into its code then: As the first reader has executed wait (write); because of which write value is 0, therefore wait(writer); of the writer, code will go into an infinite loop and no writer will be allowed. This proofs that, if one process is reading, no other process is allowed to write. Now suppose P0 wants to stop the reading and wanted to exit then Following sequence of instructions will take place: wait(mutex); // decrease mutex by 1, i.e. mutex = 0 readcount --; // readcount = 0, i.e. no one is currently reading if (readcount == 0) // evaluates TRUE { signal (write); // increase write by one, i.e. write = 1 } signal(mutex);// increase mutex by one, i.e. mutex = 1 Now if again any writer wants to write, it can do it now, since write > 0 CASE 3: WRITING -- READING → NOT ALLOWED. That is when if one process is writing into the file, then reading by another process is not allowed. Let us see that our code is working accordingly or not? Explanation: The initial value of semaphore write = 1 Suppose two processes P0 and P1 are in a system, P0 wants to write while P1 wants to read, P0 enter first into the writer code, The moment P0 enters Wait( write ); will decrease semaphore write by 1, now write = 0 And continue WRITE INTO THE FILE Now suppose P1 wants to read the same time (will it be allowed?) let's see. P1 enters reader's code Initial value of semaphore mutex = 1 and variable readcount = 0 Wait( mutex ); will decrease semaphore mutex by 1, now mutex = 0 Increment readcount by 1, now readcount = 1, next if (readcount == 1)// evaluates to TRUE { wait (write); // since value of write is already 0, hence it will enter into an infinite loop and will not be allowed to proceed further (which clearly proves that if one writer is writing then no reader will be allowed. } The moment writer stops writing and willing to exit then This proofs that, if one process is writing, no other process is allowed to read. The moment writer stops writing and willing to exit then it will execute: signal( write); will increase semaphore write by 1, now write = 1 if now P1 wants to read it can since semaphore write > 0 CASE 4: READING - READING → ALLOWED. That is when one process is reading the file, and other process or processes is willing to read, then they all are allowed i.e. reading - reading is not mutually exclusive. Let us see that our code is working accordingly or not? Explanation : Initial value of semaphore mutex = 1 and variable readcount = 0 Suppose three processes P0, P1 and P2 are in a system, all the three processes P0, P1, and P2 want to read, let P0 enter first into the reader code, the moment P0 enters Wait( mutex ); will decrease semaphore mutex by 1, now mutex = 0 Increment readcount by 1, now readcount = 1, next if (readcount == 1)// evaluates to TRUE { wait (write); // decrement write by 1, i.e. write = 0(which clearly proves that if one or more than one reader is reading then no writer will be allowed. } signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to enter. And P0 continues to --READ THE FILE? →Now P1 wants to enter the reader code current value of semaphore mutex = 1 and variable readcount = 1 let P1 enter into the reader code, the moment P1 enters Wait( mutex ); will decrease semaphore mutex by 1, now mutex = 0 Increment readcount by 1, now readcount = 2, next if (readcount == 1)// eval. to False, it will not enter if block signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to enter. Now P0 and P1 continues to --READ THE FILE? →Now P2 wants to enter the reader code current value of semaphore mutex = 1 and variable readcount = 2 let P2 enter into the reader code, The moment P2 enters Wait( mutex ); will decrease semaphore mutex by 1, now mutex = 0 Increment readcount by 1, now readcount = 3, next if (readcount == 1)// eval. to False, it will not enter if block signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to enter. Now P0, P1, and P2 continues to --READ THE FILE? Suppose now any writer wants to enter into its code then: As the first reader P0 has executed wait (write); because of which write value is 0, therefore wait(writer); of the writer, code will go into an infinite loop and no writer will be allowed. Now suppose P0 wants to come out of system( stop reading) then wait(mutex); //will decrease semaphore mutex by 1, now mutex = 0 readcount --; // on every exit of reader decrement readcount by one i.e. readcount = 2 if (readcount == 0)// eval. to FALSE it will not enter if block signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to exit → Now suppose P1 wants to come out of system (stop reading) then wait(mutex); //will decrease semaphore mutex by 1, now mutex = 0 readcount --; // on every exit of reader decrement readcount by one i.e. readcount = 1 if (readcount == 0)// eval. to FALSE it will not enter if block signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 i.e. other readers are allowed to exit →Now suppose P2 (last process) wants to come out of system (stop reading) then wait(mutex); //will decrease semaphore mutex by 1, now mutex = 0 readcount --; // on every exit of reader decrement readcount by one i.e. readcount = 0 if (readcount == 0)// eval. to TRUE it will enter into if block { signal (write); // will increment semaphore write by one, i.e. now write = 1, since P2 was the last process which was reading, since now it is going out, so by making write = 1 it is allowing the writer to write now. } signal(mutex); // will increase semaphore mutex by 1, now mutex = 1 The above explanation proves that if one or more than one processes are willing to read simultaneously then they are allowed. Next Topic Banker's Algorithm in Operating System



← prev next →



"
291,"next → ← prev History of the Operating System Operating System The operating system is a system program that serves as an interface between the computing system and the end-user. Operating systems create an environment where the user can run any programs or communicate with software or applications in a comfortable and well-organized way. Furthermore, an operating is a software program that manages and controls the execution of application programs, software resources and computer hardware. It also helps manage the software/hardware resource, such as file management, memory management, input/ output and many peripheral devices like a disk drive, printers, etc. These are the popular operating system: Linux OS, Windows OS, Mac OS, VMS, OS/400 etc. Functions of Operating System Processor management

Act as a Resource Manager

Memory Management

File Management

Security

Device Management

Input devices / Output devices

Deadlock Prevention

Time Management

Coordinate with system software or hardware Types of Operating System Batch Operating System Time-Sharing Operating System Embedded Operating System Multiprogramming Operating System Network Operating System Distributed Operating System Multiprocessing Operating System Real-Time Operating System Batch Operating System In Batch Operating System, there is no direct interaction between user and computer. Therefore, the user needs to prepare jobs and save offline mode to punch card or paper tape or magnetic tape. After creating the jobs, hand it over to the computer operator; then the operator sort or creates the similar types of batches like B2, B3, and B4. Now, the computer operator submits batches into the CPU to execute the jobs one by one. After that, CPUs start executing jobs, and when all jobs are finished, the computer operator provides the output to the user. Time-Sharing Operating System It is the type of operating system that allows us to connect many people located at different locations to share and use a specific system at a single time. The time-sharing operating system is the logical extension of the multiprogramming through which users can run multiple tasks concurrently. Furthermore, it provides each user his terminal for input or output that impacts the program or processor currently running on the system. It represents the CPU's time is shared between many user processes. Or, the processor's time that is shared between multiple users simultaneously termed as time-sharing. Embedded Operating System The Embedded operating system is the specific purpose operating system used in the computer system's embedded hardware configuration. These operating systems are designed to work on dedicated devices like automated teller machines (ATMs), airplane systems, digital home assistants, and the internet of things (IoT) devices. Multiprogramming Operating System Due to the CPU's underutilization and the waiting for I/O resource till that CPU remains idle. It shows the improper use of system resources. Hence, the operating system introduces a new concept that is known as multiprogramming. A multiprogramming operating system refers to the concepts wherein two or more processes or programs activate simultaneously to execute the processes one after another by the same computer system. When a program is in run mode and uses CPU, another program or file uses I/O resources at the same time or waiting for another system resources to become available. It improves the use of system resources, thereby increasing system throughput. Such a system is known as a multiprogramming operating system. Network Operating System A network operating system is an important category of the operating system that operates on a server using network devices like a switch, router, or firewall to handle data, applications and other network resources. It provides connectivity among the autonomous operating system, called as a network operating system. The network operating system is also useful to share data, files, hardware devices and printer resources among multiple computers to communicate with each other. Types of network operating system Peer-to-peer network operating system: The type of network operating system allows users to share files, resources between two or more computer machines using a LAN.



The type of network operating system allows users to share files, resources between two or more computer machines using a LAN. Client-Server network operating system: It is the type of network operating system that allows the users to access resources, functions, and applications through a common server or center hub of the resources. The client workstation can access all resources that exist in the central hub of the network. Multiple clients can access and share different types of the resource over the network from different locations.

Distributed Operating system A distributed operating system provides an environment in which multiple independent CPU or processor communicates with each other through physically separate computational nodes. Each node contains specific software that communicates with the global aggregate operating system. With the ease of a distributed system, the programmer or developer can easily access any operating system and resource to execute the computational tasks and achieve a common goal. It is the extension of a network operating system that facilitates a high degree of connectivity to communicate with other users over the network. Multiprocessing Operating System It is the type of operating system that refers to using two or more central processing units (CPU) in a single computer system. However, these multiprocessor systems or parallel operating systems are used to increase the computer system's efficiency. With the use of a multiprocessor system, they share computer bus, clock, memory and input or output device for concurrent execution of process or program and resource management in the CPU. Real-Time Operating System A real-time operating system is an important type of operating system used to provide services and data processing resources for applications in which the time interval required to process & respond to input/output should be so small without any delay real-time system. For example, real-life situations governing an automatic car, traffic signal, nuclear reactor or an aircraft require an immediate response to complete tasks within a specified time delay. Hence, a real-time operating system must be fast and responsive for an embedded system, weapon system, robots, scientific research & experiments and various real-time objects. Types of the real-time operating system: Hard Real-Time System

These types of OS are used with those required to complete critical tasks within the defined time limit. If the response time is high, it is not accepted by the system or may face serious issues like a system failure. In a hard real-time system, the secondary storage is either limited or missing, so these system stored data in the ROM.

These types of OS are used with those required to complete critical tasks within the defined time limit. If the response time is high, it is not accepted by the system or may face serious issues like a system failure. In a hard real-time system, the secondary storage is either limited or missing, so these system stored data in the ROM. Soft Real-Time System

A soft real-time system is a less restrictive system that can accept software and hardware resources delays by the operating system. In a soft real-time system, a critical task prioritizes less important tasks, and that priority retains active until completion of the task. Also, a time limit is set for a specific job, which enables short time delays for further tasks that are acceptable. For example, computer audio or video, virtual reality, reservation system, projects like undersea, etc. Generations of Operating System The First Generation (1940 to early 1950s) When the first electronic computer was developed in 1940, it was created without any operating system. In early times, users have full access to the computer machine and write a program for each task in absolute machine language. The programmer can perform and solve only simple mathematical calculations during the computer generation, and this calculation does not require an operating system. The Second Generation (1955 - 1965) The first operating system (OS) was created in the early 1950s and was known as GMOS. General Motors has developed OS for the IBM computer. The second-generation operating system was based on a single stream batch processing system because it collects all similar jobs in groups or batches and then submits the jobs to the operating system using a punch card to complete all jobs in a machine. At each completion of jobs (either normally or abnormally), control transfer to the operating system that is cleaned after completing one job and then continues to read and initiates the next job in a punch card. After that, new machines were called mainframes, which were very big and used by professional operators. The Third Generation (1965 - 1980) During the late 1960s, operating system designers were very capable of developing a new operating system that could simultaneously perform multiple tasks in a single computer program called multiprogramming. The introduction of multiprogramming plays a very important role in developing operating systems that allow a CPU to be busy every time by performing different tasks on a computer at the same time. During the third generation, there was a new development of minicomputer's phenomenal growth starting in 1961 with the DEC PDP-1. These PDP's leads to the creation of personal computers in the fourth generation. The Fourth Generation (1980 - Present Day) The fourth generation of operating systems is related to the development of the personal computer. However, the personal computer is very similar to the minicomputers that were developed in the third generation. The cost of a personal computer was very high at that time; there were small fractions of minicomputers costs. A major factor related to creating personal computers was the birth of Microsoft and the Windows operating system. Microsoft created the first window operating system in 1975. After introducing the Microsoft Windows OS, Bill Gates and Paul Allen had the vision to take personal computers to the next level. Therefore, they introduced the MS-DOS in 1981; however, it was very difficult for the person to understand its cryptic commands. Today, Windows has become the most popular and most commonly used operating system technology. And then, Windows released various operating systems such as Windows 95, Windows 98, Windows XP and the latest operating system, Windows 7. Currently, most Windows users use the Windows 10 operating system. Besides the Windows operating system, Apple is another popular operating system built in the 1980s, and this operating system was developed by Steve Jobs, a co-founder of Apple. They named the operating system Macintosh OS or Mac OS. Advantages of Operating System It is helpful to monitor and regulate resources.

It can easily operate since it has a basic graphical user interface to communicate with your device.

It is used to create interaction between the users and the computer application or hardware.

The performance of the computer system is based on the CPU.

The response time and throughput time of any process or program are fast.

It can share different resources like fax, printer, etc.

It also offers a forum for various types of applications like system and web application. Disadvantage of the Operating System It allows only a few tasks that can run at the same time.

It any error occurred in the operating system; the stored data can be destroyed.

It is a very difficult task or works for the OS to provide entire security from the viruses because any threat or virus can occur at any time in a system.

An unknown user can easily use any system without the permission of the original user.

The cost of operating system costs is very high. Next Topic Types of OS



← prev next →



"
292,"next → ← prev Banker's Algorithm in Operating System It is a banker algorithm used to avoid deadlock and allocate resources safely to each process in the computer system. The 'S-State' examines all possible tests or activities before deciding whether the allocation should be allowed to each process. It also helps the operating system to successfully share the resources between all the processes. The banker's algorithm is named because it checks whether a person should be sanctioned a loan amount or not to help the bank system safely simulate allocation resources. In this section, we will learn the Banker's Algorithm in detail. Also, we will solve problems based on the Banker's Algorithm. To understand the Banker's Algorithm first we will see a real word example of it. Suppose the number of account holders in a particular bank is 'n', and the total money in a bank is 'T'. If an account holder applies for a loan; first, the bank subtracts the loan amount from full cash and then estimates the cash difference is greater than T to approve the loan amount. These steps are taken because if another person applies for a loan or withdraws some amount from the bank, it helps the bank manage and operate all things without any restriction in the functionality of the banking system. Similarly, it works in an operating system. When a new process is created in a computer system, the process must provide all types of information to the operating system like upcoming processes, requests for their resources, counting them, and delays. Based on these criteria, the operating system decides which process sequence should be executed or waited so that no deadlock occurs in a system. Therefore, it is also known as deadlock avoidance algorithm or deadlock detection in the operating system. Advantages Following are the essential characteristics of the Banker's algorithm: It contains various resources that meet the requirements of each process. Each process should provide information to the operating system for upcoming resource requests, the number of resources, and how long the resources will be held. It helps the operating system manage and control process requests for each type of resource in the computer system. The algorithm has a Max resource attribute that represents indicates each process can hold the maximum number of resources in a system. Disadvantages It requires a fixed number of processes, and no additional processes can be started in the system while executing the process. The algorithm does no longer allows the processes to exchange its maximum needs while processing its tasks. Each process has to know and state their maximum resource requirement in advance for the system. The number of resource requests can be granted in a finite time, but the time limit for allocating the resources is one year. When working with a banker's algorithm, it requests to know about three things: How much each process can request for each resource in the system. It is denoted by the [MAX] request. How much each process is currently holding each resource in a system. It is denoted by the [ALLOCATED] resource. It represents the number of each resource currently available in the system. It is denoted by the [AVAILABLE] resource. Following are the important data structures terms applied in the banker's algorithm as follows: Suppose n is the number of processes, and m is the number of each type of resource used in a computer system. Available: It is an array of length 'm' that defines each type of resource available in the system. When Available[j] = K, means that 'K' instances of Resources type R[j] are available in the system. Max: It is a [n x m] matrix that indicates each process P[i] can store the maximum number of resources R[j] (each type) in a system. Allocation: It is a matrix of m x n orders that indicates the type of resources currently allocated to each process in the system. When Allocation [i, j] = K, it means that process P[i] is currently allocated K instances of Resources type R[j] in the system. Need: It is an M x N matrix sequence representing the number of remaining resources for each process. When the Need[i] [j] = k, then process P[i] may require K more instances of resources type Rj to complete the assigned work.

Nedd[i][j] = Max[i][j] - Allocation[i][j]. Finish: It is the vector of the order m. It includes a Boolean value (true/false) indicating whether the process has been allocated to the requested resources, and all resources have been released after finishing its task. The Banker's Algorithm is the combination of the safety algorithm and the resource request algorithm to control the processes and avoid deadlock in a system: Safety Algorithm It is a safety algorithm used to check whether or not a system is in a safe state or follows the safe sequence in a banker's algorithm: 1. There are two vectors Wok and Finish of length m and n in a safety algorithm. Initialize: Work = Available

Finish[i] = false; for I = 0, 1, 2, 3, 4… n - 1. 2. Check the availability status for each type of resources [i], such as: Need[i] <= Work

Finish[i] == false

If the i does not exist, go to step 4. 3. Work = Work +Allocation(i) // to get new resource allocation Finish[i] = true Go to step 2 to check the status of resource availability for the next process. 4. If Finish[i] == true; it means that the system is safe for all processes. Resource Request Algorithm A resource request algorithm checks how a system will behave when a process makes each type of resource request in a system as a request matrix. Let create a resource request array R[i] for each process P[i]. If the Resource Request i [j] equal to 'K', which means the process P[i] requires 'k' instances of Resources type R[j] in the system. 1. When the number of requested resources of each type is less than the Need resources, go to step 2 and if the condition fails, which means that the process P[i] exceeds its maximum claim for the resource. As the expression suggests: If Request(i) <= Need

Go to step 2; 2. And when the number of requested resources of each type is less than the available resource for each process, go to step (3). As the expression suggests: If Request(i) <= Available

Else Process P[i] must wait for the resource since it is not available for use. 3. When the requested resource is allocated to the process by changing state: Available = Available - Request

Allocation(i) = Allocation(i) + Request (i)

Need i = Need i - Request i When the resource allocation state is safe, its resources are allocated to the process P(i). And if the new state is unsafe, the Process P (i) has to wait for each type of Request R(i) and restore the old resource-allocation state. Example: Consider a system that contains five processes P1, P2, P3, P4, P5 and the three resource types A, B and C. Following are the resources types: A has 10, B has 5 and the resource type C has 7 instances. Process Allocation

A B C Max

A B C Available

A B C P1 0 1 0 7 5 3 3 3 2 P2 2 0 0 3 2 2 P3 3 0 2 9 0 2 P4 2 1 1 2 2 2 P5 0 0 2 4 3 3 Answer the following questions using the banker's algorithm: What is the reference of the need matrix? Determine if the system is safe or not. What will happen if the resource request (1, 0, 0) for process P1 can the system accept this request immediately? Ans. 2: Context of the need matrix is as follows: Need [i] = Max [i] - Allocation [i]

Need for P1: (7, 5, 3) - (0, 1, 0) = 7, 4, 3

Need for P2: (3, 2, 2) - (2, 0, 0) = 1, 2, 2

Need for P3: (9, 0, 2) - (3, 0, 2) = 6, 0, 0

Need for P4: (2, 2, 2) - (2, 1, 1) = 0, 1, 1

Need for P5: (4, 3, 3) - (0, 0, 2) = 4, 3, 1 Process Need

A B C P1 7 4 3 P2 1 2 2 P3 6 0 0 P4 0 1 1 P5 4 3 1 Hence, we created the context of need matrix. Ans. 2: Apply the Banker's Algorithm: Available Resources of A, B and C are 3, 3, and 2. Now we check if each type of resource request is available for each process. Step 1: For Process P1: Need <= Available 7, 4, 3 <= 3, 3, 2 condition is false. So, we examine another process, P2. Step 2: For Process P2: Need <= Available 1, 2, 2 <= 3, 3, 2 condition true New available = available + Allocation (3, 3, 2) + (2, 0, 0) => 5, 3, 2 Similarly, we examine another process P3. Step 3: For Process P3: P3 Need <= Available 6, 0, 0 < = 5, 3, 2 condition is false. Similarly, we examine another process, P4. Step 4: For Process P4: P4 Need <= Available 0, 1, 1 <= 5, 3, 2 condition is true New Available resource = Available + Allocation 5, 3, 2 + 2, 1, 1 => 7, 4, 3 Similarly, we examine another process P5. Step 5: For Process P5: P5 Need <= Available 4, 3, 1 <= 7, 4, 3 condition is true New available resource = Available + Allocation 7, 4, 3 + 0, 0, 2 => 7, 4, 5 Now, we again examine each type of resource request for processes P1 and P3. Step 6: For Process P1: P1 Need <= Available 7, 4, 3 <= 7, 4, 5 condition is true New Available Resource = Available + Allocation 7, 4, 5 + 0, 1, 0 => 7, 5, 5 So, we examine another process P2. Step 7: For Process P3: P3 Need <= Available 6, 0, 0 <= 7, 5, 5 condition is true New Available Resource = Available + Allocation 7, 5, 5 + 3, 0, 2 => 10, 5, 7 Hence, we execute the banker's algorithm to find the safe state and the safe sequence like P2, P4, P5, P1 and P3. Ans. 3: For granting the Request (1, 0, 2), first we have to check that Request <= Available, that is (1, 0, 2) <= (3, 3, 2), since the condition is true. So the process P1 gets the request immediately. Next Topic Operating System MCQ



← prev next →



"
293,"next → ← prev Operating System MCQ 1) Which of the following is not an operating system? Windows Linux Oracle DOS Show Answer Workspace Answer: (c) Oracle Explanation: Oracle is an RDBMS (Relational Database Management System). It is known as Oracle Database, Oracle DB, or Oracle Only. The first database for enterprise grid computing is the Oracle database. 2) What is the maximum length of the filename in DOS? 4 5 8 12 Show Answer Workspace Answer: (c) 8 Explanation: The maximum length of the filename is 8 characters in the DOS operating system. It is commonly known as an 8.3 filename. 3) When was the first operating system developed? 1948 1949 1950 1951 Show Answer Workspace Answer: (c) 1950 Explanation: The first operating system was developed in the early 1950's. It was also called a single-stream batch processing system because it presented data in groups. 4) When were MS windows operating systems proposed? 1994 1990 1992 1985 Show Answer Workspace Answer: (d) 1985 Explanation: The first MS Windows operating system was introduced in early 1985. 5) Which of the following is the extension of Notepad? .txt .xls .ppt .bmp Show Answer Workspace Answer: (a) .txt Explanation: The .txt file extension is a standard text document extension that contains the unformatted text. It is the default file extension for the notepad. 6) What else is a command interpreter called? prompt kernel shell command Show Answer Workspace Answer: (c) shell Explanation: The command interpreter is also called the shell. 7) What is the full name of FAT? File attribute table File allocation table Font attribute table Format allocation table Show Answer Workspace Answer: (b) File allocation table. Explanation: The FAT stands for File allocation table. The FAT is a file system architecture. It is used in computer systems and memory cards. A FAT of the contents of a computer disk indicates which field is used for which file. 8) BIOS is used? By operating system By compiler By interpreter By application software Show Answer Workspace Answer: (a) By operating system Explanation: BIOS is used by the operating system. It is used to configure and identify the hardware in a system such as the hard drive, floppy drive, optical drive, CPU, and memory. 9) What is the mean of the Booting in the operating system? Restarting computer Install the program To scan To turn off Show Answer Workspace Answer: (a) Restarting computer Explanation: Booting is a process of the restart the computer. After restarting it, there is no software in the computer's main memory. 10) When does page fault occur? The page is present in memory. The deadlock occurs. The page does not present in memory. The buffering occurs. Show Answer Workspace Answer: (c) The page does not present in memory. Explanation: Page faults occur when a process tries to access a block page of the memory and that page is not stored in RAM (Read only memory) or memory. 11) Banker's algorithm is used? To prevent deadlock To deadlock recovery To solve the deadlock None of these Show Answer Workspace Answer: (a) To prevent deadlock Explanation: Banker's algorithm is used to prevent the deadlock condition. The banker algorithm is sometimes called the detection algorithm. It is named the banker algorithm because it is used to determine whether a loan can be granted in the banking system or not. 12) When you delete a file in your computer, where does it go? Recycle bin Hard disk Taskbar None of these Show Answer Workspace Answer: (a) Recycle bin Explanation: When you delete a file on your computer device, it is transferred to your computer system's recycle bin or trash. 13) Which is the Linux operating system? Private operating system Windows operating system Open-source operating system None of these Show Answer Workspace Answer: (c) Open-source operating system Explanation: The Linux operating system is an open-source operating system made up of a kernel. It is a very safe operating system. 14) What is the full name of the DSM? Direct system module Direct system memory Demoralized system memory Distributed shared memory Show Answer Workspace Answer: (d) Distributed shared memory Explanation: The DSM stands for Distributed Shared Memory. 15) What is the full name of the IDL? Interface definition language Interface direct language Interface data library None of these Show Answer Workspace Answer: (a) Interface definition language Explanation: The IDL stands for Interface Definition Language. It is used to establish communications between clients and servers in RPC (Remote Procedure Call). 16) What is bootstrapping called? Cold boot Cold hot boot Cold hot strap Hot boot Show Answer Workspace Answer: (a) Cold boot Explanation: Bootstrapping is also known as the cool boot. 17) What is the fence register used for? To disk protection To CPU protection To memory protection None of these Show Answer Workspace Answer: (c) To memory protection Explanation: The fence register is used for memory protection on the computer. It is a way to access the memory in the computer. 18) If the page size increases, the internal fragmentation is also?..? Decreases Increases Remains constant None of these Show Answer Workspace Answer: (b) Increases Explanation: None 19) Which of the following is a single-user operating system? Windows MAC Ms-Dos None of these Show Answer Workspace Answer: (c) Ms-Dos Explanation: The single-user operating system is the operating system in which only one user can access the computer system at a time, and Ms-DOS is the best example of a single-user operating system. 20) The size of virtual memory is based on which of the following? CPU RAM Address bus Data bus Show Answer Workspace Answer: (c) Address bus Explanation: The size of virtual memory is based on the address bus. 21) If a page number is not found in the translation lookaside buffer, then it is known as a? Translation Lookaside Buffer miss Buffer miss Translation Lookaside Buffer hit All of the mentioned Show Answer Workspace Answer: (a) Translation Lookaside Buffer miss Explanation: A Translation Lookaside Buffer miss arises when the page table entry needed to translate a virtual address to a physical address is not available in the translation lookaside buffer. 22) Which of the following is not application software? Windows 7 WordPad Photoshop MS-excel Show Answer Workspace Answer: (a) Windows 7 Explanation: Windows 7 is not an application software because it is a operating system. 23) Which of the following supports Windows 64 bit? Window XP Window 2000 Window 1998 None of these Show Answer Workspace Answer: (a) Window XP Explanation: Windows XP supports the 64-bits. Windows XP is designed to expand the memory address space. Its original name is Microsoft Windows XP Professional x64 and it is based on the x86-64 architecture. 24) Which of the following windows does not have a start button? Windows 7 Windows 8 Windows XP None of these Show Answer Workspace Answer: (b) Windows 8 Explanation: Windows 8 does not have a start button because it uses the tablet mode, but windows 8.1 has a start button. 25) Which of the following operating systems does not support more than one program at a time? Linux Windows MAC DOS Show Answer Workspace Answer: (d) DOS Explanation: DOS stands for Disk operating system. Disk operating system is a single-user operating system that does not support more than one program at a time. 26) Which of the following is a condition that causes deadlock? Mutual exclusion Hold and wait Circular wait No preemption All of these Show Answer Workspace Answer: (e) All of these Explanation: None 27) Who provides the interface to access the services of the operating system? API System call Library Assembly instruction Show Answer Workspace Answer: (b) System call Explanation: The system call provides an interface for user programs to access the services of the operating system through the API (Application Program Interface). 28) Where are placed the list of processes that are prepared to be executed and waiting? Job queue Ready queue Execution queue Process queue Show Answer Workspace Answer: (b) Ready queue Explanation: The ready queue is a set of all the processes that processes are ready to execute and wait. 29) Who among the following can block the running process? Fork Read Down All of these Show Answer Workspace Answer: (d) All of these Explanation: None 30) Which of the following does not interrupt the running process? Timer interrupt Device Power failure Scheduler process Show Answer Workspace Answer: (b) Scheduler process Explanation: Scheduler process does not interrupt in any running process. Its job is to select the processes for long-term, short-term, and short-term scheduler. 31) What is Microsoft window? Operating system Graphics program Word Processing Database program Show Answer Workspace Answer: (a) Operating system Explanation: Microsoft Windows is an operating system that was developed by Microsoft company. The Microsoft Windows is available in 32-bits and 64-bits in the market. 32) Which of the following is group of programs? Accessories Paint Word All of above Show Answer Workspace Answer: (a) Accessories Explanation: The windows accessories are a group of programs in the operating system. Windows XP offers many accessories or software that you can use to help with your work. The accessories are not full features programs, but it is useful for a specific task in the operating systems. It provides many programs such as a painting program, a calculator, a word processor, a notepad, and Internet software. 33) Which of the following is an example of a Real Time Operating System? MAC MS-DOS Windows 10 Process Control Show Answer Workspace Answer: (d) Process Control Explanation: Process control is a best example of a Real time operating system. 34) Which of the following operating systems do you use for a client-server network? MAC Linux Windows XP Windows 2000 Show Answer Workspace Answer: (d) Windows 2000 Explanation: Windows 2002 operating systems were used to implement a client Server Network. It is a server OS that was developed by Microsoft in April 24, 2002. It includes some features of Windows XP. 35) Which windows was introduced to My Computer? Windows 10 Windows XP Windows 95 Windows 98 Show Answer Workspace Answer: (c) Windows 95 Explanation: Windows 95 was first window to introduced the My Computer. 36) What type of commands are required to perform various tasks in DOS? Internal commands External commands Valuable commands Primary commands Show Answer Workspace Answer: (b) External commands Explanation: External commands are required to perform various tasks in DOS. 37) What is the number of characters contained in the primary name of the file of MS-DOS? Up to 8 characters 3 characters Up to 10 characters None of the above Show Answer Workspace Answer: (a) Up to 8 characters Explanation: MS-DOS operating system uses the file system that supports the 8.3 characters. The eight characters are used to the filename, and three characters are used to the extension. 38) Which command is used to fetch a group (.doc) of files that have just been deleted? Undelete Undelete/all Undelete *.doc All of above Show Answer Workspace Answer: (c) Undelete *.doc Explanation: Undelete *.doc command is used to fetch a group (.doc) of files that have just been deleted. 39) Which of the following is system software? Operating system Compiler Utilities All of the above Show Answer Workspace Answer: (d) All of the above Explanation: The system software is a type of computer program designed to run hardware and software programs on a computer. According to some definitions, system software also includes system utilities, system restore, development tools, compilers, and debuggers. 40) Which program runs first after booting the computer and loading the GUI? Desktop Manager File Manager Windows Explorer Authentication Show Answer Workspace Answer: (d) Authentication Explanation: The authentication program is run first after booting the computer and loading the GUI. Authentication is a process of verifying the person or device. For example, when you log in to Facebook, you enter a username and password. Next Topic Operating System Tutorial



← prev next →



"
